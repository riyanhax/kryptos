(function(b, a) {
    if (typeof module != "undefined") {
        module.exports = a(MindFusion)
    } else {
        if (typeof define == "function" && typeof define.amd == "object") {
            define(b, a)
        } else {
            return a(MindFusion)
        }
    }
}(["MindFusion.Common"], function(MindFusion) {
    MindFusion.registerNamespace("MindFusion.Animations");
    MindFusion.Animations.AnimationType = {
        Linear: 0,
        Power: 1,
        Exponential: 2,
        Circular: 3,
        BackBow: 4,
        Bounce: 5,
        Elastic: 6,
        Custom: 7
    };
    MindFusion.Animations.EasingType = {
        EaseIn: 0,
        EaseOut: 1,
        EaseInOut: 2,
        EaseOutIn: 3
    };
    (function(manim) {
        var Animation = manim.Animation = function(item, options, onUpdateCallback, onCustomFunctionCallback) {
            this.item = item;
            this.duration = 1000;
            this.fromValue = null;
            this.toValue = null;
            this.animationType = manim.AnimationType.Linear;
            this.param = null;
            this.easingType = manim.EasingType.EaseIn;
            this.repeat = false;
            this.reverse = false;
            this.onUpdateDelegate = mflayer.createDelegate(this, onUpdateCallback || this.onUpdate);
            this.onCustomFunctionDelegate = mflayer.createDelegate(this, onCustomFunctionCallback || this.onCustomFunction);
            if (options) {
                if (options.duration != null) {
                    this.duration = options.duration
                }
                if (options.fromValue != null) {
                    this.fromValue = options.fromValue
                }
                if (options.toValue != null) {
                    this.toValue = options.toValue
                }
                if (options.animationType) {
                    this.animationType = options.animationType
                }
                if (options.param != null) {
                    this.param = options.param
                } else {
                    if (this.animationType == manim.AnimationType.Power) {
                        this.param = 2
                    } else {
                        if (this.animationType == manim.AnimationType.BackBow) {
                            this.param = 1.5
                        } else {
                            if (this.animationType == manim.AnimationType.Elastic) {
                                this.param = 0.5
                            } else {
                                if (this.animationType == manim.AnimationType.Exponential) {
                                    this.param = 10
                                }
                            }
                        }
                    }
                }
                if (options.easingType) {
                    this.easingType = options.easingType
                }
                if (options.repeat != null) {
                    this.repeat = options.repeat
                }
                if (options.reverse != null) {
                    this.reverse = options.reverse
                }
            }
            this.ellapsedTime = 0;
            this.progress = 0;
            this.animationId = null;
            this.eventHandlers = mflayer.eventHandlerList();
            mflayer.registerDisposableObject(this)
        };
        Animation.prototype = {
            dispose: function() {
                this.stop()
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            },
            removeEventListener: function(eventName, handler) {
                mflayer.removeHandler(this, eventName, handler)
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler != null) {
                    handler(this, args)
                }
            },
            start: function() {
                this.startTimeStamp = new Date().getTime();
                this.animationId = Animation.requestAnimationFrame(this.update.bind(this))
            },
            stop: function() {
                if (this.animationId != null) {
                    Animation.cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    this.raiseEvent(manim.Events.animationComplete, MindFusion.EventArgs.Empty)
                }
            },
            isRunning: function() {
                return this.animationId != null
            },
            getProgress: function() {
                if (this.isRunning()) {
                    return this.progress
                }
                return 0
            },
            animationProgress: function(progress) {
                if (progress === 0) {
                    return 0
                }
                if (progress === 1) {
                    return 1
                }
                switch (this.animationType) {
                    case manim.AnimationType.Linear:
                        return progress;
                    case manim.AnimationType.Power:
                        return Math.pow(progress, this.param);
                    case manim.AnimationType.Exponential:
                        return (Math.pow(Math.E, this.param * progress) - 1) / (Math.pow(Math.E, this.param) - 1);
                    case manim.AnimationType.Circular:
                        return 1 - Math.sin(Math.acos(progress));
                    case manim.AnimationType.BackBow:
                        return Math.pow(progress, 2) * ((this.param + 1) * progress - this.param);
                    case manim.AnimationType.Bounce:
                        var a = 0,
                            b = 1;
                        while (true) {
                            if (progress >= (7 - 4 * a) / 11) {
                                return -Math.pow((11 - 6 * a - 11 * progress) / 4, 2) + Math.pow(b, 2)
                            }
                            a += b;
                            b /= 2
                        }
                    case manim.AnimationType.Elastic:
                        return Math.pow(2, 10 * (progress - 1)) * Math.cos(20 * Math.PI * this.param * progress);
                    case manim.AnimationType.Custom:
                        return this.onCustomFunctionDelegate(progress, this.param)
                }
            },
            onCustomFunction: function(progress, prm) {
                return progress
            },
            easeIn: function(progress) {
                return this.animationProgress(progress)
            },
            easeOut: function(progress) {
                return 1 - this.animationProgress(1 - progress)
            },
            easeInOut: function(progress) {
                if (progress <= 0.5) {
                    return this.easeIn(progress * 2) / 2
                } else {
                    return this.easeOut((progress - 0.5) * 2) / 2 + 0.5
                }
            },
            easeOutIn: function(progress) {
                if (progress <= 0.5) {
                    return this.easeOut(progress * 2) / 2
                } else {
                    return this.easeIn((progress - 0.5) * 2) / 2 + 0.5
                }
            },
            update: function() {
                this.animationId = Animation.requestAnimationFrame(this.update.bind(this));
                this.ellapsedTime = new Date().getTime();
                this.progress = (this.ellapsedTime - this.startTimeStamp) / this.duration;
                if (this.progress >= 1) {
                    this.progress = 1
                }
                switch (this.easingType) {
                    case manim.EasingType.EaseIn:
                        this.onUpdateDelegate(this, this.easeIn(this.progress));
                        break;
                    case manim.EasingType.EaseOut:
                        this.onUpdateDelegate(this, this.easeOut(this.progress));
                        break;
                    case manim.EasingType.EaseInOut:
                        this.onUpdateDelegate(this, this.easeInOut(this.progress));
                        break;
                    case manim.EasingType.EaseOutIn:
                        this.onUpdateDelegate(this, this.easeOutIn(this.progress));
                        break
                }
                if (this.progress == 1) {
                    if (this.repeat) {
                        this.progress = 0;
                        this.startTimeStamp = new Date().getTime()
                    } else {
                        this.stop()
                    }
                    if (this.reverse) {
                        var temp = this.toValue;
                        this.toValue = this.fromValue;
                        this.fromValue = temp
                    }
                }
            },
            onUpdate: function(animation, animationDelta) {
                if (animation.item.updateAnimation) {
                    animation.item.updateAnimation(animation, animationDelta)
                }
            },
            getDuration: function() {
                return this.duration
            },
            setDuration: function(value) {
                if (this.duration != value) {
                    this.duration = value
                }
            },
            getFromValue: function() {
                return this.fromValue
            },
            setFromValue: function(value) {
                if (this.fromValue != value) {
                    this.fromValue = value
                }
            },
            getToValue: function() {
                return this.toValue
            },
            setToValue: function(value) {
                if (this.toValue != value) {
                    this.toValue = value
                }
            },
            getAnimationType: function() {
                return this.animationType
            },
            setAnimationType: function(value) {
                if (this.animationType != value) {
                    this.animationType = value
                }
            },
            getParam: function() {
                return this.param
            },
            setParam: function(value) {
                if (this.param != value) {
                    this.param = value
                }
            },
            getEasingType: function() {
                return this.easingType
            },
            setEasingType: function(value) {
                if (this.easingType != value) {
                    this.easingType = value
                }
            },
            getRepeat: function() {
                return this.repeat
            },
            setRepeat: function(value) {
                if (this.repeat != value) {
                    this.repeat = value
                }
            },
            getReverse: function() {
                return this.reverse
            },
            setReverse: function(value) {
                if (this.reverse != value) {
                    this.reverse = value
                }
            }
        };
        Animation.requestAnimationFrame = (function() {
            if (typeof window === "undefined") {
                return
            }
            var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                return window.setTimeout(callback, 1000 / 60)
            };
            return raf.bind(window)
        })();
        Animation.cancelAnimationFrame = (function() {
            if (typeof window === "undefined") {
                return
            }
            var caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(id) {
                window.clearTimeout(id)
            };
            return caf.bind(window)
        })();
        MindFusion.registerClass(Animation, "MindFusion.Animations.Animation", null, "Sys.IDisposable")
    })(MindFusion.Animations);
    MindFusion.Animations.Events = {
        animationComplete: "animationComplete"
    };
    MindFusion.registerNamespace("MindFusion.Graphs");
    if (typeof $skipLayout == "undefined") {
        $skipLayout = {}
    }(function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Set = MindFusion.Collections.Set;
        var BorderedTreeLayout = mg.BorderedTreeLayout = function() {
            this.levelDistance = 10;
            this.nodeDistance = 10;
            this.keepRootPosition = false;
            this.direction = mg.LayoutDirection.TopToBottom;
            this.linkType = mg.TreeLayoutLinkType.Default;
            this.anchoring = mg.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = mg.MultipleGraphsPlacement.Horizontal
        };
        BorderedTreeLayout.prototype.setsLinkPoints = true;
        BorderedTreeLayout.prototype.setsLinkEndPoints = true;
        BorderedTreeLayout.prototype.requiresConnectedGraph = true;
        BorderedTreeLayout.prototype.requiresSimpleGraph = false;
        BorderedTreeLayout.prototype.margins = 10;
        BorderedTreeLayout.prototype.requiresCascadingLinks = function() {
            return this.linkType == mg.TreeLayoutLinkType.Cascading
        };
        BorderedTreeLayout.prototype.isStatic = function() {
            return this.keepRootPosition
        };
        BorderedTreeLayout.prototype.arrange = function(graph) {
            var root;
            graph.vertices.forEach(function(v) {
                if (v.inEdges.length == 0) {
                    root = v;
                    return $break
                }
            });
            if (!root) {
                return $skipLayout
            }
            this.tree = graph.tree(root);
            if (!this.tree) {
                return $skipLayout
            }
            var rootX = root.x + root.width / 2;
            var rootY = root.y + root.height / 2;
            this.x = 0;
            this.y = 0;
            this.rarrange(root);
            var levelSizes = new ArrayList();
            for (var i = 0; i < this.tree.treeLevels.length; i++) {
                var treeLevel = this.tree.treeLevels[i];
                var sz = 0;
                for (var j = 0; j < treeLevel.length; j++) {
                    if (this.isHorizontal()) {
                        sz = Math.max(sz, treeLevel[j].width)
                    } else {
                        sz = Math.max(sz, treeLevel[j].height)
                    }
                }
                levelSizes.push(sz)
            }
            var off = 0;
            var size = 0;
            for (var l = 1; l < levelSizes.length; l++) {
                size += levelSizes[l];
                size += this.levelDistance
            }
            size += this.margins;
            if (!this.isStraight()) {
                off = size
            }
            for (var i = 0; i < this.tree.treeLevels.length; i++) {
                var treeLevel = this.tree.treeLevels[i];
                for (var j = 0; j < treeLevel.length; j++) {
                    var node = treeLevel[j];
                    if (this.isHorizontal()) {
                        node.x += off
                    } else {
                        node.y += off
                    }
                }
                if (this.isStraight()) {
                    off += this.levelDistance + levelSizes[i]
                } else {
                    off += -(this.levelDistance + levelSizes[i])
                }
            }
            if (this.keepRootPosition) {
                var newRootX = root.x;
                var newRootY = root.y;
                var xoff = rootX - newRootX;
                var yoff = rootY - newRootY;
                this.offsetBranch(root, xoff, yoff)
            }
            if (this.linkType != mg.TreeLayoutLinkType.Default) {
                switch (this.linkType) {
                    case mg.TreeLayoutLinkType.Straight:
                        switch (this.direction) {
                            case mg.LayoutDirection.TopToBottom:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x + e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y - e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.BottomToTop:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x + e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y + e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.LeftToRight:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y + e.origin.height / 2
                                    }, {
                                        x: e.destination.x - e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.RightToLeft:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y + e.origin.height / 2
                                    }, {
                                        x: e.destination.x + e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break
                        }
                        break;
                    case mg.TreeLayoutLinkType.Cascading:
                        switch (this.direction) {
                            case mg.LayoutDirection.TopToBottom:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x + e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y - e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.BottomToTop:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x + e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y + e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.LeftToRight:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y + e.origin.height / 2
                                    }, {
                                        x: e.origin.x,
                                        y: e.destination.y
                                    }, {
                                        x: e.destination.x - e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.RightToLeft:
                                this.tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y + e.origin.height / 2
                                    }, {
                                        x: e.origin.x,
                                        y: e.destination.y
                                    }, {
                                        x: e.destination.x + e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break
                        }
                        break
                }
            }
        };
        BorderedTreeLayout.prototype.rarrange = function(node) {
            var rc = new MindFusion.Drawing.Rect.fromVertex(node);
            rc.x = this.x;
            rc.y = this.y;
            if (this.direction == mg.LayoutDirection.RightToLeft) {
                var rcRoot = MindFusion.Drawing.Rect.fromVertex(this.tree.root);
                var s = rc.width;
                rc = new Rect(rcRoot.right() - s, rc.top(), rc.width, rc.height)
            } else {
                if (this.direction == mg.LayoutDirection.BottomToTop) {
                    var rcRoot = MindFusion.Drawing.Rect.fromVertex(this.tree.root);
                    var s = rc.height;
                    rc = new Rect(rc.left(), rcRoot.bottom() - s, rc.width, rc.height)
                }
            }
            node.x = rc.x + rc.width / 2;
            node.y = rc.y + rc.height / 2;
            if (this.isHorizontal()) {
                this.y += rc.height + this.nodeDistance
            } else {
                this.x += rc.width + this.nodeDistance
            }
            var self = this;
            childrenOf(node).forEach(function(child) {
                self.rarrange(child)
            })
        };
        BorderedTreeLayout.prototype.offsetBranch = function(nodeFrom, xoff, yoff) {
            var offsetFunc = function(node, params) {
                node.x += params[0];
                node.y += params[1]
            };
            walk(nodeFrom, offsetFunc, [xoff, yoff])
        };
        BorderedTreeLayout.prototype.isHorizontal = function() {
            return this.direction == mg.LayoutDirection.LeftToRight || this.direction == mg.LayoutDirection.RightToLeft
        };
        BorderedTreeLayout.prototype.isStraight = function() {
            return this.direction == mg.LayoutDirection.LeftToRight || this.direction == mg.LayoutDirection.TopToBottom
        };

        function childrenOf(node) {
            var children = new ArrayList();
            node.outEdges.forEach(function(e) {
                children.push(e.destination)
            });
            return children
        }

        function walk(node, func, params) {
            func.call(this, node, params);
            var children = childrenOf(node);
            children.forEach(function(child) {
                walk(child, func, params)
            })
        }
        BorderedTreeLayout.With = function() {
            if (!mg.BorderedTreeLayoutBuilder) {
                mg.BorderedTreeLayoutBuilder = new MindFusion.Builder(BorderedTreeLayout.prototype)
            } else {
                mg.BorderedTreeLayoutBuilder.setInstance(null)
            }
            return mg.BorderedTreeLayoutBuilder
        };
        BorderedTreeLayout.prototype.init = function() {
            if (!mg.BorderedTreeLayoutBuilder) {
                mg.BorderedTreeLayoutBuilder = new MindFusion.Builder(BorderedTreeLayout.prototype, null, this)
            } else {
                mg.BorderedTreeLayoutBuilder.setInstance(this)
            }
            return mg.BorderedTreeLayoutBuilder
        };
        BorderedTreeLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.BorderedTreeLayoutBuilder = null;
        BorderedTreeLayout.prototype.getLevelDistance = function() {
            return this.levelDistance
        };
        BorderedTreeLayout.prototype.setLevelDistance = function(value) {
            this.levelDistance = value
        };
        BorderedTreeLayout.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        BorderedTreeLayout.prototype.setNodeDistance = function(value) {
            this.nodeDistance = value
        };
        BorderedTreeLayout.prototype.getKeepRootPosition = function() {
            return this.keepRootPosition
        };
        BorderedTreeLayout.prototype.setKeepRootPosition = function(value) {
            this.keepRootPosition = value
        };
        BorderedTreeLayout.prototype.getDirection = function() {
            return this.direction
        };
        BorderedTreeLayout.prototype.setDirection = function(value) {
            this.direction = value
        };
        BorderedTreeLayout.prototype.getLinkType = function() {
            return this.linkType
        };
        BorderedTreeLayout.prototype.setLinkType = function(value) {
            this.linkType = value
        };
        BorderedTreeLayout.prototype.getAnchoring = function() {
            return this.anchoring
        };
        BorderedTreeLayout.prototype.setAnchoring = function(value) {
            this.anchoring = value
        };
        BorderedTreeLayout.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        BorderedTreeLayout.prototype.setKeepGroupLayout = function(value) {
            this.keepGroupLayout = value
        };
        BorderedTreeLayout.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        BorderedTreeLayout.prototype.setMultipleGraphsPlacement = function(value) {
            this.multipleGraphsPlacement = value
        };
        MindFusion.registerClass(BorderedTreeLayout, "MindFusion.Graphs.BorderedTreeLayout")
    })(MindFusion.Graphs);
    (function(mg) {
        var Edge = mg.Edge = function(origin, destination) {
            this.origin = origin;
            this.destination = destination
        };
        Edge.prototype.getOtherEnd = function(vertex) {
            return this.origin == vertex ? this.destination : this.origin
        };
        Edge.prototype.getCommonVertex = function(edge) {
            if (this.origin == edge.origin || this.origin == edge.destination) {
                return this.origin
            }
            if (this.destination == edge.origin || this.destination == edge.destination) {
                return this.destination
            }
            return null
        };
        Edge.prototype.joins = function(v1, v2) {
            if (this.origin == v1 && this.destination == v2 || this.origin == v2 && this.destination == v1) {
                return true
            }
            return false
        };
        Edge.prototype.getEnds = function() {
            return [this.origin, this.destination]
        };
        Edge.prototype.incidentWith = function(vertex) {
            return this.origin == vertex || this.destination == vertex
        };
        Edge.prototype.adjacentTo = function(edge) {
            return this.origin.edges.contains(edge) || this.destination.edges.contains(edge)
        };
        Edge.prototype.changeOrigin = function(v) {
            this.origin.edges.remove(this);
            this.origin.outEdges.remove(this);
            v.edges.push(this);
            v.outEdges.push(this);
            this.origin = v
        };
        Edge.prototype.changeDestination = function(v) {
            this.destination.edges.remove(this);
            this.destination.inEdges.remove(this);
            v.edges.push(this);
            v.inEdges.push(this);
            this.destination = v
        };
        Edge.prototype.changeVertex = function(v, w) {
            if (this.origin == v) {
                this.changeOrigin(w)
            } else {
                if (this.destination == v) {
                    this.changeDestination(w)
                }
            }
        };
        Edge.prototype.reverse = function() {
            var oldOrigin = this.origin;
            var oldDest = this.destination;
            this.origin = oldDest;
            oldOrigin.outEdges.remove(this);
            this.origin.outEdges.push(this);
            this.destination = oldOrigin;
            oldDest.inEdges.remove(this);
            this.destination.inEdges.push(this)
        };
        Edge.prototype.directTo = function(destination) {
            if (this.destination != destination) {
                this.reverse()
            }
        };
        Edge.prototype.createReverseEdge = function() {
            var r = new Edge(destination, origin, this);
            r.reversed = true;
            return r
        };
        MindFusion.registerClass(Edge, "MindFusion.Graphs.Edge")
    })(MindFusion.Graphs);
    MindFusion.Graphs.AssistantPosition = {
        Left: 1,
        Right: 2
    };
    MindFusion.Graphs.AssistantType = {
        Normal: 1,
        Left: 2,
        Right: 3
    };
    MindFusion.Graphs.Anchoring = {
        Ignore: 0,
        Keep: 1,
        Reassign: 2
    };
    MindFusion.Graphs.LayoutDirection = {
        TopToBottom: 0,
        LeftToRight: 1,
        BottomToTop: 2,
        RightToLeft: 3
    };
    MindFusion.Graphs.TreeLayoutLinkType = {
        Default: 0,
        Straight: 1,
        Cascading: 2
    };
    MindFusion.Graphs.MultipleGraphsPlacement = {
        Vertical: 0,
        Horizontal: 1
    };
    MindFusion.Graphs.Orientation = MindFusion.Graphs.MultipleGraphsPlacement;
    (function(mg) {
        var Dictionary = MindFusion.Collections.Dictionary;
        var ArrayList = MindFusion.Collections.ArrayList;
        var FractalLayout = mg.FractalLayout = function() {
            this.anchoring = mg.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.root = null;
            this.multipleGraphsPlacement = mg.MultipleGraphsPlacement.Horizontal
        };
        FractalLayout.prototype.setsLinkPoints = false;
        FractalLayout.prototype.setsLinkEndPoints = false;
        FractalLayout.prototype.requiresConnectedGraph = true;
        FractalLayout.prototype.requiresSimpleGraph = true;
        FractalLayout.prototype.margins = 10;
        FractalLayout.prototype.arrange = function(graph) {
            var root = this.root && this.root.vertex && graph.vertices.contains(this.root.vertex) ? this.root.vertex : graph.vertices[0];
            root.isRoot = true;
            this.branchCircles = new Dictionary();
            this.measureCircles(root);
            var rootCircle = this.branchCircles.get(root);
            this.arrangeCircles(rootCircle, {
                x: 0,
                y: 0
            }, 0)
        };
        FractalLayout.prototype.measureCircles = function(node) {
            var w = node.width;
            var h = node.height;
            var branchCircle = {};
            var radius = Math.sqrt(w * w + h * h) / 2;
            branchCircle.node = node;
            this.branchCircles.set(node, branchCircle);
            var childCircles = [];
            var radTotal = 0;
            node.getNeighbors().forEach(function(child) {
                if (this.branchCircles.contains(child)) {
                    return
                }
                var childCircle = this.measureCircles(child);
                childCircles.push(childCircle);
                radTotal += childCircle.radius
            }, this);
            childCircles.sort(compareRadius);
            if (!node.isRoot) {
                radTotal = radTotal * 72 / 71
            }
            var pointsInCircle = [{
                x: -w / 2,
                y: -h / 2
            }, {
                x: w / 2,
                y: -h / 2
            }, {
                x: w / 2,
                y: h / 2
            }, {
                x: -w / 2,
                y: h / 2
            }];
            var currentAngle = 0;
            if (!node.isRoot) {
                currentAngle += Math.PI / 72
            }
            var totalSweep = 2 * Math.PI;
            for (var i = 0; i < childCircles.length; ++i) {
                var childCircle = childCircles[i];
                var sweepAngle = totalSweep * childCircle.radius / radTotal;
                if (sweepAngle > Math.PI) {
                    sweepAngle = Math.PI;
                    totalSweep = Math.PI;
                    radTotal -= childCircle.radius
                }
                childCircle.sweepAngle = sweepAngle
            }
            for (var i = 0; i < childCircles.length; ++i) {
                var childCircle = childCircles[i];
                var halfSectorAngle = childCircle.sweepAngle / 2;
                currentAngle += halfSectorAngle;
                childCircle.angle = currentAngle;
                currentAngle += halfSectorAngle;
                var centerDelta = Math.max(radius + childCircle.radius, childCircle.radius / Math.sin(halfSectorAngle));
                childCircle.centerDelta = centerDelta;
                var farPointDelta = Math.max(radius + 2 * childCircle.radius, childCircle.radius + childCircle.radius / Math.sin(halfSectorAngle));
                var farPoint = {
                    x: farPointDelta * Math.cos(childCircle.angle),
                    y: farPointDelta * Math.sin(childCircle.angle)
                };
                pointsInCircle.push(farPoint)
            }
            if (childCircles.length > 0) {
                var minCircle = MindFusion.Geometry.Circle.fromPoints(pointsInCircle);
                branchCircle.radius = minCircle.r;
                branchCircle.centerX = minCircle.x;
                branchCircle.centerY = minCircle.y
            } else {
                branchCircle.radius = radius;
                branchCircle.centerX = branchCircle.centerY = 0
            }
            branchCircle.childCircles = childCircles;
            return branchCircle
        };
        FractalLayout.prototype.arrangeCircles = function(circle, center, angle) {
            var parentLinkAngle = angle;
            if (!circle.node.isRoot) {
                parentLinkAngle += Math.PI - circle.angle
            }
            var nodePos = {
                x: center.x - circle.centerX,
                y: center.y - circle.centerY
            };
            ArrayList.forEach(circle.childCircles, function(childCircle) {
                var childCirclePos = {
                    x: nodePos.x + childCircle.centerDelta * Math.cos(childCircle.angle),
                    y: nodePos.y + childCircle.centerDelta * Math.sin(childCircle.angle)
                };
                childCirclePos = MindFusion.Geometry.rotatePoint(childCirclePos, center, parentLinkAngle);
                this.arrangeCircles(childCircle, childCirclePos, parentLinkAngle)
            }, this);
            nodePos = MindFusion.Geometry.rotatePoint(nodePos, center, parentLinkAngle);
            circle.node.x = nodePos.x;
            circle.node.y = nodePos.y
        };

        function compareRadius(e1, e2) {
            var r1 = e1.radius;
            var r2 = e2.radius;
            if (r1 < r2) {
                return 1
            }
            if (r1 > r2) {
                return -1
            }
            return 0
        }
        FractalLayout.With = function() {
            if (!mg.FractalLayoutBuilder) {
                mg.FractalLayoutBuilder = new MindFusion.Builder(FractalLayout.prototype)
            } else {
                mg.FractalLayoutBuilder.setInstance(null)
            }
            return mg.FractalLayoutBuilder
        };
        FractalLayout.prototype.init = function() {
            if (!mg.FractalLayoutBuilder) {
                mg.FractalLayoutBuilder = new MindFusion.Builder(FractalLayout.prototype, null, this)
            } else {
                mg.FractalLayoutBuilder.setInstance(this)
            }
            return mg.FractalLayoutBuilder
        };
        FractalLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.FractalLayoutBuilder = null;
        FractalLayout.prototype.getAnchoring = function() {
            return this.anchoring
        };
        FractalLayout.prototype.setAnchoring = function(value) {
            this.anchoring = value
        };
        FractalLayout.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        FractalLayout.prototype.setKeepGroupLayout = function(value) {
            this.keepGroupLayout = value
        };
        FractalLayout.prototype.getRoot = function() {
            return this.root
        };
        FractalLayout.prototype.setRoot = function(value) {
            this.root = value
        };
        FractalLayout.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        FractalLayout.prototype.setMultipleGraphsPlacement = function(value) {
            this.multipleGraphsPlacement = value
        };
        MindFusion.registerClass(FractalLayout, "MindFusion.Graphs.FractalLayout")
    })(MindFusion.Graphs);
    (function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var AssistantPosition = MindFusion.Graphs.AssistantPosition;
        var AssistantType = MindFusion.Graphs.AssistantType;
        var Graph = mg.Graph = function() {
            this.vertices = new ArrayList();
            this.edges = new ArrayList()
        };
        Graph.prototype.clone = function(saveMapping) {
            var copy = new Graph();
            if (saveMapping) {
                copy.vertexCopyToOrigMap = new Dictionary();
                copy.edgeCopyToOrigMap = new Dictionary()
            }
            var map = new Dictionary();
            this.vertices.forEach(function(v) {
                var vcopy = v.clone();
                map.set(v, vcopy);
                copy.vertices.push(vcopy);
                if (saveMapping) {
                    copy.vertexCopyToOrigMap.set(vcopy, v)
                }
            });
            this.edges.forEach(function(e) {
                if (map.contains(e.origin) && map.contains(e.destination)) {
                    var ecopy = copy.createEdge(map.get(e.origin), map.get(e.destination));
                    if (saveMapping) {
                        copy.edgeCopyToOrigMap.set(ecopy, e)
                    }
                }
            });
            return copy
        };
        Graph.prototype.tree = function(root, enableAssistants, compactAssistants) {
            var tree = new Graph();
            root.level = 0;
            tree.root = root;
            var visited = new ArrayList();
            var remaining = new ArrayList();
            tree.vertices.push(root);
            visited.push(root);
            remaining.push(root);
            var levelCount = 1;
            while (remaining.length > 0) {
                var next = remaining.pop();
                next.outEdges.forEach(function(e) {
                    if (visited.contains(e.destination)) {
                        return
                    }
                    var origin = e.origin;
                    var destination = e.destination;
                    destination.level = origin.level + 1;
                    destination.parent = origin;
                    if (levelCount < destination.level + 1) {
                        levelCount = destination.level + 1
                    }
                    remaining.push(destination);
                    visited.push(destination);
                    tree.vertices.push(destination);
                    tree.edges.push(e)
                })
            }
            if (enableAssistants) {
                remaining.push(root);
                visited = new ArrayList();
                visited.push(root);
                while (remaining.length > 0) {
                    var next = remaining.pop();
                    var lastPosition = AssistantPosition.Right;
                    for (var i = 0; i < next.outEdges.length; i++) {
                        var child = next.outEdges[i].destination;
                        if (visited.contains(child)) {
                            continue
                        }
                        remaining.push(child);
                        visited.push(child);
                        switch (child.owner.getLayoutTraits().treeLayoutAssistant) {
                            case AssistantType.Left:
                                child.assistantPosition = AssistantPosition.Left;
                                break;
                            case AssistantType.Right:
                                child.assistantPosition = AssistantPosition.Right;
                                break;
                            case AssistantType.Normal:
                                if (lastPosition === AssistantPosition.Left) {
                                    child.assistantPosition = AssistantPosition.Right
                                } else {
                                    child.assistantPosition = AssistantPosition.Left
                                }
                                break;
                            default:
                                continue
                        }
                        lastPosition = child.assistantPosition
                    }
                }
                visited = new ArrayList();
                levelCount = this.reassignLevels(visited, root, compactAssistants) + 1
            }
            var treeLevels = new ArrayList();
            for (var i = 0; i < levelCount; i++) {
                treeLevels.push(new ArrayList())
            }
            tree.vertices.forEach(function(v) {
                treeLevels[v.level].push(v)
            });
            tree.treeLevels = treeLevels;
            return tree
        };
        Graph.prototype.reassignLevels = function(visited, parent, compactAssistants) {
            var maxLeftLevel = parent.level;
            var maxRightLevel = parent.level;
            var maxLevel = parent.level;
            var bottomLevel = -1;
            var sorted = new ArrayList();
            for (var i = 0; i < parent.outEdges.length; i++) {
                sorted.push(parent.outEdges[i].destination)
            }
            sorted.sort(function(a, b) {
                var aAssistantType = a.owner.getLayoutTraits().treeLayoutAssistant;
                var bAssistantType = b.owner.getLayoutTraits().treeLayoutAssistant;
                if (aAssistantType && !bAssistantType) {
                    return -1
                }
                if (!aAssistantType && bAssistantType) {
                    return 1
                }
                return a.index - b.index
            });
            for (var i = 0; i < sorted.length; i++) {
                var child = sorted[i];
                if (visited.contains(child)) {
                    continue
                }
                visited.push(child);
                if (child.owner.getLayoutTraits().treeLayoutAssistant) {
                    if (child.assistantPosition === AssistantPosition.Left) {
                        if (compactAssistants) {
                            child.level = maxLeftLevel + 1
                        } else {
                            child.level = Math.max(maxLeftLevel, maxRightLevel) + 1
                        }
                    } else {
                        if (child.assistantPosition === AssistantPosition.Right) {
                            if (compactAssistants) {
                                child.level = maxRightLevel + 1
                            } else {
                                child.level = maxLevel + 1
                            }
                        }
                    }
                } else {
                    if (bottomLevel === -1) {
                        bottomLevel = Math.max(maxLeftLevel, maxRightLevel) + 1
                    }
                    child.level = bottomLevel
                }
                var newMaxLevel = this.reassignLevels(visited, child, compactAssistants);
                if (child.owner.getLayoutTraits().treeLayoutAssistant) {
                    if (child.assistantPosition === AssistantPosition.Left) {
                        maxLeftLevel = Math.max(maxLeftLevel, newMaxLevel)
                    } else {
                        maxRightLevel = Math.max(maxRightLevel, newMaxLevel);
                        maxLevel = Math.max(maxLeftLevel, maxRightLevel)
                    }
                } else {
                    maxLevel = Math.max(maxLevel, newMaxLevel)
                }
            }
            return Math.max(maxLevel, maxLeftLevel)
        };
        Graph.prototype.createEdge = function(origin, destination, owner) {
            var edge = new mg.Edge(origin, destination);
            this.edges.push(edge);
            edge.origin.outEdges.push(edge);
            edge.origin.edges.push(edge);
            edge.destination.inEdges.push(edge);
            edge.destination.edges.push(edge);
            if (owner) {
                edge.owner = owner
            }
            return edge
        };
        Graph.prototype.addEdge = function(edge) {
            this.edges.push(edge);
            edge.origin.outEdges.push(edge);
            edge.origin.edges.push(edge);
            edge.destination.inEdges.push(edge);
            edge.destination.edges.push(edge)
        };
        Graph.prototype.removeEdge = function(edge) {
            this.edges.remove(edge);
            ArrayList.remove(edge.origin.outEdges, edge);
            ArrayList.remove(edge.origin.edges, edge);
            ArrayList.remove(edge.destination.inEdges, edge);
            ArrayList.remove(edge.destination.edges, edge)
        };
        Graph.prototype.createVertex = function(layoutRect, owner) {
            var vertex = new mg.Vertex();
            this.vertices.push(vertex);
            if (layoutRect) {
                vertex.x = layoutRect.x;
                vertex.y = layoutRect.y;
                vertex.width = layoutRect.width;
                vertex.height = layoutRect.height
            }
            if (owner) {
                vertex.owner = owner
            }
            return vertex
        };
        Graph.prototype.addVertexAndOutEdges = function(vertex) {
            this.vertices.push(vertex);
            ArrayList.forEach(vertex.outEdges, function(edge) {
                this.edges.push(edge)
            }, this)
        };
        Graph.prototype.setItemIndices = function() {
            for (var i = 0; i < this.vertices.length; ++i) {
                var vertex = this.vertices[i];
                vertex.index = i
            }
            for (var i = 0; i < this.edges.length; ++i) {
                var edge = this.edges[i];
                edge.index = i
            }
        };
        Graph.prototype.getConnectedComponents = function() {
            this.searchCounter = 0;
            this.setItemIndices();
            var setIds = createIdArray(this.vertices.length, -1);
            for (var v = 0; v < this.vertices.length; v++) {
                if (setIds[v] == -1) {
                    this.dfsConnectivity(setIds, v);
                    this.searchCounter++
                }
            }
            var components = [];
            for (var i = 0; i < this.searchCounter; ++i) {
                components[i] = new Graph()
            }
            for (var i = 0; i < setIds.length; ++i) {
                var graph = components[setIds[i]];
                graph.addVertexAndOutEdges(this.vertices[i])
            }
            return components
        };
        Graph.prototype.dfsConnectivity = function(setIds, vertexId) {
            setIds[vertexId] = this.searchCounter;
            var vertex = this.vertices[vertexId];
            ArrayList.forEach(vertex.edges, function(edge) {
                var next = edge.getOtherEnd(vertex);
                var nextId = next.index;
                if (setIds[nextId] == -1) {
                    this.dfsConnectivity(setIds, nextId)
                }
            }, this)
        };
        Graph.prototype.getBiconnectedComponents = function() {
            var blocks = [];
            this.setItemIndices();
            this.edges.forEach(function(edge) {
                delete edge.processed
            });
            var searchCounter = 0;
            var searchOrder = [];
            var componentStack = [];
            var lowPoint = [];
            for (var v = 0; v < this.vertices.length; v++) {
                var vertex = this.vertices[v];
                if (searchOrder[vertex.index] !== undefined) {
                    continue
                }
                if (vertex.edges.length == 0) {
                    var component = new Graph();
                    component.addVertexAndOutEdges(vertex);
                    blocks.push(component.clone(true));
                    continue
                }
                var vertexStack = [];
                var edgeStack = [];
                searchOrder[vertex.index] = searchCounter++;
                lowPoint[vertex.index] = searchOrder[vertex.index];
                vertexStack.push(vertex);
                edgeStack.push(vertex.edges.slice(0));
                while (true) {
                    while (edgeStack[edgeStack.length - 1].length > 0) {
                        var tail = vertexStack[vertexStack.length - 1];
                        var edge = edgeStack[edgeStack.length - 1].shift();
                        var head = edge.getOtherEnd(tail);
                        if (edge.processed) {
                            continue
                        }
                        componentStack.push(edge);
                        edge.processed = true;
                        if (searchOrder[head.index] === undefined) {
                            searchOrder[head.index] = searchCounter++;
                            vertexStack.push(head);
                            edgeStack.push(head.edges.slice(0));
                            lowPoint[head.index] = searchOrder[tail.index]
                        } else {
                            if (searchOrder[head.index] < lowPoint[tail.index]) {
                                lowPoint[tail.index] = searchOrder[head.index]
                            }
                        }
                    }
                    if (vertexStack.length > 1) {
                        var top = vertexStack[vertexStack.length - 1];
                        var next = vertexStack[vertexStack.length - 2];
                        if (lowPoint[top.index] == searchOrder[next.index]) {
                            var component = new Graph();
                            var topEdge = componentStack[componentStack.length - 1];
                            while (searchOrder[topEdge.origin.index] >= searchOrder[next.index] && searchOrder[topEdge.destination.index] >= searchOrder[next.index]) {
                                componentStack.pop();
                                if (!component.vertices.contains(topEdge.origin)) {
                                    component.addVertexAndOutEdges(topEdge.origin)
                                }
                                if (!component.vertices.contains(topEdge.destination)) {
                                    component.addVertexAndOutEdges(topEdge.destination)
                                }
                                if (componentStack.length == 0) {
                                    break
                                }
                                topEdge = componentStack[componentStack.length - 1]
                            }
                            blocks.push(component.clone(true))
                        } else {
                            if (lowPoint[next.index] > lowPoint[top.index]) {
                                lowPoint[next.index] = lowPoint[top.index]
                            }
                        }
                        vertexStack.pop();
                        edgeStack.pop()
                    } else {
                        break
                    }
                }
            }
            return blocks
        };
        Graph.prototype.get3EdgeConnectedComponents = function() {
            return this.test3EdgeConnectivity(false)
        };
        Graph.prototype.getCutPairs = function() {
            return this.test3EdgeConnectivity(true)
        };
        Graph.prototype.test3EdgeConnectivity = function(returnPairs) {
            if (this.vertices.length < 2) {
                return returnPairs ? new ArrayList() : [this]
            }
            if (this.vertices[0].index === undefined) {
                this.setItemIndices()
            }
            this.edges.forEach(function(e) {
                delete e.cutEdge;
                delete e.treeEdge
            });
            var cutPairs = new ArrayList();
            var dfs = 0;
            var dfsNumber = [];
            var nd = [];
            var lowpt = [];
            var low = [];
            var lowpt2 = [];
            var low2 = [];
            var tolow = [];
            var stack = [];
            var newlink = [];
            var generatorBuckets = new Dictionary();

            function findCutPairs(v, parentEdge) {
                var vi = v.index;
                dfsNumber[vi] = dfs++;
                newlink[vi] = v;
                nd[vi] = 1;
                lowpt[vi] = dfsNumber[vi];
                low[vi] = v;
                lowpt2[vi] = dfsNumber[vi];
                low2[vi] = v;
                if (stack[vi] === undefined) {
                    stack[vi] = []
                }
                v.edges.forEach(function(e) {
                    if (e == parentEdge) {
                        return
                    }
                    var w = e.getOtherEnd(v);
                    var wi = w.index;
                    if (dfsNumber[wi] === undefined) {
                        e.treeEdge = true;
                        e.child = w;
                        findCutPairs(w, e);
                        var s = stack[wi];
                        var top = s.length > 0 ? s[s.length - 1] : null;
                        if (top != null && w == top.q) {
                            s.pop();
                            cutPairs.push([e, top.edge]);
                            e.cutEdge = true;
                            top.edge.cutEdge = true;
                            if (returnPairs) {
                                if (!generatorBuckets.contains(top.edge)) {
                                    generatorBuckets.set(top.edge, new ArrayList())
                                }
                                generatorBuckets.get(top.edge).push(e)
                            }
                            if (v != top.p) {
                                s.push({
                                    edge: top.edge,
                                    p: top.p,
                                    q: v
                                })
                            }
                            if (top.edge.treeEdge) {
                                var y = top.edge.child.index;
                                newlink[y] = v
                            }
                        }
                        nd[vi] = nd[vi] + nd[wi];
                        if (lowpt[wi] < lowpt[vi]) {
                            lowpt2[vi] = lowpt[vi];
                            lowpt[vi] = lowpt[wi];
                            low2[vi] = low[vi];
                            low[vi] = low[wi];
                            stack[vi] = stack[wi].slice(0);
                            tolow[vi] = e
                        } else {
                            if (lowpt[wi] < lowpt2[vi]) {
                                lowpt2[vi] = lowpt[wi];
                                low2[vi] = low[wi];
                                stack[wi] = []
                            }
                        }
                    } else {
                        if (dfsNumber[vi] > dfsNumber[wi]) {
                            if (dfsNumber[wi] <= lowpt[vi]) {
                                lowpt2[vi] = lowpt[vi];
                                lowpt[vi] = dfsNumber[wi];
                                low2[vi] = low[vi];
                                low[vi] = w;
                                stack[vi] = [];
                                tolow[vi] = e
                            } else {
                                if (dfsNumber[wi] < lowpt2[vi]) {
                                    lowpt2[vi] = dfsNumber[wi];
                                    low2[vi] = w
                                }
                            }
                        }
                    }
                });
                var s = stack[vi];
                var top = s.length > 0 ? s[s.length - 1] : null;
                if (top == null) {
                    if (lowpt2[vi] > lowpt[vi]) {
                        s.push({
                            edge: tolow[vi],
                            p: low[vi],
                            q: low2[vi]
                        })
                    }
                } else {
                    if (lowpt2[vi] > dfsNumber[top.q.index]) {
                        s.push({
                            edge: tolow[vi],
                            p: top.q,
                            q: low2[vi]
                        })
                    } else {
                        while (s.length > 0 && lowpt2[vi] <= dfsNumber[s[s.length - 1].p.index]) {
                            s.pop()
                        }
                        if (s.length > 0 && lowpt2[vi] < dfsNumber[s[s.length - 1].q.index]) {
                            var se = s.pop();
                            s.push({
                                edge: se.edge,
                                p: se.p,
                                q: low2[vi]
                            })
                        }
                    }
                }
                v.edges.forEach(function(e) {
                    var u = e.getOtherEnd(v);
                    var ui = u.index;
                    if (e.treeEdge || dfsNumber[vi] > dfsNumber[ui]) {
                        return
                    }
                    var top = s.length > 0 ? s[s.length - 1] : null;
                    var y = top == null ? null : top.edge.child;
                    var yi = y ? y.index : 0;
                    while (top != null && top.edge.treeEdge && dfsNumber[yi] <= dfsNumber[ui] && dfsNumber[ui] <= dfsNumber[yi] + nd[yi] - 1) {
                        s.pop();
                        top = s.length > 0 ? s[s.length - 1] : null;
                        y = top == null ? null : top.edge.child;
                        yi = y ? y.index : 0
                    }
                })
            }
            findCutPairs(this.vertices[0], null);
            if (returnPairs) {
                generatorBuckets.forEach(function(generator, edges) {
                    for (var i = 0; i < edges.length; i++) {
                        for (var j = i + 1; j < edges.length; j++) {
                            if (!cutPairs.any(function(p) {
                                    return p[0] == edges[i] && p[1] == edges[j]
                                })) {
                                cutPairs.push([edges[i], edges[j]])
                            }
                        }
                    }
                });
                return cutPairs
            }
            var cutEdges = new ArrayList();
            this.edges.forEach(function(e) {
                if (e.cutEdge) {
                    cutEdges.push(e)
                }
            });
            cutEdges.forEach(function(e) {
                this.removeEdge(e)
            }, this);
            var newEdges = [];
            this.vertices.forEach(function(v) {
                if (newlink[v.index] != v) {
                    var e = this.createEdge(v, newlink[v.index]);
                    newEdges.push(e)
                }
            }, this);
            var comps = this.getConnectedComponents();
            newEdges.forEach(function(e) {
                this.removeEdge(e)
            }, this);
            cutEdges.forEach(function(e) {
                this.addEdge(e)
            }, this);
            return comps
        };
        Graph.prototype.findBlockSeparationPairs = function() {
            var va = this.vertices;
            if (va.length < 4) {
                return []
            }

            function remainsConnectedWithout(v1, v2) {
                var queue = [];
                var visited = [];
                var processed = 1;
                va.forEach(function(v) {
                    if (v != v1 && v != v2) {
                        queue.push(v);
                        visited[v.index] = true;
                        return $break
                    }
                });
                while (queue.length > 0) {
                    var v = queue.shift();
                    v.getNeighbors().forEach(function(n) {
                        if (visited[n.index] || v1 == n || v2 == n) {
                            return
                        }
                        queue.push(n);
                        visited[n.index] = true;
                        processed++
                    })
                }
                return processed == va.length - 2
            }
            this.setItemIndices();
            var separationPairs = [];
            for (var i = 0; i < va.length - 1; i++) {
                for (var j = i + 1; j < va.length; j++) {
                    if (!remainsConnectedWithout(va[i], va[j])) {
                        separationPairs.push([va[i], va[j]])
                    }
                }
            }
            return separationPairs
        };
        Graph.prototype.findBlockSeparationPairsB = function() {
            var dfsCounter = 0;
            var dfsNumber = [];
            var dfsVertex = [];
            var low1 = [];
            var low2 = [];
            var parent = [];
            var children = [];
            var nd = [];
            var flag = [];
            var separationPairs = new ArrayList();
            var removed = new ArrayList();
            var This = this;
            var VLen = This.vertices.length;
            this.edges.forEach(function(e) {
                delete e.spTreeEdge
            });

            function traverse(V, P) {
                var v = V.index;
                children[v] = [];
                dfsNumber[v] = dfsCounter++;
                dfsVertex[dfsNumber[v]] = V;
                parent[v] = P;
                low1[v] = low2[v] = dfsNumber[v];
                nd[v] = 1;
                V.edges.forEach(function(e) {
                    var W = e.getOtherEnd(V);
                    var w = W.index;
                    if (dfsNumber[w] === undefined) {
                        e.spTreeEdge = true;
                        children[v].push(W);
                        traverse(W, V);
                        if (low1[w] < low1[v]) {
                            low2[v] = Math.min(low1[v], low2[w]);
                            low1[v] = low1[w]
                        } else {
                            if (low1[w] == low1[v]) {
                                low2[v] = Math.min(low2[v], low2[w])
                            } else {
                                low2[v] = Math.min(low2[v], low1[w])
                            }
                        }
                        nd[v] += nd[w]
                    } else {
                        if (dfsNumber[w] < dfsNumber[v] && (w != P.index || flag[v])) {
                            if (dfsNumber[w] < low1[v]) {
                                low2[v] = low1[v];
                                low1[v] = dfsNumber[w]
                            } else {
                                if (dfsNumber[w] > low1[v]) {
                                    low2[v] = Math.min(low2[v], dfsNumber[w])
                                }
                            }
                        }
                    }
                    if (W == P) {
                        flag[v] = true
                    }
                });
                if (P) {
                    var X = dfsVertex[low1[v]];
                    var t3s = nd[v];
                    if (X != P && low2[v] >= dfsNumber[P.index] && t3s < VLen - 2) {
                        separationPairs.push([X, P])
                    } else {
                        if (dfsNumber[X.index] > 0 && intermLinksOnlyToSubtree(X, P, V)) {
                            separationPairs.push([X, P])
                        }
                    }
                }
                var sameLow = false;
                getChildren(V).forEach(function(Q) {
                    if (low1[v] == low1[Q.index]) {
                        sameLow = true;
                        return $break
                    }
                });
                if (nd[v] > 1 && !sameLow) {
                    var vc = This.createVertex();
                    vc.index = This.vertices.length - 1;
                    ArrayList.forEach(V.edges.slice(0), function(e) {
                        if (!e.spTreeEdge) {
                            var W = e.getOtherEnd(V);
                            if (dfsNumber[v] > dfsNumber[W.index]) {
                                e.changeVertex(V, vc)
                            }
                        }
                    });
                    var ce = This.createEdge(V, vc);
                    ce.index = This.edges.length - 1;
                    ce.spTreeEdge = true;
                    dfsNumber[vc.index] = dfsNumber[v];
                    low1[vc.index] = low1[v];
                    nd[vc.index] = 1;
                    parent[vc.index] = V;
                    reduce(vc, V);
                    removed.push(vc)
                }
                var nontreeEdges = 0;
                V.edges.forEach(function(e) {
                    if (!e.spTreeEdge) {
                        nontreeEdges++
                    }
                });
                if (nontreeEdges > 1) {
                    reduce(V, V);
                    removed.push(V)
                }
            }

            function pathNodesBetween(a, d) {
                var nodes = new ArrayList();
                while (parent[d.index] != a) {
                    nodes.push(parent[d.index]);
                    d = parent[d.index]
                }
                return nodes
            }

            function intermLinksOnlyToSubtree(a, d, v) {
                var intermNodes = pathNodesBetween(a, d);
                var onlyToSubtree = true;
                intermNodes.forEach(function(node) {
                    node.edges.forEach(function(e) {
                        var w = e.getOtherEnd(node);
                        if (w == a || w == d) {
                            return
                        }
                        if (dfsNumber[w.index] === undefined) {
                            onlyToSubtree = false
                        } else {
                            if (dfsNumber[w.index] < dfsNumber[a.index]) {
                                onlyToSubtree = false
                            } else {
                                if (dfsNumber[w.index] > dfsNumber[d.index] && dfsNumber[w.index] < dfsNumber[v.index]) {
                                    onlyToSubtree = false
                                } else {
                                    if (low1[w.index] < dfsNumber[a.index]) {
                                        onlyToSubtree = false
                                    }
                                }
                            }
                        }
                    });
                    if (!onlyToSubtree) {
                        return $break
                    }
                });
                return onlyToSubtree
            }

            function getChildren(V) {
                var v = V.index;
                var children = new ArrayList();
                V.edges.forEach(function(e) {
                    if (e.spTreeEdge) {
                        var W = e.getOtherEnd(V);
                        if (dfsNumber[v] < dfsNumber[W.index]) {
                            children.push(W)
                        }
                    }
                });
                return children
            }

            function reduce(V, rep) {
                var v = V.index;
                var outNodes = new ArrayList();
                var inNodes = new ArrayList();
                V.edges.forEach(function(e) {
                    if (e.spTreeEdge) {
                        return
                    }
                    var W = e.getOtherEnd(V);
                    if (dfsNumber[v] > dfsNumber[W.index]) {
                        if (!outNodes.contains(W)) {
                            outNodes.push(W)
                        }
                    } else {
                        if (!inNodes.contains(W)) {
                            inNodes.push(W)
                        }
                    }
                });
                outNodes.sort(sortByDfsNumber);
                inNodes.sort(sortByDfsNumber);
                var outReplacement = new ArrayList();
                outNodes.forEach(function(n) {
                    var r = This.createVertex();
                    r.replacementFor = rep;
                    r.index = This.vertices.length - 1;
                    nd[r.index] = nd[v];
                    outReplacement.push(r)
                });
                var inReplacement = new ArrayList();
                inNodes.forEach(function(n) {
                    var r = This.createVertex();
                    r.replacementFor = rep;
                    r.index = This.vertices.length - 1;
                    nd[r.index] = nd[v];
                    inReplacement.push(r)
                });
                var replacement = [];
                outReplacement.forReverse(function(v) {
                    replacement.push(v)
                });
                inReplacement.forReverse(function(v) {
                    replacement.push(v)
                });
                for (var i = 0; i < replacement.length - 1; i++) {
                    var e = This.createEdge(replacement[i], replacement[i + 1]);
                    e.index = This.edges.length - 1;
                    e.replacementFor = rep;
                    e.spTreeEdge = true
                }
                var parentEdge = null;
                var childEdges = new ArrayList();
                V.edges.forEach(function(e) {
                    if (e.spTreeEdge) {
                        var W = e.getOtherEnd(V);
                        if (dfsNumber[v] < dfsNumber[W.index]) {
                            childEdges.push(e)
                        } else {
                            if (dfsNumber[v] >= dfsNumber[W.index]) {
                                parentEdge = e
                            }
                        }
                    }
                });
                if (parentEdge) {
                    parentEdge.changeVertex(V, replacement[0]);
                    parentEdge.replacementFor = rep
                }
                childEdges.forEach(function(childEdge) {
                    childEdge.changeVertex(V, replacement[replacement.length - 1]);
                    childEdge.replacementFor = rep
                });
                parent[replacement[0].index] = parent[v];
                for (var i = 0; i < outNodes.length; i++) {
                    var u = outNodes[i];
                    var uiOut = V.getCommonEdges(u);
                    uiOut.forEach(function(e) {
                        if (!e.spTreeEdge) {
                            e.changeVertex(V, outReplacement[i])
                        }
                    });
                    low1[outReplacement[i].index] = low1[v];
                    dfsNumber[outReplacement[i].index] = dfsNumber[v]
                }
                for (var i = 0; i < inNodes.length; i++) {
                    var w = inNodes[i];
                    var wiIn = V.getCommonEdges(w);
                    wiIn.forEach(function(e) {
                        if (!e.spTreeEdge) {
                            e.changeVertex(V, inReplacement[i])
                        }
                    });
                    low1[inReplacement[i].index] = low1[v];
                    dfsNumber[inReplacement[i].index] = dfsNumber[v]
                }
            }

            function sortByDfsNumber(v1, v2) {
                if (dfsNumber[v1.index] < dfsNumber[v2.index]) {
                    return -1
                }
                if (dfsNumber[v1.index] > dfsNumber[v2.index]) {
                    return 1
                }
                return 0
            }

            function childOnPathTo(a, d) {
                while (parent[d.index] != a) {
                    d = parent[d.index]
                }
                return d
            }
            this.setItemIndices();
            traverse(this.vertices[0], null);
            removed.forEach(function(V) {
                This.vertices.remove(V)
            });
            var candidates = new ArrayList();
            var cutPairs = this.getCutPairs();
            cutPairs.forEach(function(pair) {
                if (!(pair[0].spTreeEdge && pair[1].spTreeEdge)) {
                    return
                }
                var e1v = pair[0].getEnds();
                var e2v = pair[1].getEnds();
                e1v.sort(sortByDfsNumber);
                e2v.sort(sortByDfsNumber);
                if (!parent[e1v[0].index] && nd[e2v[1].index] === 1) {
                    return
                }
                if (!parent[e2v[0].index] && nd[e1v[1].index] === 1) {
                    return
                }
                var e1Vertices = [];
                e1Vertices.push(pair[0].origin);
                e1Vertices.push(pair[0].destination);
                var e2Vertices = [];
                e2Vertices.push(pair[1].origin);
                e2Vertices.push(pair[1].destination);
                for (var i = 0; i < e1Vertices.length; i++) {
                    for (var j = 0; j < e2Vertices.length; j++) {
                        if (e1Vertices[i] != e2Vertices[j]) {
                            candidates.push([e1Vertices[i], e2Vertices[j]])
                        }
                    }
                }
            });
            candidates.forEach(function(pair) {
                var a, d;
                if (dfsNumber[pair[0].index] < dfsNumber[pair[1].index]) {
                    a = pair[0];
                    d = pair[1]
                } else {
                    d = pair[0];
                    a = pair[1]
                }
                if (a.replacementFor) {
                    a = a.replacementFor
                }
                if (d.replacementFor) {
                    d = d.replacementFor
                }
                if (a == d) {
                    return
                }
                var t3s = t3Sizes(a, d, children[d.index][0], children[d.index]);
                if (t3s[1] != 0 && t3s[0] + t3s[2] != 0 && !separationPairs.any(function(e) {
                        return e[0] == a && e[1] == d
                    })) {
                    separationPairs.push([a, d])
                }
            });

            function t3Sizes(a, d, v, children) {
                var sizeOfV3 = children.length == 0 ? 0 : nd[v.index];
                var U = childOnPathTo(a, d);
                var sizeOfV2 = nd[U.index] - sizeOfV3 - 1;
                children.forEach(function(W) {
                    if (W == v) {
                        return
                    }
                    if (low1[W.index] < dfsNumber[a.index]) {
                        sizeOfV2 -= nd[W.index]
                    }
                });
                var sizeOfV1 = VLen - sizeOfV2 - sizeOfV3 - 2;
                return [sizeOfV1, sizeOfV2, sizeOfV3]
            }
            return separationPairs
        };
        Graph.prototype.makeAcyclic = function() {
            if (this.vertices.length <= 1 || this.edges.length <= 1) {
                return []
            }
            if (this.vertices.length == 2) {
                var result = [];
                var edge = this.edges[0];
                edge.reverse();
                result.push(edge);
                return result
            }
            var copy = this.clone(true);
            var n = this.vertices.length;
            var vertexBuckets = new Dictionary();
            copy.vertices.forEach(function(v) {
                addVertexToBucket(v, n, vertexBuckets)
            });
            var sl = [];
            var sr = [];
            while (copy.vertices.length > 0) {
                if (vertexBuckets.contains(2 - n)) {
                    var sinks = vertexBuckets.get(2 - n);
                    while (sinks.length > 0) {
                        var sink = sinks.pop();
                        sink.edges.forEach(function(e) {
                            var neighbor = e.getOtherEnd(sink);
                            var bucket = getBucket(neighbor, n);
                            vertexBuckets.get(bucket).remove(neighbor);
                            neighbor.removeEdge(e);
                            addVertexToBucket(neighbor, n, vertexBuckets)
                        });
                        copy.vertices.remove(sink);
                        sr.unshift(sink)
                    }
                }
                if (vertexBuckets.contains(n - 2)) {
                    var sources = vertexBuckets.get(n - 2);
                    while (sources.length > 0) {
                        var source = sources.pop();
                        source.edges.forEach(function(e) {
                            var neighbor = e.getOtherEnd(source);
                            var bucket = getBucket(neighbor, n);
                            vertexBuckets.get(bucket).remove(neighbor);
                            neighbor.removeEdge(e);
                            addVertexToBucket(neighbor, n, vertexBuckets)
                        });
                        copy.vertices.remove(source);
                        sl.push(source)
                    }
                }
                if (copy.vertices.length > 0) {
                    for (var i = n - 3; i > 2 - n; i--) {
                        if (vertexBuckets.contains(i) && vertexBuckets.get(i).length > 0) {
                            var maxdiff = vertexBuckets.get(i);
                            var v = maxdiff.pop();
                            v.edges.forEach(function(e) {
                                var neighbor = e.getOtherEnd(v);
                                var bucket = getBucket(neighbor, n);
                                vertexBuckets.get(bucket).remove(neighbor);
                                neighbor.removeEdge(e);
                                addVertexToBucket(neighbor, n, vertexBuckets)
                            });
                            copy.vertices.remove(v);
                            sl.push(v);
                            break
                        }
                    }
                }
            }
            ArrayList.addRange(sl, sr);
            var vertexOrder = new Dictionary();
            for (var i = 0; i < this.vertices.length; i++) {
                vertexOrder.set(copy.vertexCopyToOrigMap.get(sl[i]), i)
            }
            var reversedEdges = new ArrayList();
            this.edges.forEach(function(e) {
                if (vertexOrder.get(e.origin) > vertexOrder.get(e.destination)) {
                    e.reverse();
                    reversedEdges.push(e)
                }
            });
            return reversedEdges
        };

        function getBucket(vertex, n) {
            if (vertex.outEdges.length == 0) {
                return 2 - n
            } else {
                if (vertex.inEdges.length == 0) {
                    return n - 2
                } else {
                    return vertex.outEdges.length - vertex.inEdges.length
                }
            }
        }

        function addVertexToBucket(vertex, n, vertexBuckets) {
            var bucket = getBucket(vertex, n);
            if (!vertexBuckets.contains(bucket)) {
                vertexBuckets.set(bucket, new ArrayList())
            }
            vertexBuckets.get(bucket).push(vertex)
        }

        function createIdArray(size, value) {
            var array = [];
            for (var i = 0; i < size; ++i) {
                array[i] = value
            }
            return array
        }
        MindFusion.registerClass(Graph, "MindFusion.Graphs.Graph")
    })(MindFusion.Graphs);
    (function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Set = MindFusion.Collections.Set;
        var AssistantPosition = MindFusion.Graphs.AssistantPosition;
        var TreeLayout = mg.TreeLayout = function() {
            this.levelDistance = 10;
            this.nodeDistance = 10;
            this.keepRootPosition = false;
            this.direction = mg.LayoutDirection.TopToBottom;
            this.linkType = mg.TreeLayoutLinkType.Default;
            this.anchoring = mg.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.enableAssistants = false;
            this.compactAssistants = false;
            this.multipleGraphsPlacement = mg.MultipleGraphsPlacement.Horizontal
        };
        TreeLayout.prototype.setsLinkPoints = true;
        TreeLayout.prototype.setsLinkEndPoints = true;
        TreeLayout.prototype.requiresConnectedGraph = true;
        TreeLayout.prototype.requiresSimpleGraph = false;
        TreeLayout.prototype.margins = 10;
        TreeLayout.prototype.requiresCascadingLinks = function() {
            return this.linkType == mg.TreeLayoutLinkType.Cascading
        };
        TreeLayout.prototype.isStatic = function() {
            return this.keepRootPosition
        };
        TreeLayout.prototype.arrange = function(graph) {
            var root;
            graph.vertices.forEach(function(v) {
                if (v.inEdges.length == 0) {
                    root = v;
                    return $break
                }
            });
            if (!root) {
                return $skipLayout
            }
            var tree = graph.tree(root, this.enableAssistants, this.compactAssistants);
            if (!tree) {
                return $skipLayout
            }
            tree.vertices.forEach(function(v) {
                v.assistantType = v.owner.getLayoutTraits().treeLayoutAssistant
            });
            var rootX = root.x + root.width / 2;
            var rootY = root.y + root.height / 2;
            walk(tree, root, function(node, params) {
                node.x = node.width / 2;
                node.y = node.height / 2
            }, null);
            var levelSizes = new ArrayList();
            for (var i = 0; i < tree.treeLevels.length; i++) {
                var treeLevel = tree.treeLevels[i];
                var sz = 0;
                for (var j = 0; j < treeLevel.length; j++) {
                    if (this.isHorizontal()) {
                        sz = Math.max(sz, treeLevel[j].width)
                    } else {
                        sz = Math.max(sz, treeLevel[j].height)
                    }
                }
                levelSizes.push(sz)
            }
            var lastLevel = tree.treeLevels[tree.treeLevels.length - 1];
            var s = 0;
            for (var i = 0; i < lastLevel.length; i++) {
                var node = lastLevel[i];
                if (this.isHorizontal()) {
                    node.y = s + node.height / 2;
                    s += node.height + this.nodeDistance
                } else {
                    node.x = s + node.width / 2;
                    s += node.width + this.nodeDistance
                }
            }
            var previousLefts = new Dictionary();
            var previousRights = new Dictionary();
            for (var i = tree.treeLevels.length - 1; i >= 0; i--) {
                var treeLevel = tree.treeLevels[i];
                for (var j = 0; j < treeLevel.length; j++) {
                    var node = treeLevel[j];
                    var children = childrenOf(tree, node);
                    if (children.length > 0) {
                        if (this.hasAssistants(node) && this.enableAssistants) {
                            var firstLeftAssistant = undefined;
                            var firstRightAssistant = undefined;
                            children.forEach(function(child) {
                                if (child.assistantPosition === AssistantPosition.Left) {
                                    firstLeftAssistant = child
                                } else {
                                    if (child.assistantPosition === AssistantPosition.Right) {
                                        firstRightAssistant = child
                                    }
                                }
                            });
                            if (firstLeftAssistant && firstRightAssistant) {
                                var leftBounds = this.branchBounds(firstLeftAssistant);
                                var rightBounds = this.branchBounds(firstRightAssistant);
                                if (this.isHorizontal()) {
                                    node.y += leftBounds.bottom() + (rightBounds.top() - leftBounds.bottom()) / 2 - node.height / 2
                                } else {
                                    node.x += leftBounds.right() + (rightBounds.left() - leftBounds.right()) / 2 - node.width / 2
                                }
                            } else {
                                if (firstLeftAssistant) {
                                    var assistantBounds = this.branchBounds(firstLeftAssistant);
                                    if (this.isHorizontal()) {
                                        node.y = assistantBounds.bottom() + this.nodeDistance / 2
                                    } else {
                                        node.x = assistantBounds.right() + this.nodeDistance / 2
                                    }
                                } else {
                                    var assistantBounds = this.branchBounds(firstRightAssistant);
                                    if (this.isHorizontal()) {
                                        node.y = assistantBounds.top() - this.nodeDistance / 2
                                    } else {
                                        node.x = assistantBounds.left() - this.nodeDistance / 2
                                    }
                                }
                            }
                        } else {
                            var rcTotal = MindFusion.Drawing.Rect.fromVertex(children[0]);
                            for (var c = 1; c < children.length; c++) {
                                rcTotal = rcTotal.union(MindFusion.Drawing.Rect.fromVertex(children[c]))
                            }
                            if (this.isHorizontal()) {
                                node.y += (rcTotal.top() + rcTotal.bottom()) / 2 - node.height / 2
                            } else {
                                node.x += (rcTotal.left() + rcTotal.right()) / 2 - node.width / 2
                            }
                        }
                    }
                    if (node.assistantType && this.enableAssistants) {
                        var subordinates = [];
                        if (node.parent) {
                            for (var c = 0; c < node.parent.outEdges.length; c++) {
                                var child = node.parent.outEdges[c].destination;
                                if (child.assistantType) {
                                    continue
                                }
                                subordinates.push(child)
                            }
                        }
                        if (subordinates.length > 0) {
                            var rcTotal = MindFusion.Drawing.Rect.fromVertex(subordinates[0]);
                            for (var c = 1; c < subordinates.length; c++) {
                                rcTotal = rcTotal.union(MindFusion.Drawing.Rect.fromVertex(subordinates[c]))
                            }
                            var rc = this.branchBounds(node);
                            if (this.isHorizontal()) {
                                var offset = 0;
                                if (node.assistantPosition === AssistantPosition.Left) {
                                    offset = rcTotal.y + rcTotal.height / 2 - rc.bottom() - this.nodeDistance / 2
                                } else {
                                    offset = rcTotal.y + rcTotal.height / 2 - rc.top() + this.nodeDistance / 2
                                }
                                this.offsetBranch(tree, node, 0, offset)
                            } else {
                                var offset = 0;
                                if (node.assistantPosition === AssistantPosition.Left) {
                                    offset = rcTotal.x + rcTotal.width / 2 - rc.right() - this.nodeDistance / 2
                                } else {
                                    offset = rcTotal.x + rcTotal.width / 2 - rc.left() + this.nodeDistance / 2
                                }
                                this.offsetBranch(tree, node, offset, 0)
                            }
                        } else {
                            if (node.parent) {
                                var previousLeft = undefined;
                                if (previousLefts.contains(node.parent)) {
                                    previousLeft = previousLefts.get(node.parent)
                                }
                                var previousRight = undefined;
                                if (previousRights.contains(node.parent)) {
                                    previousRight = previousRights.get(node.parent)
                                }
                                if (previousLeft || previousRight) {
                                    var nodeBounds = this.branchBounds(node);
                                    if (node.assistantPosition === AssistantPosition.Right) {
                                        if (previousRight) {
                                            var previousBounds = this.branchBounds(previousRight);
                                            if (this.isHorizontal()) {
                                                var offset = previousBounds.top() - nodeBounds.top();
                                                this.offsetBranch(tree, node, 0, offset)
                                            } else {
                                                var offset = previousBounds.left() - nodeBounds.left();
                                                this.offsetBranch(tree, node, offset, 0)
                                            }
                                        } else {
                                            if (previousLeft) {
                                                var previousBounds = this.branchBounds(previousLeft);
                                                if (this.isHorizontal()) {
                                                    var offset = previousBounds.bottom() + this.nodeDistance - nodeBounds.top();
                                                    this.offsetBranch(tree, node, 0, offset)
                                                } else {
                                                    var offset = previousBounds.right() + this.nodeDistance - nodeBounds.left();
                                                    this.offsetBranch(tree, node, offset, 0)
                                                }
                                            }
                                        }
                                    } else {
                                        if (previousLeft) {
                                            var previousBounds = this.branchBounds(previousLeft);
                                            if (this.isHorizontal()) {
                                                var offset = previousBounds.bottom() - nodeBounds.bottom();
                                                this.offsetBranch(tree, node, 0, offset)
                                            } else {
                                                var offset = previousBounds.right() - nodeBounds.right();
                                                this.offsetBranch(tree, node, offset, 0)
                                            }
                                        } else {
                                            if (previousRight) {
                                                var previousBounds = this.branchBounds(previousRight);
                                                if (this.isHorizontal()) {
                                                    var offset = previousBounds.top() - this.nodeDistance - nodeBounds.bottom();
                                                    this.offsetBranch(tree, node, 0, offset)
                                                } else {
                                                    var offset = previousBounds.left() - this.nodeDistance - nodeBounds.right();
                                                    this.offsetBranch(tree, node, offset, 0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (node.assistantType && this.enableAssistants) {
                        if (node.assistantPosition === AssistantPosition.Left) {
                            previousLefts.set(node.parent, node)
                        } else {
                            if (node.assistantPosition === AssistantPosition.Right) {
                                previousRights.set(node.parent, node)
                            }
                        }
                    }
                }
                for (var j = 0; j < treeLevel.length - 1; j++) {
                    for (var k = j; k >= 0; k--) {
                        if (treeLevel[k].assistantType || treeLevel[j + 1].assistantType) {
                            continue
                        }
                        var dist = this.branchDistance(tree, treeLevel[k], treeLevel[j + 1]);
                        var checkDistance = k != j;
                        if (checkDistance ? dist < this.nodeDistance : true) {
                            if (this.isHorizontal()) {
                                this.offsetBranch(tree, treeLevel[j + 1], 0, this.nodeDistance - dist)
                            } else {
                                this.offsetBranch(tree, treeLevel[j + 1], this.nodeDistance - dist, 0)
                            }
                        }
                    }
                }
            }
            var iStart;
            var iEnd;
            var iGrow;
            if (this.isStraight()) {
                iStart = 0;
                iEnd = tree.treeLevels.length;
                iGrow = +1
            } else {
                iStart = tree.treeLevels.length - 1;
                iEnd = -1;
                iGrow = -1
            }
            var currentPos = 0;
            for (var i = iStart; this.isStraight() ? i < iEnd : i > iEnd; i += iGrow) {
                var maxSize = 0;
                var treeLevel = tree.treeLevels[i];
                for (var j = 0; j < treeLevel.length; j++) {
                    var node = treeLevel[j];
                    var size = 0;
                    if (this.isHorizontal()) {
                        size = node.width;
                        var xoff = 0;
                        if (this.direction == mg.LayoutDirection.RightToLeft) {
                            xoff = levelSizes[i] - size
                        }
                        node.x = currentPos + xoff + this.margins + node.width / 2;
                        node.y = node.y + this.margins
                    } else {
                        size = node.height;
                        var yoff = 0;
                        if (this.direction == mg.LayoutDirection.BottomToTop) {
                            yoff = levelSizes[i] - size
                        }
                        node.x = node.x + this.margins;
                        node.y = currentPos + yoff + this.margins + node.height / 2
                    }
                    maxSize = Math.max(maxSize, size)
                }
                currentPos += maxSize + this.levelDistance
            }
            if (this.keepRootPosition) {
                var newRootX = root.x;
                var newRootY = root.y;
                var xoff = rootX - newRootX;
                var yoff = rootY - newRootY;
                this.offsetBranch(tree, root, xoff, yoff)
            }
            if (this.linkType != mg.TreeLayoutLinkType.Default) {
                switch (this.linkType) {
                    case mg.TreeLayoutLinkType.Straight:
                        switch (this.direction) {
                            case mg.LayoutDirection.TopToBottom:
                                tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y + e.origin.height / 2
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y - e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.BottomToTop:
                                tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x,
                                        y: e.origin.y - e.origin.height / 2
                                    }, {
                                        x: e.destination.x,
                                        y: e.destination.y + e.destination.height / 2
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.LeftToRight:
                                tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x + e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x - e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break;
                            case mg.LayoutDirection.RightToLeft:
                                tree.edges.forEach(function(e) {
                                    e.points = [{
                                        x: e.origin.x - e.origin.width / 2,
                                        y: e.origin.y
                                    }, {
                                        x: e.destination.x + e.destination.width / 2,
                                        y: e.destination.y
                                    }]
                                });
                                break
                        }
                        break;
                    case mg.TreeLayoutLinkType.Cascading:
                        var enableAssistants = this.enableAssistants;
                        var halfDistance = this.levelDistance / 2;
                        switch (this.direction) {
                            case mg.LayoutDirection.TopToBottom:
                                tree.edges.forEach(function(e) {
                                    if (enableAssistants && e.destination.assistantType) {
                                        e.points = [{
                                            x: e.origin.x,
                                            y: e.origin.y + e.origin.height / 2
                                        }, {
                                            x: e.origin.x,
                                            y: e.destination.y
                                        }, e.destination.assistantPosition === AssistantPosition.Left ? {
                                            x: e.destination.x + e.destination.width / 2,
                                            y: e.destination.y
                                        } : {
                                            x: e.destination.x - e.destination.width / 2,
                                            y: e.destination.y
                                        }]
                                    } else {
                                        e.points = [{
                                            x: e.origin.x,
                                            y: e.origin.y + e.origin.height / 2
                                        }, {
                                            x: e.origin.x,
                                            y: e.destination.y - e.destination.height / 2 - halfDistance
                                        }, {
                                            x: e.destination.x,
                                            y: e.destination.y - e.destination.height / 2 - halfDistance
                                        }, {
                                            x: e.destination.x,
                                            y: e.destination.y - e.destination.height / 2
                                        }]
                                    }
                                });
                                break;
                            case mg.LayoutDirection.BottomToTop:
                                tree.edges.forEach(function(e) {
                                    if (enableAssistants && e.destination.assistantType) {
                                        e.points = [{
                                            x: e.origin.x,
                                            y: e.origin.y - e.origin.height / 2
                                        }, {
                                            x: e.origin.x,
                                            y: e.destination.y
                                        }, e.destination.assistantPosition === AssistantPosition.Left ? {
                                            x: e.destination.x + e.destination.width / 2,
                                            y: e.destination.y
                                        } : {
                                            x: e.destination.x - e.destination.width / 2,
                                            y: e.destination.y
                                        }]
                                    } else {
                                        e.points = [{
                                            x: e.origin.x,
                                            y: e.origin.y - e.origin.height / 2
                                        }, {
                                            x: e.origin.x,
                                            y: e.destination.y + e.destination.height / 2 + halfDistance
                                        }, {
                                            x: e.destination.x,
                                            y: e.destination.y + e.destination.height / 2 + halfDistance
                                        }, {
                                            x: e.destination.x,
                                            y: e.destination.y + e.destination.height / 2
                                        }]
                                    }
                                });
                                break;
                            case mg.LayoutDirection.LeftToRight:
                                tree.edges.forEach(function(e) {
                                    if (enableAssistants && e.destination.assistantType) {
                                        e.points = [{
                                            x: e.origin.x + e.origin.width / 2,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x,
                                            y: e.origin.y
                                        }, e.destination.assistantPosition === AssistantPosition.Left ? {
                                            x: e.destination.x,
                                            y: e.destination.y + e.destination.height / 2
                                        } : {
                                            x: e.destination.x,
                                            y: e.destination.y - e.destination.height / 2
                                        }]
                                    } else {
                                        e.points = [{
                                            x: e.origin.x + e.origin.width / 2,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x - e.destination.width / 2 - halfDistance,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x - e.destination.width / 2 - halfDistance,
                                            y: e.destination.y
                                        }, {
                                            x: e.destination.x - e.destination.width / 2,
                                            y: e.destination.y
                                        }]
                                    }
                                });
                                break;
                            case mg.LayoutDirection.RightToLeft:
                                tree.edges.forEach(function(e) {
                                    if (enableAssistants && e.destination.assistantType) {
                                        e.points = [{
                                            x: e.origin.x - e.origin.width / 2,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x,
                                            y: e.origin.y
                                        }, e.destination.assistantPosition === AssistantPosition.Left ? {
                                            x: e.destination.x,
                                            y: e.destination.y + e.destination.height / 2
                                        } : {
                                            x: e.destination.x,
                                            y: e.destination.y - e.destination.height / 2
                                        }]
                                    } else {
                                        e.points = [{
                                            x: e.origin.x - e.origin.width / 2,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x + e.destination.width / 2 + halfDistance,
                                            y: e.origin.y
                                        }, {
                                            x: e.destination.x + e.destination.width / 2 + halfDistance,
                                            y: e.destination.y
                                        }, {
                                            x: e.destination.x + e.destination.width / 2,
                                            y: e.destination.y
                                        }]
                                    }
                                });
                                break
                        }
                }
            }
        };
        TreeLayout.prototype.hasAssistants = function(node) {
            for (var i = 0; i < node.outEdges.length; i++) {
                if (node.outEdges[i].destination.assistantType) {
                    return true
                }
            }
            return false
        };
        TreeLayout.prototype.branchBounds = function(root) {
            var Rect = MindFusion.Drawing.Rect;
            var temp = [];
            temp.push(root);
            var visited = new ArrayList();
            var result;
            while (temp.length > 0) {
                var node = temp[0];
                temp.splice(0, 1);
                visited.push(node);
                if (!result) {
                    result = Rect.fromVertex(node)
                } else {
                    result = result.union(Rect.fromVertex(node))
                }
                for (var i = 0; i < node.outEdges.length; i++) {
                    var child = node.outEdges[i].destination;
                    if (!visited.contains(child)) {
                        temp.push(child)
                    }
                }
            }
            return result
        };
        TreeLayout.prototype.branchDistance = function(tree, node1, node2) {
            var dist = this.left(node2) - this.right(node1);
            var levels1 = new Dictionary();
            var levels2 = new Dictionary();
            enumerateLevels(tree, node1, levels1);
            enumerateLevels(tree, node2, levels2);
            var keys = levels1.keys();
            for (var i = 0; i < keys.length; i++) {
                var levelIndex = keys[i];
                if (!levels2.contains(levelIndex)) {
                    continue
                }
                var level1 = levels1.get(levelIndex);
                var level2 = levels2.get(levelIndex);
                var r = 0;
                for (var j = 0; j < level1.length; j++) {
                    r = Math.max(r, this.right(level1[j]))
                }
                var l = Number.MAX_VALUE;
                for (var j = 0; j < level2.length; j++) {
                    l = Math.min(l, this.left(level2[j]))
                }
                if ((l - r < dist) && (level1.length > 0 && level2.length > 0)) {
                    dist = l - r
                }
            }
            return dist
        };
        TreeLayout.prototype.right = function(vertex) {
            if (this.isHorizontal()) {
                return vertex.y + vertex.height / 2
            } else {
                return vertex.x + vertex.width / 2
            }
        };
        TreeLayout.prototype.left = function(vertex) {
            if (this.isHorizontal()) {
                return vertex.y - vertex.height / 2
            } else {
                return vertex.x - vertex.width / 2
            }
        };

        function enumerateLevels(tree, node, levels) {
            var levelIndex = node.level;
            var level = null;
            if (levels.contains(levelIndex)) {
                level = levels.get(levelIndex)
            } else {
                level = new ArrayList();
                levels.set(levelIndex, level)
            }
            level.push(node);
            childrenOf(tree, node).forEach(function(child) {
                enumerateLevels(tree, child, levels)
            })
        }
        TreeLayout.prototype.offsetBranch = function(tree, nodeFrom, xoff, yoff) {
            if (!xoff && !yoff) {
                return
            }
            var offsetFunc = function(node, params) {
                node.x += params[0];
                node.y += params[1]
            };
            walk(tree, nodeFrom, offsetFunc, [xoff, yoff])
        };
        TreeLayout.prototype.isHorizontal = function() {
            return this.direction == mg.LayoutDirection.LeftToRight || this.direction == mg.LayoutDirection.RightToLeft
        };
        TreeLayout.prototype.isStraight = function() {
            return this.direction == mg.LayoutDirection.LeftToRight || this.direction == mg.LayoutDirection.TopToBottom
        };

        function intDiv(numerator, denominator) {
            return (numerator - numerator % denominator) / denominator
        }

        function childrenOf(tree, node) {
            var children = new ArrayList();
            node.outEdges.forEach(function(e) {
                if (tree.edges.contains(e)) {
                    children.push(e.destination)
                }
            });
            return children
        }

        function walk(tree, node, func, params) {
            func.call(this, node, params);
            var children = childrenOf(tree, node);
            children.forEach(function(child) {
                walk(tree, child, func, params)
            })
        }
        TreeLayout.With = function() {
            if (!mg.TreeLayoutBuilder) {
                mg.TreeLayoutBuilder = new MindFusion.Builder(TreeLayout.prototype)
            } else {
                TreeMapLayoutBuilder.setInstance(null)
            }
            return mg.TreeLayoutBuilder
        };
        TreeLayout.prototype.init = function() {
            if (!mg.TreeLayoutBuilder) {
                mg.TreeLayoutBuilder = new MindFusion.Builder(TreeLayout.prototype, null, this)
            } else {
                mg.TreeLayoutBuilder.setInstance(this)
            }
            return mg.TreeLayoutBuilder
        };
        TreeLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.TreeLayoutBuilder = null;
        TreeLayout.prototype.getLevelDistance = function() {
            return this.levelDistance
        };
        TreeLayout.prototype.setLevelDistance = function(value) {
            this.levelDistance = value
        };
        TreeLayout.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        TreeLayout.prototype.setNodeDistance = function(value) {
            this.nodeDistance = value
        };
        TreeLayout.prototype.getKeepRootPosition = function() {
            return this.keepRootPosition
        };
        TreeLayout.prototype.setKeepRootPosition = function(value) {
            this.keepRootPosition = value
        };
        TreeLayout.prototype.getDirection = function() {
            return this.direction
        };
        TreeLayout.prototype.setDirection = function(value) {
            this.direction = value
        };
        TreeLayout.prototype.getLinkType = function() {
            return this.linkType
        };
        TreeLayout.prototype.setLinkType = function(value) {
            this.linkType = value
        };
        TreeLayout.prototype.getAnchoring = function() {
            return this.anchoring
        };
        TreeLayout.prototype.setAnchoring = function(value) {
            this.anchoring = value
        };
        TreeLayout.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        TreeLayout.prototype.setKeepGroupLayout = function(value) {
            this.keepGroupLayout = value
        };
        MindFusion.registerClass(TreeLayout, "MindFusion.Graphs.TreeLayout")
    })(MindFusion.Graphs);
    (function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Set = MindFusion.Collections.Set;
        var TreeMapLayout = mg.TreeMapLayout = function() {
            this.orientation = mg.Orientation.Vertical;
            this.squarify = true;
            this.padding = 1;
            this.layoutArea = null;
            this.containerPadding = 0;
            this.minNodeSize = 1
        };
        TreeMapLayout.prototype.setsLinkPoints = false;
        TreeMapLayout.prototype.setsLinkEndPoints = false;
        TreeMapLayout.prototype.requiresConnectedGraph = false;
        TreeMapLayout.prototype.requiresSimpleGraph = false;
        TreeMapLayout.prototype.requiresHierarchyInfo = true;
        TreeMapLayout.prototype.margins = 10;
        TreeMapLayout.prototype.requiresCascadingLinks = function() {
            return false
        };
        TreeMapLayout.prototype.isStatic = function() {
            return false
        };
        TreeMapLayout.prototype.arrange = function(graph) {
            if (this.layoutArea == null) {
                this.layoutArea = graph.layoutArea
            }
            var roots = [];
            this.weights = new Dictionary();
            var totalWeight = 0;
            graph.vertices.forEach(function(vertex) {
                if (vertex.master == null) {
                    totalWeight += this.calcWeights(vertex);
                    roots.push(vertex)
                }
            }, this);
            if (this.squarify) {
                this.arrangeSquare(roots, this.layoutArea, [], totalWeight)
            } else {
                this.arrangeSiblings(roots, this.layoutArea, this.orientation == mg.Orientation.Horizontal, totalWeight)
            }
        };
        TreeMapLayout.prototype.arrangeSquare = function(nodes, layoutArea, row, parentWeight) {
            var children = nodes.slice();
            var weights = this.weights;
            children.sort(function(n1, n2) {
                return weights.get(n2) - weights.get(n1)
            });
            this.doSquarify(children, layoutArea, row, parentWeight)
        };
        TreeMapLayout.prototype.doSquarify = function(children, layoutArea, row, parentWeight) {
            var horizontal = layoutArea.width > layoutArea.height;
            var sideLen = Math.min(layoutArea.width, layoutArea.height);
            var ratio1 = 0,
                ratio2 = 0;
            var row2 = row.slice();
            if (children.length > 0) {
                var node = children[0];
                row2.push(node);
                var area = layoutArea.width * layoutArea.height;
                ratio1 = this.evalRatio(row, sideLen, area * this.weight(row) / parentWeight);
                ratio2 = this.evalRatio(row2, sideLen, area * this.weight(row2) / parentWeight)
            }
            if (children.length > 0 && (ratio1 == 0 || ratio1 >= ratio2)) {
                children.shift();
                this.doSquarify(children, layoutArea, row2, parentWeight)
            } else {
                var len = this.layoutRow(layoutArea, row, !horizontal, parentWeight);
                parentWeight -= this.weight(row);
                if (horizontal) {
                    layoutArea.x += len;
                    layoutArea.width -= len
                } else {
                    layoutArea.y += len;
                    layoutArea.height -= len
                }
                if (children.length > 0) {
                    this.doSquarify(children, layoutArea, [], parentWeight)
                }
            }
        };
        TreeMapLayout.prototype.weight = function(row) {
            var total = 0;
            row.forEach(function(node) {
                total += this.weights.get(node)
            }, this);
            return total
        };
        TreeMapLayout.prototype.subtractPadding = function(rect) {
            var hp = -this.padding / 2;
            rect = rect.inflate(hp);
            var mm = this.minNodeSize;
            if (rect.width < mm) {
                rect.width = mm
            }
            if (rect.height < mm) {
                rect.height = mm
            }
        };
        TreeMapLayout.prototype.layoutRow = function(layoutArea, row, horizontal, parentWeight) {
            var Rect = MindFusion.Drawing.Rect;
            var parentArea = layoutArea.width * layoutArea.height;
            var sideLen = horizontal ? layoutArea.width : layoutArea.height;
            var total = 0;
            row.forEach(function(node) {
                total += this.weights.get(node)
            }, this);
            var rowArea = parentArea * total / parentWeight;
            var len = rowArea / sideLen;
            var pos = horizontal ? layoutArea.x : layoutArea.y;
            row.forEach(function(node) {
                var weight = this.weights.get(node);
                var bounds = horizontal ? new Rect(pos, layoutArea.y, rowArea * weight / total / len, len) : new Rect(layoutArea.x, pos, len, rowArea * weight / total / len);
                this.subtractPadding(bounds);
                setBounds(node, bounds);
                pos += rowArea * weight / total / len;
                if (node.subordinates != null) {
                    var children = node.subordinates.slice();
                    var childArea = this.layOutArea(node);
                    this.subtractPadding(childArea);
                    this.arrangeSquare(children, childArea, [], weight)
                }
            }, this);
            return len
        };
        TreeMapLayout.prototype.arrangeSiblings = function(nodes, layoutArea, horizontal, totalWeight) {
            var Rect = MindFusion.Drawing.Rect;
            var pos = horizontal ? layoutArea.x : layoutArea.y;
            var length = horizontal ? layoutArea.width : layoutArea.height;
            nodes.forEach(function(node) {
                var nodeSize = length * this.weights.get(node) / totalWeight;
                var bounds = horizontal ? new Rect(pos, layoutArea.y, nodeSize, layoutArea.height) : new Rect(layoutArea.x, pos, layoutArea.width, nodeSize);
                this.subtractPadding(bounds);
                setBounds(node, bounds);
                if (node.subordinates != null) {
                    var children = node.subordinates.slice();
                    var childArea = this.layOutArea(node);
                    this.subtractPadding(childArea);
                    this.arrangeSiblings(children, childArea, !horizontal, this.weights.get(node))
                }
                pos += nodeSize
            }, this)
        };
        TreeMapLayout.prototype.evalRatio = function(row, sideLen, rowArea) {
            var worst = 0;
            var total = 0;
            row.forEach(function(node) {
                var weight = this.weights.get(node);
                total += weight
            }, this);
            row.forEach(function(node) {
                var weight = this.weights.get(node);
                var area = rowArea * weight / total;
                worst = Math.max(worst, Math.max(sideLen * sideLen * area / (rowArea * rowArea), rowArea * rowArea / (sideLen * sideLen * area)))
            }, this);
            return worst
        };
        TreeMapLayout.prototype.calcWeights = function(root) {
            if (this.weights.contains(root)) {
                return this.weights.get(root)
            }
            if (root.subordinates == null) {
                this.weights.set(root, root.weight);
                return root.weight
            }
            var weight = 0;
            root.subordinates.forEach(function(child) {
                weight += this.calcWeights(child)
            }, this);
            this.weights.set(root, weight);
            return weight
        };
        TreeMapLayout.prototype.layOutArea = function(node) {
            var Rect = MindFusion.Drawing.Rect;
            var la = Rect.fromVertex(node);
            if (node.headerSize) {
                var headerSize = node.headerSize;
                if (headerSize < la.height) {
                    la.y += headerSize;
                    la.height -= headerSize
                } else {
                    la.y += la.height / 2;
                    la.height /= 2
                }
            }
            if (node.subordinates != null) {
                return la.inflate(-this.containerPadding)
            }
            return la
        };

        function setBounds(vertex, rect) {
            var c = rect.center();
            vertex.x = c.x;
            vertex.y = c.y;
            vertex.width = rect.width;
            vertex.height = rect.height
        }
        TreeMapLayout.With = function() {
            if (!mg.TreeMapLayoutBuilder) {
                mg.TreeMapLayoutBuilder = new MindFusion.Builder(TreeMapLayout.prototype)
            } else {
                mg.TreeMapLayoutBuilder.setInstance(null)
            }
            return mg.TreeMapLayoutBuilder
        };
        TreeMapLayout.prototype.init = function() {
            if (!mg.TreeMapLayoutBuilder) {
                mg.TreeMapLayoutBuilder = new MindFusion.Builder(TreeMapLayout.prototype, null, this)
            } else {
                mg.TreeMapLayoutBuilder.setInstance(this)
            }
            return mg.TreeMapLayoutBuilder
        };
        TreeMapLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.TreeMapLayoutBuilder = null;
        TreeMapLayout.prototype.getOrientation = function() {
            return this.orientation
        };
        TreeMapLayout.prototype.setOrientation = function(value) {
            this.orientation = value
        };
        TreeMapLayout.prototype.getSquarify = function() {
            return this.squarify
        };
        TreeMapLayout.prototype.setSquarify = function(value) {
            this.squarify = value
        };
        TreeMapLayout.prototype.getPadding = function() {
            return this.padding
        };
        TreeMapLayout.prototype.setPadding = function(value) {
            this.padding = value
        };
        TreeMapLayout.prototype.getLayoutArea = function() {
            return this.layoutArea
        };
        TreeMapLayout.prototype.setLayoutArea = function(value) {
            this.layoutArea = value
        };
        TreeMapLayout.prototype.getContainerPadding = function() {
            return this.containerPadding
        };
        TreeMapLayout.prototype.setContainerPadding = function(value) {
            this.containerPadding = value
        };
        MindFusion.registerClass(TreeMapLayout, "MindFusion.Graphs.TreeMapLayout")
    })(MindFusion.Graphs);
    (function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Vertex = mg.Vertex = function() {
            this.edges = new ArrayList();
            this.outEdges = new ArrayList();
            this.inEdges = new ArrayList();
            this.weight = 1
        };
        Vertex.prototype.clone = function() {
            var copy = new Vertex();
            if (this.layer !== undefined) {
                copy.layer = this.layer
            }
            if (this.weight !== undefined) {
                copy.weight = this.weight
            }
            if (this.balance !== undefined) {
                copy.balance = this.balance
            }
            if (this.owner !== undefined) {
                copy.owner = this.owner
            }
            return copy
        };
        Vertex.prototype.removeEdge = function(edge) {
            if (edge.origin == this) {
                this.edges.remove(edge);
                this.outEdges.remove(edge);
                edge.origin = null
            }
            if (edge.destination == this) {
                this.edges.remove(edge);
                this.inEdges.remove(edge);
                edge.destination = null
            }
        };
        Vertex.prototype.incidentWith = function(edge) {
            return this.edges.contains(edge)
        };
        Vertex.prototype.adjacentTo = function(vertex) {
            return this.getCommonEdge(vertex) !== null
        };
        Vertex.prototype.getCommonEdge = function(vertex) {
            var thisRef = this;
            return this.edges.any(function(edge) {
                return edge.getOtherEnd(thisRef) === vertex
            }, this)
        };
        Vertex.prototype.getCommonEdges = function(vertex) {
            return this.edges.all(function(edge) {
                return edge.getOtherEnd(this) === vertex
            }, this)
        };
        Vertex.prototype.edgeTo = function(vertex) {
            return this.outEdges.any(function(edge) {
                return edge.destination == vertex
            })
        };
        Vertex.prototype.getNeighbors = function() {
            var neighbors = new ArrayList();
            this.inEdges.forEach(function(e) {
                neighbors.push(e.getOtherEnd(this))
            }, this);
            this.outEdges.forEach(function(e) {
                neighbors.push(e.getOtherEnd(this))
            }, this);
            return neighbors
        };
        Vertex.prototype.degree = function() {
            return this.edges.length
        };
        MindFusion.registerClass(Vertex, "MindFusion.Graphs.Vertex")
    })(MindFusion.Graphs);
    (function(mg) {
        var SpringLayout = mg.SpringLayout = function() {
            this.nodeDistance = 30;
            this.iterations = 300;
            this.refineStage = false;
            this.initialTemperature = 0;
            this.temperature = 0;
            this.anchoring = mg.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = mg.MultipleGraphsPlacement.Horizontal
        };
        SpringLayout.prototype.requiresSimpleGraph = true;
        SpringLayout.prototype.margins = 10;
        SpringLayout.prototype.arrange = function(graph) {
            this.initialTemperature = this.nodeDistance * 9;
            this.temperature = this.initialTemperature;
            this.graph = graph;
            var autoSize = calcAutoFrame(graph, averageNodeSize(graph), 1, 4);
            this.width = autoSize.width;
            this.height = autoSize.height;
            for (var step = 0; step < this.iterations; step++) {
                this.refineStage = step >= this.iterations * 3 / 4;
                graph.vertices.forEach(function(v) {
                    this.calcRepulsionForce(v)
                }, this);
                graph.edges.forEach(function(e) {
                    this.calcSpringForce(e)
                }, this);
                graph.vertices.forEach(function(v) {
                    this.applyForce(v)
                }, this);
                this.temperature = this.refineStage ? this.initialTemperature / 30 : this.initialTemperature * (1 - step / this.iterations / 2)
            }
        };
        SpringLayout.prototype.moveToEpsilonCircle = function(v, radius) {
            var a = Math.random() * 2 * Math.PI;
            var l = radius * Math.random();
            if (l == 0) {
                l = radius / 2
            }
            v.x += l * Math.cos(a);
            v.y -= l * Math.sin(a)
        };
        SpringLayout.prototype.attraction = function(distance, desiredDistance, v1, v2) {
            var a = 0;
            if (this.refineStage) {
                var vx = v1.x - v2.x;
                var vy = v1.y - v2.y;
                var r1x = v1.width / 2;
                var r1y = v1.height / 2;
                var r2x = v2.width / 2;
                var r2y = v2.height / 2;
                a = (vx * vx) / Math.pow(r1x + r2x + desiredDistance, 2) + (vy * vy) / Math.pow(r1y + r2y + desiredDistance, 2)
            } else {
                a = distance * distance / desiredDistance / desiredDistance
            }
            return a * 4 / 3
        };
        SpringLayout.prototype.repulsion = function(distance, desiredDistance, v1, v2) {
            return 1 / this.attraction(distance, desiredDistance, v1, v2)
        };
        SpringLayout.prototype.calcRepulsionForce = function(v) {
            v.dx = 0;
            v.dy = 0;
            var desiredDist = this.nodeDistance;
            this.graph.vertices.forEach(function(v2) {
                if (v2 == v) {
                    return
                }
                while (v.x == v2.x && v.y == v2.y) {
                    this.moveToEpsilonCircle(v2, desiredDist / 4)
                }
                var vx = v.x - v2.x;
                var vy = v.y - v2.y;
                var distance = Math.sqrt(vx * vx + vy * vy);
                var r = this.repulsion(distance, desiredDist, v, v2);
                v.dx += (vx / distance) * r;
                v.dy += (vy / distance) * r
            }, this)
        };
        SpringLayout.prototype.calcSpringForce = function(e) {
            var v1 = e.origin;
            var v2 = e.destination;
            var desiredDist = this.nodeDistance;
            while (v1.x == v2.x && v1.y == v2.y) {
                this.moveToEpsilonCircle(v2, desiredDist / 4)
            }
            var vx = v1.x - v2.x;
            var vy = v1.y - v2.y;
            var distance = Math.sqrt(vx * vx + vy * vy);
            var a = this.attraction(distance, desiredDist, v1, v2);
            var dx = (vx / distance) * a;
            var dy = (vy / distance) * a;
            v1.dx -= dx;
            v1.dy -= dy;
            v2.dx += dx;
            v2.dy += dy
        };
        SpringLayout.prototype.applyForce = function(v) {
            var offset = Math.sqrt(v.dx * v.dx + v.dy * v.dy);
            if (offset == 0) {
                return
            }
            v.x += Math.min(offset, this.temperature) * v.dx / offset;
            v.y += Math.min(offset, this.temperature) * v.dy / offset;
            v.x = Math.min(this.width, Math.max(v.width / 2, v.x));
            v.y = Math.min(this.height, Math.max(v.height / 2, v.y))
        };

        function averageNodeSize(graph) {
            var size = 0;
            if (graph.vertices.length == 0) {
                return size
            }
            graph.vertices.forEach(function(v) {
                var area = v.width * v.height;
                if (area > 0) {
                    size += Math.sqrt(area)
                }
            });
            return size / graph.vertices.length
        }

        function calcAutoFrame(graph, averageNodeSize, widthHeightRatio, multiplier) {
            var squareSize = averageNodeSize * Math.ceil(Math.sqrt(graph.vertices.length));
            var width = squareSize * Math.sqrt(widthHeightRatio);
            var height = squareSize / Math.sqrt(widthHeightRatio);
            return {
                width: width * multiplier,
                height: height * multiplier
            }
        }
        SpringLayout.With = function() {
            if (!mg.SpringLayoutBuilder) {
                mg.SpringLayoutBuilder = new MindFusion.Builder(SpringLayout.prototype)
            } else {
                mg.SpringLayoutBuilder.setInstance(null)
            }
            return mg.SpringLayoutBuilder
        };
        SpringLayout.prototype.init = function() {
            if (!mg.SpringLayoutBuilder) {
                mg.SpringLayoutBuilder = new MindFusion.Builder(SpringLayout.prototype, null, this)
            } else {
                mg.SpringLayoutBuilder.setInstance(this)
            }
            return mg.SpringLayoutBuilder
        };
        SpringLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.SpringLayoutBuilder = null;
        SpringLayout.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        SpringLayout.prototype.setNodeDistance = function(value) {
            this.nodeDistance = value
        };
        SpringLayout.prototype.getIterations = function() {
            return this.iterations
        };
        SpringLayout.prototype.setIterations = function(value) {
            this.iterations = value
        };
        SpringLayout.prototype.getAnchoring = function() {
            return this.anchoring
        };
        SpringLayout.prototype.setAnchoring = function(value) {
            this.anchoring = value
        };
        SpringLayout.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        SpringLayout.prototype.setKeepGroupLayout = function(value) {
            this.keepGroupLayout = value
        };
        SpringLayout.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        SpringLayout.prototype.setMultipleGraphsPlacement = function(value) {
            this.multipleGraphsPlacement = value
        };
        MindFusion.registerClass(SpringLayout, "MindFusion.Graphs.SpringLayout")
    })(MindFusion.Graphs);
    (function(mg) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Set = MindFusion.Collections.Set;
        var Edge = MindFusion.Graphs.Edge;
        var Vertex = MindFusion.Graphs.Vertex;
        var LayeredLayout = mg.LayeredLayout = function() {
            this.nodeDistance = 20;
            this.layerDistance = 25;
            this.direction = mg.LayoutDirection.TopToBottom;
            this.siftingRounds = 1;
            this.anchoring = mg.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = mg.MultipleGraphsPlacement.Horizontal
        };
        LayeredLayout.prototype.setsLinkPoints = true;
        LayeredLayout.prototype.requiresConnectedGraph = true;
        LayeredLayout.prototype.requiresSimpleGraph = true;
        LayeredLayout.prototype.margins = 10;
        LayeredLayout.prototype.arrange = function(graph) {
            graph.setItemIndices();
            this.graph = graph;
            var reversedEdges = graph.makeAcyclic();
            for (var n = 0; n < graph.vertices.length; n++) {
                var node = graph.vertices[n];
                node.layer = -1;
                node.uBaryCenter = 0;
                node.dBaryCenter = 0;
                node.uLinkCount = 0;
                node.dLinkCount = 0;
                node.uPriority = 0;
                node.dPriority = 0;
                node.gridPosition = 0;
                node.dummy = false
            }
            for (var l = 0; l < graph.edges.length; l++) {
                var link = graph.edges[l];
                link.dummificationLevel = 0
            }
            var sinks = [];
            var current = [];
            var layering = new Dictionary();
            graph.vertices.forEach(function(node) {
                if (node.inEdges.length == 0) {
                    sinks.push(node);
                    layering.set(node, 0);
                    current.push(node)
                }
            });
            while (current.length > 0) {
                var next = current.shift();
                next.outEdges.forEach(function(link) {
                    var dest = link.destination;
                    if (!layering.contains(dest)) {
                        layering.set(dest, layering.get(next) + 1)
                    } else {
                        layering.set(dest, Math.max(layering.get(dest), layering.get(next) + 1))
                    }
                    if (!ArrayList.contains(current, dest)) {
                        current.push(dest)
                    }
                })
            }
            var layerCount = 0;
            layering.forEachValue(function(nodeLayer) {
                layerCount = Math.max(layerCount, nodeLayer)
            });
            var sortedNodes = [];
            ArrayList.addRange(sortedNodes, layering.keys());
            sortedNodes.sort(function(o1, o2) {
                var o1layer = layering.get(o1);
                var o2layer = layering.get(o2);
                if (o1layer < o2layer) {
                    return 1
                }
                if (o1layer > o2layer) {
                    return -1
                }
                return 0
            });
            for (var n = 0; n < sortedNodes.length; ++n) {
                var node = sortedNodes[n];
                var minLayer = Number.MAX_VALUE;
                if (node.outEdges.length == 0) {
                    continue
                }
                for (var l = 0; l < node.outEdges.length; ++l) {
                    var link = node.outEdges[l];
                    minLayer = Math.min(minLayer, layering.get(link.destination))
                }
                if (minLayer > 1) {
                    layering.set(node, minLayer - 1)
                }
            }
            this.layers = [];
            for (var i = 0; i < layerCount + 1; i++) {
                this.layers.push([])
            }
            layering.forEach(function(node, layer) {
                node.layer = layer;
                this.layers[layer].push(node)
            }, this);
            for (var l = 0; l < this.layers.length; l++) {
                var layer = this.layers[l];
                for (var i = 0; i < layer.length; i++) {
                    layer[i].gridPosition = i
                }
            }
            this.dummify();
            this.minimizeCrossings();
            this.swapPairs();
            this.layout();
            this.assignCoordinates();
            this.dedummify();
            reversedEdges.forEach(function(e) {
                if (e.points) {
                    e.points.reverse()
                }
            })
        };
        LayeredLayout.prototype.setMinDist = function(m, n, minDist) {
            var l = m.layer;
            var i = m.indexInLayer;
            this.minDistances[l][i] = minDist
        };
        LayeredLayout.prototype.getMinDist = function(m, n) {
            var l = m.layer;
            var i1 = m.indexInLayer;
            var i2 = n.indexInLayer;
            var min = Math.min(i1, i2);
            var max = Math.max(i1, i2);
            var dist = 0;
            for (var i = min; i < max; ++i) {
                dist += this.minDistances[l][i]
            }
            return dist
        };
        LayeredLayout.prototype.computeLeftClasses = function() {
            var nodeLeftClassRef = {
                value: null
            };
            var result = this.computeClasses(nodeLeftClassRef, 1);
            this.nodeLeftClass = nodeLeftClassRef.value;
            return result
        };
        LayeredLayout.prototype.computeRightClasses = function() {
            var nodeRightClassRef = {
                value: null
            };
            var result = this.computeClasses(nodeRightClassRef, -1);
            this.nodeRightClass = nodeRightClassRef.value;
            return result
        };
        LayeredLayout.prototype.computeClasses = function(nodeClassRef, d) {
            var nodeClass = nodeClassRef.value = new Dictionary();
            var currentClass = 0;
            for (var l = 0; l < this.layers.length; ++l) {
                currentClass = l;
                var layer = this.layers[l];
                for (var n = d == 1 ? 0 : layer.length - 1; 0 <= n && n < layer.length; n += d) {
                    var node = layer[n];
                    if (!nodeClass.contains(node)) {
                        nodeClass.set(node, currentClass);
                        if (node.dummy) {
                            this.nodesInLongLink(node).forEach(function(vnode) {
                                nodeClass.set(vnode, currentClass)
                            })
                        }
                    } else {
                        currentClass = nodeClass.get(node)
                    }
                }
            }
            var classes = [];
            for (var i = 0; i < this.layers.length; i++) {
                classes.push(null)
            }
            nodeClass.forEach(function(node, classIndex) {
                if (classes[classIndex] === null) {
                    classes[classIndex] = []
                }
                classes[classIndex].push(node)
            });
            return classes
        };
        LayeredLayout.prototype.placeLeftToRight = function(leftClasses) {
            var leftPos = new Dictionary();
            for (var c = 0; c < this.layers.length; ++c) {
                var classNodes = leftClasses[c];
                if (classNodes == null) {
                    continue
                }
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    if (!leftPos.contains(node)) {
                        this.placeLeft(node, leftPos, c)
                    }
                }
                var d = Number.POSITIVE_INFINITY;
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    var rightSibling = this.rightSibling(node);
                    if (rightSibling != null && this.nodeLeftClass.get(rightSibling) != c) {
                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling))
                    }
                }
                if (d == Number.POSITIVE_INFINITY) {
                    var D = [];
                    for (var n = 0; n < classNodes.length; n++) {
                        var node = classNodes[n];
                        var neighbors = [];
                        ArrayList.addRange(neighbors, this.upNodes.get(node));
                        ArrayList.addRange(neighbors, this.downNodes.get(node));
                        for (var e = 0; e < neighbors.length; e++) {
                            var neighbor = neighbors[e];
                            if (this.nodeLeftClass.get(neighbor) < c) {
                                D.push(leftPos.get(neighbor) - leftPos.get(node))
                            }
                        }
                    }
                    D.sort();
                    if (D.length == 0) {
                        d = 0
                    } else {
                        if (D.length % 2 == 1) {
                            d = D[intDiv(D.length, 2)]
                        } else {
                            d = (D[intDiv(D.length, 2) - 1] + D[intDiv(D.length, 2)]) / 2
                        }
                    }
                }
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    leftPos.set(node, leftPos.get(node) + d)
                }
            }
            return leftPos
        };
        LayeredLayout.prototype.placeRightToLeft = function(rightClasses) {
            var rightPos = new Dictionary();
            for (var c = 0; c < this.layers.length; ++c) {
                var classNodes = rightClasses[c];
                if (classNodes == null) {
                    continue
                }
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    if (!rightPos.contains(node)) {
                        this.placeRight(node, rightPos, c)
                    }
                }
                var d = Number.NEGATIVE_INFINITY;
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    var leftSibling = this.leftSibling(node);
                    if (leftSibling != null && this.nodeRightClass.get(leftSibling) != c) {
                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node))
                    }
                }
                if (d == Number.NEGATIVE_INFINITY) {
                    var D = [];
                    for (var n = 0; n < classNodes.length; n++) {
                        var node = classNodes[n];
                        var neighbors = [];
                        ArrayList.addRange(neighbors, this.upNodes.get(node));
                        ArrayList.addRange(neighbors, this.downNodes.get(node));
                        for (var e = 0; e < neighbors.length; e++) {
                            var neighbor = neighbors[e];
                            if (this.nodeRightClass.get(neighbor) < c) {
                                D.push(rightPos.get(node) - rightPos.get(neighbor))
                            }
                        }
                    }
                    D.sort();
                    if (D.length == 0) {
                        d = 0
                    } else {
                        if (D.length % 2 == 1) {
                            d = D[intDiv(D.length, 2)]
                        } else {
                            d = (D[intDiv(D.length, 2) - 1] + D[intDiv(D.length, 2)]) / 2
                        }
                    }
                }
                for (var n = 0; n < classNodes.length; n++) {
                    var node = classNodes[n];
                    rightPos.set(node, rightPos.get(node) + d)
                }
            }
            return rightPos
        };
        LayeredLayout.prototype.assignCoordinates = function() {
            for (var l = 0; l < this.layers.length; ++l) {
                var layer = this.layers[l];
                layer.sort(compareByGridPos)
            }
            this.minDistances = [];
            for (var l = 0; l < this.layers.length; ++l) {
                var layer = this.layers[l];
                this.minDistances[l] = [];
                for (var n = 0; n < layer.length; ++n) {
                    var node = layer[n];
                    node.indexInLayer = n;
                    this.minDistances[l][n] = this.nodeDistance;
                    if (n < layer.length - 1) {
                        if (this.direction % 2 == 0) {
                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2
                        } else {
                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2
                        }
                    }
                }
            }
            this.downNodes = new Dictionary();
            this.upNodes = new Dictionary();
            this.graph.vertices.forEach(function(node) {
                this.downNodes.set(node, []);
                this.upNodes.set(node, [])
            }, this);
            this.graph.edges.forEach(function(link) {
                var origin = link.origin;
                var dest = link.destination;
                var down = null,
                    up = null;
                if (origin.layer > dest.layer) {
                    down = link.origin;
                    up = link.destination
                } else {
                    up = link.origin;
                    down = link.destination
                }
                this.downNodes.get(up).push(down);
                this.upNodes.get(down).push(up)
            }, this);
            this.downNodes.forEachValue(function(list) {
                list.sort(compareByGridPos)
            });
            this.upNodes.forEachValue(function(list) {
                list.sort(compareByGridPos)
            });
            for (var l = 0; l < this.layers.length - 1; ++l) {
                var layer = this.layers[l];
                for (var u = 0; u < layer.length - 1; u++) {
                    var currNode = layer[u];
                    if (!currNode.dummy) {
                        continue
                    }
                    var currDown = this.downNodes.get(currNode)[0];
                    if (!currDown.dummy) {
                        continue
                    }
                    for (var n = u + 1; n < layer.length; ++n) {
                        var node = layer[n];
                        if (!node.dummy) {
                            continue
                        }
                        var downNode = this.downNodes.get(node)[0];
                        if (!downNode.dummy) {
                            continue
                        }
                        if (currDown.gridPosition > downNode.gridPosition) {
                            var pos = currDown.gridPosition;
                            currDown.gridPosition = downNode.gridPosition;
                            downNode.gridPosition = pos;
                            var i1 = currDown.indexInLayer;
                            var i2 = downNode.indexInLayer;
                            this.layers[l + 1][i1] = downNode;
                            this.layers[l + 1][i2] = currDown;
                            currDown.indexInLayer = i2;
                            downNode.indexInLayer = i1
                        }
                    }
                }
            }
            var leftClasses = this.computeLeftClasses();
            var rightClasses = this.computeRightClasses();
            var leftPos = this.placeLeftToRight(leftClasses);
            var rightPos = this.placeRightToLeft(rightClasses);
            var x = new Dictionary();
            this.graph.vertices.forEach(function(node) {
                x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2)
            });
            var order = new Dictionary();
            var placed = new Dictionary();
            for (var l = 0; l < this.layers.length; ++l) {
                var layer = this.layers[l];
                var sequenceStart = -1,
                    sequenceEnd = -1;
                for (var n = 0; n < layer.length; ++n) {
                    var node = layer[n];
                    order.set(node, 0);
                    placed.set(node, false);
                    if (node.dummy) {
                        if (sequenceStart == -1) {
                            sequenceStart = n
                        } else {
                            if (sequenceStart == n - 1) {
                                sequenceStart = n
                            } else {
                                sequenceEnd = n;
                                order.set(layer[sequenceStart], 0);
                                if (x.get(node) - x.get(layer[sequenceStart]) == this.getMinDist(layer[sequenceStart], node)) {
                                    placed.set(layer[sequenceStart], true)
                                } else {
                                    placed.set(layer[sequenceStart], false)
                                }
                                sequenceStart = n
                            }
                        }
                    }
                }
            }
            var directions = [1, -1];
            ArrayList.forEach(directions, function(d) {
                var start = d == 1 ? 0 : this.layers.length - 1;
                var end = d == 1 ? this.layers.length - 1 : 0;
                for (var l = start; 0 <= l && l < this.layers.length; l += d) {
                    var layer = this.layers[l];
                    var virtualStartIndex = leftMostVirtualNode(layer);
                    var virtualStart = null;
                    var sequence = null;
                    if (virtualStartIndex != -1) {
                        virtualStart = layer[virtualStartIndex];
                        sequence = [];
                        for (var i = 0; i < virtualStartIndex; i++) {
                            sequence.push(layer[i])
                        }
                    } else {
                        virtualStart = null;
                        sequence = layer
                    }
                    if (sequence.length > 0) {
                        this.placeSequence(x, null, virtualStart, d, sequence);
                        for (var i = 0; i < sequence.length - 1; ++i) {
                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]))
                        }
                        if (virtualStart != null) {
                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]))
                        }
                    }
                    while (virtualStart != null) {
                        var virtualEnd = nextVirtualNode(layer, virtualStart);
                        if (virtualEnd == null) {
                            virtualStartIndex = virtualStart.indexInLayer;
                            sequence = [];
                            for (var i = virtualStartIndex + 1; i < layer.length; i++) {
                                sequence.push(layer[i])
                            }
                            if (sequence.length > 0) {
                                this.placeSequence(x, virtualStart, null, d, sequence);
                                for (var i = 0; i < sequence.length - 1; ++i) {
                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]))
                                }
                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart))
                            }
                        } else {
                            if (order.get(virtualStart) == d) {
                                virtualStartIndex = virtualStart.indexInLayer;
                                var virtualEndIndex = virtualEnd.indexInLayer;
                                sequence = [];
                                for (var i = virtualStartIndex + 1; i < virtualEndIndex; i++) {
                                    sequence.push(layer[i])
                                }
                                if (sequence.length > 0) {
                                    this.placeSequence(x, virtualStart, virtualEnd, d, sequence)
                                }
                                placed.set(virtualStart, true)
                            }
                        }
                        virtualStart = virtualEnd
                    }
                    this.adjustDirections(l, d, order, placed)
                }
            }, this);
            var depth = this.margins;
            for (var i = (this.direction < 2 ? 0 : this.layers.length - 1); this.direction < 2 ? i < this.layers.length : i >= 0; i += (this.direction < 2 ? 1 : -1)) {
                var layer = this.layers[i];
                var height = Number.MIN_VALUE;
                for (var n = 0; n < layer.length; ++n) {
                    var node = layer[n];
                    if (this.direction % 2 == 0) {
                        height = Math.max(height, node.height)
                    } else {
                        height = Math.max(height, node.width)
                    }
                }
                for (var n = 0; n < layer.length; ++n) {
                    var node = layer[n];
                    var gridPosition = node.gridPosition;
                    if (this.direction % 2 == 0) {
                        node.x = x.get(node);
                        node.y = depth + height / 2
                    } else {
                        node.x = depth + height / 2;
                        node.y = x.get(node)
                    }
                }
                depth += this.layerDistance + height
            }
        };
        LayeredLayout.prototype.adjustDirections = function(l, d, order, placed) {
            if (l + d < 0 || l + d >= this.layers.length) {
                return
            }
            var prevBridge = null,
                prevBridgeTarget = null;
            var layer = this.layers[l + d];
            for (var n = 0; n < layer.length; ++n) {
                var nextBridge = layer[n];
                if (nextBridge.dummy) {
                    var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);
                    if (nextBridgeTarget.dummy) {
                        if (prevBridge != null) {
                            var p = placed.get(prevBridgeTarget);
                            var clayer = this.layers[l];
                            var i1 = prevBridgeTarget.indexInLayer;
                            var i2 = nextBridgeTarget.indexInLayer;
                            for (var i = i1 + 1; i < i2; ++i) {
                                if (clayer[i].dummy) {
                                    p = p && placed.get(clayer[i])
                                }
                            }
                            if (p) {
                                order.set(prevBridge, d);
                                var j1 = prevBridge.indexInLayer;
                                var j2 = nextBridge.indexInLayer;
                                for (var j = j1 + 1; j < j2; ++j) {
                                    if (layer[j].dummy) {
                                        order.set(layer[j], d)
                                    }
                                }
                            }
                        }
                        prevBridge = nextBridge;
                        prevBridgeTarget = nextBridgeTarget
                    }
                }
            }
        };
        LayeredLayout.prototype.getNeighborOnLayer = function(node, l) {
            var neighbor = this.upNodes.get(node)[0];
            if (neighbor.layer == l) {
                return neighbor
            }
            neighbor = this.downNodes.get(node)[0];
            if (neighbor.layer == l) {
                return neighbor
            }
            return null
        };
        LayeredLayout.prototype.placeSequence = function(x, virtualStart, virtualEnd, dir, sequence) {
            if (sequence.length == 1) {
                this.placeSingle(x, virtualStart, virtualEnd, dir, sequence[0])
            }
            if (sequence.length > 1) {
                var r = sequence.length,
                    t = intDiv(r, 2);
                this.placeSequence(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));
                this.placeSequence(x, virtualStart, virtualEnd, dir, sequence.slice(t));
                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence)
            }
        };
        LayeredLayout.prototype.placeSingle = function(x, virtualStart, virtualEnd, dir, node) {
            var neighbors = dir == -1 ? this.downNodes.get(node) : this.upNodes.get(node);
            var n = neighbors.length;
            if (n != 0) {
                if (n % 2 == 1) {
                    x.set(node, x.get(neighbors[intDiv(n, 2)]))
                } else {
                    x.set(node, (x.get(neighbors[intDiv(n, 2) - 1]) + x.get(neighbors[intDiv(n, 2)])) / 2)
                }
                if (virtualStart != null) {
                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)))
                }
                if (virtualEnd != null) {
                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)))
                }
            }
        };
        LayeredLayout.prototype.combineSequences = function(x, virtualStart, virtualEnd, dir, sequence) {
            var r = sequence.length,
                t = intDiv(r, 2);
            var leftHeap = [];
            for (var i = 0; i < t; ++i) {
                var c = 0;
                var neighbors = dir == -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);
                for (var n = 0; n < neighbors.length; ++n) {
                    var neighbor = neighbors[n];
                    if (x.get(neighbor) >= x.get(sequence[i])) {
                        c++
                    } else {
                        c--;
                        leftHeap.push({
                            k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]),
                            v: 2
                        })
                    }
                }
                leftHeap.push({
                    k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]),
                    v: c
                })
            }
            if (virtualStart != null) {
                leftHeap.push({
                    k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]),
                    v: Number.MAX_VALUE
                })
            }
            leftHeap.sort(compareByPosDecreasing);
            var rightHeap = [];
            for (var i = t; i < r; ++i) {
                var c = 0;
                var neighbors = dir == -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);
                for (var n = 0; n < neighbors.length; ++n) {
                    var neighbor = neighbors[n];
                    if (x.get(neighbor) <= x.get(sequence[i])) {
                        c++
                    } else {
                        c--;
                        rightHeap.push({
                            k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]),
                            v: 2
                        })
                    }
                }
                rightHeap.push({
                    k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]),
                    v: c
                })
            }
            if (virtualEnd != null) {
                rightHeap.push({
                    k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]),
                    v: Number.MAX_VALUE
                })
            }
            rightHeap.sort(compareByPosIncreasing);
            var leftRes = 0,
                rightRes = 0;
            var m = this.getMinDist(sequence[t - 1], sequence[t]);
            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {
                if (leftRes < rightRes) {
                    if (leftHeap.length == 0) {
                        x.set(sequence[t - 1], x.get(sequence[t]) - m);
                        break
                    } else {
                        var pair = leftHeap.shift();
                        leftRes = leftRes + pair.v;
                        x.set(sequence[t - 1], pair.k);
                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m))
                    }
                } else {
                    if (rightHeap.length == 0) {
                        x.set(sequence[t], x.get(sequence[t - 1]) + m);
                        break
                    } else {
                        var pair = rightHeap.shift();
                        rightRes = rightRes + pair.v;
                        x.set(sequence[t], pair.k);
                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m))
                    }
                }
            }
            for (var i = t - 2; i >= 0; i--) {
                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])))
            }
            for (var i = t + 1; i < r; i++) {
                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])))
            }
        };
        LayeredLayout.prototype.placeLeft = function(node, leftPos, leftClass) {
            var pos = Number.NEGATIVE_INFINITY;
            this.L(node).forEach(function(v) {
                var leftSibling = this.leftSibling(v);
                if (leftSibling != null && this.nodeLeftClass.get(leftSibling) == this.nodeLeftClass.get(v)) {
                    if (!leftPos.contains(leftSibling)) {
                        this.placeLeft(leftSibling, leftPos, leftClass)
                    }
                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v))
                }
            }, this);
            if (pos == Number.NEGATIVE_INFINITY) {
                pos = 0
            }
            this.L(node).forEach(function(v) {
                leftPos.set(v, pos)
            })
        };
        LayeredLayout.prototype.placeRight = function(node, rightPos, rightClass) {
            var pos = Number.POSITIVE_INFINITY;
            this.L(node).forEach(function(v) {
                var rightSibling = this.rightSibling(v);
                if (rightSibling != null && this.nodeRightClass.get(rightSibling) == this.nodeRightClass.get(v)) {
                    if (!rightPos.contains(rightSibling)) {
                        this.placeRight(rightSibling, rightPos, rightClass)
                    }
                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling))
                }
            }, this);
            if (pos == Number.POSITIVE_INFINITY) {
                pos = 0
            }
            this.L(node).forEach(function(v) {
                rightPos.set(v, pos)
            })
        };
        LayeredLayout.prototype.leftSibling = function(node) {
            var layer = this.layers[node.layer];
            var i = node.indexInLayer;
            if (i == 0) {
                return null
            }
            return layer[i - 1]
        };
        LayeredLayout.prototype.rightSibling = function(node) {
            var layer = this.layers[node.layer];
            var i = node.indexInLayer;
            if (i == layer.length - 1) {
                return null
            }
            return layer[i + 1]
        };
        LayeredLayout.prototype.L = function(node) {
            if (node.dummy) {
                return this.nodesInLongLink(node)
            }
            var list = new ArrayList();
            list.push(node);
            return list
        };
        LayeredLayout.prototype.layout = function() {
            for (var l = 0; l < this.layers.length; l++) {
                var layer = this.layers[l];
                for (var ni = 0; ni < layer.length; ni++) {
                    var node = layer[ni];
                    node.uPriority = node.uLinkCount;
                    node.dPriority = node.dLinkCount
                }
            }
            var maxLayoutIterations = 2;
            for (var it = 0; it < maxLayoutIterations; it++) {
                for (var i = this.layers.length - 1; i >= 1; i--) {
                    this.layoutLayer(false, i)
                }
                for (var i = 0; i < this.layers.length - 1; i++) {
                    this.layoutLayer(true, i)
                }
            }
            var gridPos = Number.MAX_VALUE;
            for (var l = 0; l < this.layers.length; l++) {
                var layer = this.layers[l];
                for (var ni = 0; ni < layer.length; ni++) {
                    var node = layer[ni];
                    gridPos = Math.min(gridPos, node.gridPosition)
                }
            }
            if (gridPos < 0) {
                for (var l = 0; l < this.layers.length; l++) {
                    var layer = this.layers[l];
                    for (var ni = 0; ni < layer.length; ni++) {
                        var node = layer[ni];
                        node.gridPosition = node.gridPosition - gridPos
                    }
                }
            }
        };
        LayeredLayout.prototype.layoutLayer = function(down, layer) {
            var iconsidered;
            var considered;
            if (down) {
                considered = this.layers[iconsidered = layer + 1]
            } else {
                considered = this.layers[iconsidered = layer - 1]
            }
            var sorted = [];
            for (var n = 0; n < considered.length; n++) {
                sorted.push(considered[n])
            }
            sorted.sort(function(n1, n2) {
                var n1Priority = (n1.uPriority + n1.dPriority) / 2;
                var n2Priority = (n2.uPriority + n2.dPriority) / 2;
                if (Math.abs(n1Priority - n2Priority) < 0.0001) {
                    return 0
                }
                if (n1Priority < n2Priority) {
                    return 1
                }
                return -1
            });
            ArrayList.forEach(sorted, function(node) {
                var nodeGridPos = node.gridPosition;
                var nodeBaryCenter = calcBaryCenter(node);
                var nodePriority = (node.uPriority + node.dPriority) / 2;
                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {
                    return
                }
                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {
                    return
                }
                if (nodeGridPos < nodeBaryCenter) {
                    while (nodeGridPos < nodeBaryCenter) {
                        if (!this.moveRight(node, considered, nodePriority)) {
                            break
                        }
                        nodeGridPos = node.gridPosition
                    }
                } else {
                    while (nodeGridPos > nodeBaryCenter) {
                        if (!this.moveLeft(node, considered, nodePriority)) {
                            break
                        }
                        nodeGridPos = node.gridPosition
                    }
                }
            }, this);
            if (iconsidered > 0) {
                this.calcDownData(iconsidered - 1)
            }
            if (iconsidered < this.layers.length - 1) {
                this.calcUpData(iconsidered + 1)
            }
        };
        LayeredLayout.prototype.moveRight = function(node, layer, priority) {
            var index = ArrayList.indexOf(layer, node);
            if (index == layer.length - 1) {
                node.gridPosition = node.gridPosition + 0.5;
                return true
            }
            var rightNode = layer[index + 1];
            var rightNodePriority = (rightNode.uPriority + rightNode.dPriority) / 2;
            if (rightNode.gridPosition > node.gridPosition + 1) {
                node.gridPosition = node.gridPosition + 0.5;
                return true
            }
            if (rightNodePriority > priority || Math.abs(rightNodePriority - priority) < 0.0001) {
                return false
            }
            if (this.moveRight(rightNode, layer, priority)) {
                node.gridPosition = node.gridPosition + 0.5;
                return true
            }
            return false
        };
        LayeredLayout.prototype.moveLeft = function(node, layer, priority) {
            var index = ArrayList.indexOf(layer, node);
            if (index == 0) {
                node.gridPosition = node.gridPosition - 0.5;
                return true
            }
            var leftNode = layer[index - 1];
            var leftNodePriority = (leftNode.uPriority + leftNode.dPriority) / 2;
            if (leftNode.gridPosition < node.gridPosition - 1) {
                node.gridPosition = node.gridPosition - 0.5;
                return true
            }
            if (leftNodePriority > priority || Math.abs(leftNodePriority - priority) < 0.0001) {
                return false
            }
            if (this.moveLeft(leftNode, layer, priority)) {
                node.gridPosition = node.gridPosition - 0.5;
                return true
            }
            return false
        };
        LayeredLayout.prototype.mapVirtualNode = function(node, link) {
            this.nodeToLinkMap.set(node, link);
            if (!this.linkToNodeMap.contains(link)) {
                this.linkToNodeMap.set(link, new ArrayList())
            }
            this.linkToNodeMap.get(link).push(node)
        };
        LayeredLayout.prototype.nodesInLongLink = function(node) {
            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node))
        };
        LayeredLayout.prototype.dummify = function() {
            this.linkToNodeMap = new Dictionary();
            this.nodeToLinkMap = new Dictionary();
            var links = this.graph.edges.slice(0);
            for (var l = 0; l < links.length; l++) {
                var link = links[l];
                var o = link.origin;
                var d = link.destination;
                var oLayer = o.layer;
                var dLayer = d.layer;
                var oPos = o.gridPosition;
                var dPos = d.gridPosition;
                var step = (dPos - oPos) / Math.abs(dLayer - oLayer);
                var p = o;
                if (oLayer - dLayer > 1) {
                    for (var i = oLayer - 1; i > dLayer; i--) {
                        var newNode = new Vertex();
                        newNode.x = o.x;
                        newNode.y = o.y;
                        newNode.width = o.width / 100;
                        newNode.height = o.height / 100;
                        var layer = this.layers[i];
                        var pos = (i - dLayer) * step + oPos;
                        if (pos > layer.length) {
                            pos = layer.length
                        }
                        if (oPos >= this.layers[oLayer].length - 1 && dPos >= this.layers[dLayer].length - 1) {
                            pos = layer.length
                        } else {
                            if (oPos == 0 && dPos == 0) {
                                pos = 0
                            }
                        }
                        newNode.layer = i;
                        newNode.uBaryCenter = 0;
                        newNode.dBaryCenter = 0;
                        newNode.uLinkCount = 0;
                        newNode.dLinkCount = 0;
                        newNode.gridPosition = pos;
                        newNode.dummy = true;
                        ArrayList.insert(layer, pos, newNode);
                        for (var r = pos + 1; r < layer.length; r++) {
                            var node = layer[r];
                            node.gridPosition = node.gridPosition + 1
                        }
                        var newLink = new Edge(p, newNode);
                        newLink.dummificationLevel = 0;
                        p = newNode;
                        this.graph.vertices.push(newNode);
                        this.graph.addEdge(newLink);
                        newNode.index = this.graph.vertices.length - 1;
                        this.mapVirtualNode(newNode, link)
                    }
                    link.changeOrigin(p);
                    link.dummificationLevel = oLayer - dLayer - 1
                }
                if (oLayer - dLayer < -1) {
                    for (var i = oLayer + 1; i < dLayer; i++) {
                        var newNode = new Vertex();
                        newNode.x = o.x;
                        newNode.y = o.y;
                        newNode.width = o.width / 100;
                        newNode.height = o.height / 100;
                        var layer = this.layers[i];
                        var pos = (i - oLayer) * step + oPos;
                        if (pos > layer.length) {
                            pos = layer.length
                        }
                        if (oPos >= this.layers[oLayer].length - 1 && dPos >= this.layers[dLayer].length - 1) {
                            pos = layer.length
                        } else {
                            if (oPos == 0 && dPos == 0) {
                                pos = 0
                            }
                        }
                        newNode.layer = i;
                        newNode.uBaryCenter = 0;
                        newNode.dBaryCenter = 0;
                        newNode.uLinkCount = 0;
                        newNode.dLinkCount = 0;
                        newNode.gridPosition = pos;
                        newNode.dummy = true;
                        pos = pos & pos;
                        ArrayList.insert(layer, pos, newNode);
                        for (var r = pos + 1; r < layer.length; r++) {
                            var node = layer[r];
                            node.gridPosition = node.gridPosition + 1
                        }
                        var newLink = new Edge(p, newNode);
                        newLink.dummificationLevel = 0;
                        p = newNode;
                        this.graph.vertices.push(newNode);
                        this.graph.addEdge(newLink);
                        newNode.index = this.graph.vertices.length - 1;
                        this.mapVirtualNode(newNode, link)
                    }
                    link.changeOrigin(p);
                    link.dummificationLevel = dLayer - oLayer - 1
                }
            }
        };
        LayeredLayout.prototype.dedummify = function() {
            var dedum = true;
            while (dedum) {
                dedum = false;
                for (var l = 0; l < this.graph.edges.length; l++) {
                    var link = this.graph.edges[l];
                    if (link.dummificationLevel == 0) {
                        continue
                    }
                    var points = [];
                    ArrayList.insert(points, 0, {
                        x: link.destination.x,
                        y: link.destination.y
                    });
                    ArrayList.insert(points, 0, {
                        x: link.origin.x,
                        y: link.origin.y
                    });
                    var temp = link;
                    var dummificationLevel = link.dummificationLevel;
                    for (var d = 0; d < dummificationLevel; d++) {
                        var node = temp.origin;
                        var prevLink = node.inEdges[0];
                        ArrayList.insert(points, 0, {
                            x: prevLink.origin.x,
                            y: prevLink.origin.y
                        });
                        temp = prevLink
                    }
                    link.changeOrigin(temp.origin);
                    link.dummificationLevel = 0;
                    link.points = points;
                    dedum = true;
                    break
                }
            }
        };
        LayeredLayout.prototype.minimizeCrossings = function() {
            var moves = -1;
            var maxIterations = 3;
            var iter = 0;
            while (moves != 0) {
                if (iter++ > maxIterations) {
                    break
                }
                moves = 0;
                for (var i = this.layers.length - 1; i >= 1; i--) {
                    moves += this.minimizeCrossingsDir(false, i)
                }
                for (var i = 0; i < this.layers.length - 1; i++) {
                    moves += this.minimizeCrossingsDir(true, i)
                }
            }
        };
        LayeredLayout.prototype.calcUpData = function(layer) {
            if (layer == 0) {
                return
            }
            var considered = this.layers[layer];
            var upLayer = new Set();
            var temp = this.layers[layer - 1];
            for (var i = 0; i < temp.length; i++) {
                upLayer.add(temp[i])
            }
            for (var i = 0; i < considered.length; i++) {
                var node = considered[i];
                var sum = 0;
                var total = 0;
                for (var l = 0; l < node.inEdges.length; l++) {
                    var link = node.inEdges[l];
                    if (upLayer.contains(link.origin)) {
                        total++;
                        sum += link.origin.gridPosition
                    }
                }
                for (var l = 0; l < node.outEdges.length; l++) {
                    var link = node.outEdges[l];
                    if (upLayer.contains(link.destination)) {
                        total++;
                        sum += link.destination.gridPosition
                    }
                }
                if (total > 0) {
                    node.uBaryCenter = sum / total;
                    node.uLinkCount = total
                } else {
                    node.uBaryCenter = i;
                    node.uLinkCount = 0
                }
            }
        };
        LayeredLayout.prototype.calcDownData = function(layer) {
            if (layer == this.layers.length - 1) {
                return
            }
            var considered = this.layers[layer];
            var downLayer = new Set();
            var temp = this.layers[layer + 1];
            for (var i = 0; i < temp.length; i++) {
                downLayer.add(temp[i])
            }
            for (var i = 0; i < considered.length; i++) {
                var node = considered[i];
                var sum = 0;
                var total = 0;
                for (var l = 0; l < node.inEdges.length; l++) {
                    var link = node.inEdges[l];
                    if (downLayer.contains(link.origin)) {
                        total++;
                        sum += link.origin.gridPosition
                    }
                }
                for (var l = 0; l < node.outEdges.length; l++) {
                    var link = node.outEdges[l];
                    if (downLayer.contains(link.destination)) {
                        total++;
                        sum += link.destination.gridPosition
                    }
                }
                if (total > 0) {
                    node.dBaryCenter = sum / total;
                    node.dLinkCount = total
                } else {
                    node.dBaryCenter = i;
                    node.dLinkCount = 0
                }
            }
        };
        LayeredLayout.prototype.minimizeCrossingsDir = function(down, layer) {
            var iconsidered;
            var considered;
            if (down) {
                considered = this.layers[iconsidered = layer + 1]
            } else {
                considered = this.layers[iconsidered = layer - 1]
            }
            var presorted = considered.slice(0);
            if (down) {
                this.calcUpData(iconsidered)
            } else {
                this.calcDownData(iconsidered)
            }
            considered.sort(function(n1, n2) {
                var n1BaryCenter = calcBaryCenter(n1);
                var n2BaryCenter = calcBaryCenter(n2);
                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {
                    if (n1.degree() == n2.degree()) {
                        return compareByIndex(n1, n2)
                    } else {
                        if (n1.degree() < n2.degree()) {
                            return 1
                        }
                    }
                    return -1
                }
                var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;
                if (compareValue > 0) {
                    return -1
                } else {
                    if (compareValue < 0) {
                        return 1
                    }
                }
                return compareByIndex(n1, n2)
            });
            var moves = 0;
            for (var i = 0; i < considered.length; i++) {
                if (considered[i] != presorted[i]) {
                    moves++
                }
            }
            if (moves > 0) {
                var inode = 0;
                for (var i = 0; i < considered.length; i++) {
                    var node = considered[i];
                    node.gridPosition = inode++
                }
            }
            return moves
        };
        LayeredLayout.prototype.swapPairs = function() {
            var maxIterations = this.siftingRounds;
            var iter = 0;
            while (true) {
                if (iter++ > maxIterations) {
                    break
                }
                var downwards = (iter % 4 <= 1);
                var secondPass = (iter % 4 == 1);
                for (var l = (downwards ? 0 : this.layers.length - 1); downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {
                    var layer = this.layers[l];
                    var hasSwapped = false;
                    var calcCrossings = true;
                    var memCrossings = 0;
                    for (var n = 0; n < layer.length - 1; n++) {
                        var up = 0;
                        var down = 0;
                        var crossBefore = 0;
                        if (calcCrossings) {
                            if (l != 0) {
                                up = this.countCrossings(l - 1, l)
                            }
                            if (l != this.layers.length - 1) {
                                down = this.countCrossings(l, l + 1)
                            }
                            if (downwards) {
                                up *= 2
                            } else {
                                down *= 2
                            }
                            crossBefore = up + down
                        } else {
                            crossBefore = memCrossings
                        }
                        if (crossBefore == 0) {
                            continue
                        }
                        var node1 = layer[n];
                        var node2 = layer[n + 1];
                        var node1GridPos = node1.gridPosition;
                        var node2GridPos = node2.gridPosition;
                        layer[n] = node2;
                        layer[n + 1] = node1;
                        node1.gridPosition = node2GridPos;
                        node2.gridPosition = node1GridPos;
                        up = 0;
                        if (l != 0) {
                            up = this.countCrossings(l - 1, l)
                        }
                        down = 0;
                        if (l != this.layers.length - 1) {
                            down = this.countCrossings(l, l + 1)
                        }
                        if (downwards) {
                            up *= 2
                        } else {
                            down *= 2
                        }
                        var crossAfter = up + down;
                        var revert = false;
                        if (secondPass) {
                            revert = crossAfter >= crossBefore
                        } else {
                            revert = crossAfter > crossBefore
                        }
                        if (revert) {
                            node1 = layer[n];
                            node2 = layer[n + 1];
                            node1GridPos = node1.gridPosition;
                            node2GridPos = node2.gridPosition;
                            layer[n] = node2;
                            layer[n + 1] = node1;
                            node1.gridPosition = node2GridPos;
                            node2.gridPosition = node1GridPos;
                            memCrossings = crossBefore;
                            calcCrossings = false
                        } else {
                            hasSwapped = true;
                            calcCrossings = true
                        }
                    }
                    if (hasSwapped) {
                        if (l != this.layers.length - 1) {
                            this.calcUpData(l + 1)
                        }
                        if (l != 0) {
                            this.calcDownData(l - 1)
                        }
                    }
                }
            }
        };
        LayeredLayout.prototype.countCrossings = function(ulayer, dlayer) {
            var crossings = 0;
            var uLayer = new Set();
            var temp1 = this.layers[ulayer];
            for (var i = 0; i < temp1.length; i++) {
                uLayer.add(temp1[i])
            }
            var dLayer = new Set();
            var temp2 = this.layers[dlayer];
            for (var i = 0; i < temp2.length; i++) {
                dLayer.add(temp2[i])
            }
            var dlinks = new Set();
            var links = [];
            var temp = [];
            uLayer.forEach(function(node) {
                ArrayList.addRange(temp, node.inEdges);
                ArrayList.addRange(temp, node.outEdges)
            });
            for (var ti = 0; ti < temp.length; ti++) {
                var link = temp[ti];
                if (uLayer.contains(link.origin) && dLayer.contains(link.destination)) {
                    dlinks.add(link);
                    links.push(link)
                } else {
                    if (dLayer.contains(link.origin) && uLayer.contains(link.destination)) {
                        links.push(link)
                    }
                }
            }
            for (var l1 = 0; l1 < links.length; l1++) {
                var link1 = links[l1];
                for (var l2 = 0; l2 < links.length; l2++) {
                    if (l1 == l2) {
                        continue
                    }
                    var link2 = links[l2];
                    var n11, n12;
                    var n21, n22;
                    if (dlinks.contains(link1)) {
                        n11 = link1.origin;
                        n12 = link1.destination
                    } else {
                        n11 = link1.destination;
                        n12 = link1.origin
                    }
                    if (dlinks.contains(link2)) {
                        n21 = link2.origin;
                        n22 = link2.destination
                    } else {
                        n21 = link2.destination;
                        n22 = link2.origin
                    }
                    var n11gp = n11.gridPosition;
                    var n12gp = n12.gridPosition;
                    var n21gp = n21.gridPosition;
                    var n22gp = n22.gridPosition;
                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {
                        crossings++
                    }
                }
            }
            return crossings / 2
        };

        function calcBaryCenter(node) {
            var uLinkCount = node.uLinkCount;
            var dLinkCount = node.dLinkCount;
            var uBaryCenter = node.uBaryCenter;
            var dBaryCenter = node.dBaryCenter;
            if (uLinkCount > 0 && dLinkCount > 0) {
                return (uBaryCenter + dBaryCenter) / 2
            }
            if (uLinkCount > 0) {
                return uBaryCenter
            }
            if (dLinkCount > 0) {
                return dBaryCenter
            }
            return 0
        }

        function compareByGridPos(x, y) {
            if (x.gridPosition < y.gridPosition) {
                return -1
            }
            if (x.gridPosition > y.gridPosition) {
                return 1
            }
            return 0
        }

        function compareByPosIncreasing(x, y) {
            if (x.k < y.k) {
                return -1
            }
            if (x.k > y.k) {
                return 1
            }
            return 0
        }

        function compareByPosDecreasing(x, y) {
            if (x.k < y.k) {
                return 1
            }
            if (x.k > y.k) {
                return -1
            }
            return 0
        }

        function leftMostVirtualNode(layer) {
            for (var c = 0; c < layer.length; c++) {
                if (layer[c].dummy) {
                    return c
                }
            }
            return -1
        }

        function compareByIndex(o1, o2) {
            var i1 = o1.index;
            var i2 = o2.index;
            if (i1 < i2) {
                return 1
            }
            if (i1 > i2) {
                return -1
            }
            return 0
        }

        function intDiv(numerator, denominator) {
            return (numerator - numerator % denominator) / denominator
        }

        function nextVirtualNode(layer, node) {
            var nodeIndex = node.indexInLayer;
            for (var i = nodeIndex + 1; i < layer.length; ++i) {
                if (layer[i].dummy) {
                    return layer[i]
                }
            }
            return null
        }
        LayeredLayout.With = function() {
            if (!mg.LayeredLayoutBuilder) {
                mg.LayeredLayoutBuilder = new MindFusion.Builder(LayeredLayout.prototype)
            } else {
                mg.LayeredLayoutBuilder.setInstance(null)
            }
            return mg.LayeredLayoutBuilder
        };
        LayeredLayout.prototype.init = function() {
            if (!mg.LayeredLayoutBuilder) {
                mg.LayeredLayoutBuilder = new MindFusion.Builder(LayeredLayout.prototype, null, this)
            } else {
                mg.LayeredLayoutBuilder.setInstance(this)
            }
            return mg.LayeredLayoutBuilder
        };
        LayeredLayout.prototype.getType = function() {
            return this.constructor.__typeName
        };
        mg.LayeredLayoutBuilder = null;
        LayeredLayout.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        LayeredLayout.prototype.setNodeDistance = function(value) {
            this.nodeDistance = value
        };
        LayeredLayout.prototype.getLayerDistance = function() {
            return this.layerDistance
        };
        LayeredLayout.prototype.setLayerDistance = function(value) {
            this.layerDistance = value
        };
        LayeredLayout.prototype.getDirection = function() {
            return this.direction
        };
        LayeredLayout.prototype.setDirection = function(value) {
            this.direction = value
        };
        LayeredLayout.prototype.getSiftingRounds = function() {
            return this.siftingRounds
        };
        LayeredLayout.prototype.setSiftingRounds = function(value) {
            this.siftingRounds = value
        };
        LayeredLayout.prototype.getAnchoring = function() {
            return this.anchoring
        };
        LayeredLayout.prototype.setAnchoring = function(value) {
            this.anchoring = value
        };
        LayeredLayout.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        LayeredLayout.prototype.setKeepGroupLayout = function(value) {
            this.keepGroupLayout = value
        };
        LayeredLayout.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        LayeredLayout.prototype.setMultipleGraphsPlacement = function(value) {
            this.multipleGraphsPlacement = value
        };
        MindFusion.registerClass(LayeredLayout, "MindFusion.Graphs.LayeredLayout")
    })(MindFusion.Graphs);
    MindFusion.Diagramming.AnchorPoint = function(x, y, allowIncoming, allowOutgoing, style, color, size) {
        this.x = (x) ? x : 0;
        this.y = (y) ? y : 0;
        this.allowIncoming = (allowIncoming != undefined) ? allowIncoming : true;
        this.allowOutgoing = (allowOutgoing != undefined) ? allowOutgoing : true;
        this.markStyle = (style !== undefined) ? style : MindFusion.Diagramming.MarkStyle.Cross;
        this.color = (color) ? color : "#000000";
        this.col = -1;
        this.tag = null;
        this.size = (size) ? size : 3
    };
    MindFusion.Diagramming.AnchorPoint.prototype = {
        toJson: function() {
            return {
                x: this.x,
                y: this.y,
                allowIncoming: this.allowIncoming,
                allowOutgoing: this.allowOutgoing,
                markStyle: this.markStyle,
                color: this.color,
                column: this.col,
                tag: this.tag,
                size: this.size
            }
        },
        fromJson: function(json) {
            this.setX(json.x);
            this.setY(json.y);
            this.setAllowIncoming(json.allowIncoming);
            this.setAllowOutgoing(json.allowOutgoing);
            this.setMarkStyle(json.markStyle);
            this.setColor(json.color);
            this.setColumn(json.column);
            this.setTag(json.tag);
            this.setSize(json.size)
        },
        saveToXml: function(xmlElement, context) {
            context.writeBool(this.allowIncoming, "AllowIncoming", xmlElement);
            context.writeBool(this.allowOutgoing, "AllowOutgoing", xmlElement);
            context.writeColor(this.color, "Color", xmlElement);
            context.writeInt(this.col, "Column", xmlElement);
            context.writeInt(this.markStyle, "MarkStyle", xmlElement);
            context.writeTag(this, this.tag, "Tag", xmlElement);
            context.writeString(this.toolTip, "Tooltip", xmlElement);
            context.writeFloat(this.x, "X", xmlElement);
            context.writeFloat(this.y, "Y", xmlElement)
        },
        getPosition: function(nodeRect) {
            return new Point(nodeRect.x + nodeRect.width * this.x / 100, nodeRect.y + nodeRect.height * this.y / 100)
        },
        getX: function() {
            return this.x
        },
        setX: function(value) {
            this.x = value
        },
        getY: function() {
            return this.y
        },
        setY: function(value) {
            this.y = value
        },
        getColumn: function() {
            return this.col
        },
        setColumn: function(value) {
            this.col = value
        },
        getAllowIncoming: function() {
            return this.allowIncoming
        },
        setAllowIncoming: function(value) {
            this.allowIncoming = value
        },
        getAllowOutgoing: function() {
            return this.allowOutgoing
        },
        setAllowOutgoing: function(value) {
            this.allowOutgoing = value
        },
        getMarkStyle: function() {
            return this.markStyle
        },
        setMarkStyle: function(value) {
            this.markStyle = value
        },
        getColor: function() {
            return this.color
        },
        setColor: function(value) {
            this.color = value
        },
        getTag: function() {
            return this.tag
        },
        setTag: function(value) {
            this.tag = value
        },
        getToolTip: function() {
            return this.toolTip
        },
        setToolTip: function(value) {
            if (this.toolTip != value) {
                if (value == null) {
                    this.toolTip = ""
                } else {
                    this.toolTip = value
                }
            }
        },
        getSize: function() {
            return this.size
        },
        setSize: function(value) {
            this.size = value
        },
        updatePointData: function(context, nodeRect, angle, customDrawArgs, markSize) {
            var cX = nodeRect.x + nodeRect.width * this.x / 100;
            var cY = nodeRect.y + nodeRect.height * this.y / 100;
            var d = markSize / 2
        }
    };
    MindFusion.registerClass(MindFusion.Diagramming.AnchorPoint, "MindFusion.Diagramming.AnchorPoint");
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var Manipulator = mdiag.Manipulator = function(node) {
            mflayer.initializeBase(Manipulator, this);
            this.node = node
        };
        Manipulator.prototype = {
            updateLocation: function() {},
            hitTest: function(mousePosition) {},
            onClick: function(mousePosition) {},
            needsMouseMessages: function(mousePosition) {
                return false
            },
            onMouseDown: function(mousePosition) {},
            onMouseMove: function(mousePosition) {},
            onMouseUp: function(mousePosition) {},
            cancel: function() {},
            setMouseCursor: function(mousePosition) {}
        };
        MindFusion.registerClass(Manipulator, "MindFusion.Diagramming.Manipulator", MindFusion.Drawing.Container)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.LengthType = {
        Auto: 0,
        Relative: 1
    };
    MindFusion.Diagramming.Cursors = {
        TopLeft: 0,
        TopCenter: 1,
        TopRight: 2,
        MiddleLeft: 3,
        MiddleCenter: 4,
        MiddleRight: 5,
        BottomLeft: 6,
        BottomCenter: 7,
        BottomRight: 8,
        Rotate: 9,
        Pointer: 10,
        Default: 11
    };
    MindFusion.Diagramming.ImageAlign = MindFusion.Drawing.ImageAlign;
    MindFusion.Diagramming.Alignment = {
        Near: 0,
        Center: 1,
        Far: 2
    };
    MindFusion.Diagramming.CellFrameStyle = {
        None: 0,
        Simple: 1,
        System3D: 2
    };
    MindFusion.Diagramming.AdjustmentHandles = {
        None: 0,
        ResizeTopLeft: 1,
        ResizeTopRight: 2,
        ResizeBottomRight: 4,
        ResizeBottomLeft: 8,
        ResizeTopCenter: 16,
        ResizeMiddleRight: 32,
        ResizeBottomCenter: 64,
        ResizeMiddleLeft: 128,
        Move: 256,
        Rotate: 512,
        All: 1023
    };
    MindFusion.Diagramming.Behavior = {
        Modify: 0,
        DrawShapes: 1,
        DrawLinks: 2,
        LinkShapes: 3,
        LinkTables: 4,
        DrawTables: 5,
        DoNothing: 8,
        Custom: 9,
        DrawContainers: 10,
        LinkContainers: 11,
        Pan: 12,
        DrawSvgNodes: 15,
        LinkSvgNodes: 16,
        SelectOnly: 17,
        DrawFreeForms: 23,
        LinkFreeForms: 24,
        DrawFreeShapes: 25,
        LinkFreeShapes: 26
    };
    MindFusion.Diagramming.Action = {
        None: 0,
        Create: 1,
        Modify: 2,
        Split: 3
    };
    MindFusion.Diagramming.ConnectionStyle = {
        Node: 0,
        Rows: 1
    };
    MindFusion.Diagramming.DelKeyAction = {
        None: 0,
        DeleteActiveItem: 1,
        DeleteSelectedItems: 2
    };
    MindFusion.Diagramming.MarkStyle = {
        None: 0,
        Cross: 1,
        X: 2,
        Circle: 3,
        Rectangle: 4
    };
    MindFusion.Diagramming.ShowAnchors = {
        Always: 0,
        Never: 1,
        Auto: 2,
        Selected: 4
    };
    MindFusion.Diagramming.GridStyle = {
        Points: 0,
        Lines: 1,
        Crosses: 2
    };
    MindFusion.Diagramming.ColumnStyle = {
        FixedWidth: 0,
        AutoWidth: 1
    };
    MindFusion.Diagramming.LinkShape = {
        Bezier: 0,
        Polyline: 1,
        Cascading: 2,
        Spline: 3
    };
    MindFusion.Diagramming.RelativeToLink = {
        Segment: 0,
        ControlPoint: 1,
        LinkLength: 2
    };
    MindFusion.Diagramming.FitSize = {
        KeepWidth: 0,
        KeepHeight: 1,
        KeepRatio: 2
    };
    MindFusion.Diagramming.EffectPhase = {
        BeforeFill: 0,
        AfterFill: 1,
        AfterOutline: 2
    };
    MindFusion.Diagramming.GlassEffectType = {
        Type1: 0,
        Type2: 1,
        Type3: 2,
        Type4: 3
    };
    MindFusion.Diagramming.HandlesStyle = {
        Invisible: 0,
        SquareHandles: 1,
        DashFrame: 2,
        HatchFrame: 3,
        HatchHandles: 4,
        HatchHandles2: 5,
        HatchHandles3: 6,
        MoveOnly: 7,
        EasyMove: 8,
        SquareHandles2: 9,
        Custom: 10,
        InvisibleMove: 11,
        RoundAndSquare: 12,
        RoundAndSquare2: 13
    };
    MindFusion.Diagramming.LinkCrossings = {
        Straight: 0,
        Arcs: 1,
        Cut: 2
    };
    MindFusion.Diagramming.ModificationStart = {
        SelectedOnly: 0,
        AutoHandles: 1
    };
    MindFusion.Diagramming.AutoResize = {
        None: 0,
        RightAndDown: 1,
        AllDirections: 2
    };
    MindFusion.Diagramming.ModifierKeyAction = {
        None: 0,
        Pan: 1,
        Select: 2,
        OverrideBehavior: 3,
        Magnify: 4
    };
    MindFusion.Diagramming.MouseButtonActions = {
        None: 0,
        Pan: 1,
        Cancel: 2,
        Select: 4,
        Draw: 8,
        Magnify: 16
    };
    MindFusion.Diagramming.LinkTextStyle = {
        Center: 0,
        Rotate: 1,
        OverLongestSegment: 2,
        Follow: 3,
        MiddleSegment: 4,
        MiddleSegmentRotated: 5
    };
    MindFusion.Diagramming.ShadowsStyle = {
        None: 0,
        OneLevel: 1,
        ZOrder: 2
    };
    MindFusion.Diagramming.SimpleShape = {
        Rectangle: 0,
        RoundedRectangle: 1
    };
    MindFusion.Diagramming.Orientation = {
        Auto: 0,
        Horizontal: 1,
        Vertical: 2
    };
    MindFusion.Diagramming.SaveToStringFormat = {
        Json: 0,
        Xml: 1
    };
    MindFusion.Diagramming.ScaleMode = {
        FitAll: 0,
        CombinedScales: 1,
        FixedScale: 2,
    };
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Font = MindFusion.Drawing.Font;
        var FontStyle = MindFusion.Drawing.FontStyle;
        var Thickness = MindFusion.Drawing.Thickness;
        var DiagramItem = mdiag.DiagramItem = function(parent) {
            mflayer.initializeBase(DiagramItem, this);
            this.parent = parent;
            this.bounds = new MindFusion.Drawing.Rect(0, 0, 20, 20);
            this.text = new MindFusion.Drawing.Text("", this.bounds);
            if (DiagramItem.useStyles === false) {
                this.brush = {
                    type: "SolidBrush",
                    color: "#FFFFFF"
                };
                this.pen = "#000000";
                this.strokeThickness = 0
            }
            this.selected = false;
            this.ignoreLayout = false;
            this.tooltip = "";
            this.hyperLink = "";
            this.textPadding = new Thickness(1, 1, 1, 1);
            this.topLevel = true;
            this.graphicsContainer = new MindFusion.Drawing.Container(0, 0)
        };
        DiagramItem.prototype = {
            getType: function() {
                return this.constructor.__typeName
            },
            clone: function() {
                var copy = new this.constructor(this.parent);
                copy.bounds = this.bounds.clone();
                copy.textColor = this.textColor;
                copy.textStroke = this.textStroke;
                copy.textStrokeThickness = this.textStrokeThickness;
                copy.setTextPadding(Thickness.copy(this.textPadding));
                copy.font = (this.font) ? Font.copy(this.font) : undefined;
                copy.brush = this.brush;
                copy.pen = this.pen;
                copy.strokeThickness = this.strokeThickness;
                copy.strokeDashStyle = this.strokeDashStyle;
                copy.ignoreLayout = this.ignoreLayout;
                copy.layoutTraits = this.layoutTraits;
                copy.handlesSize = this.handlesSize;
                copy.locked = this.locked;
                copy.tooltip = this.tooltip;
                copy.hyperLink = this.hyperLink;
                copy.shadowColor = this.shadowColor;
                copy.shadowOffsetX = this.shadowOffsetX;
                copy.shadowOffsetY = this.shadowOffsetY;
                copy.style = (this.style) ? this.style.clone() : undefined;
                copy.setTextAlignment(this.getTextAlignment());
                copy.setLineAlignment(this.getLineAlignment());
                copy.setZIndex(this.getZIndex());
                copy.setTag(this.getTag());
                copy.setId(this.getId());
                copy.setVisible(this.getVisible());
                copy.invalidate(false);
                return copy
            },
            toJson: function() {
                var json = {
                    __type: this.getType(),
                    instanceId: this.instanceId,
                    zIndex: this.getZIndex(),
                    tag: this.tag || null,
                    id: this.id || null,
                    layoutTraits: this.layoutTraits,
                    text: this.getText(),
                    textColor: this.textColor,
                    textStroke: this.textStroke,
                    textStrokeThickness: this.textStrokeThickness,
                    textPadding: this.textPadding,
                    font: this.font,
                    ignoreLayout: this.ignoreLayout,
                    brush: this.brush,
                    pen: this.pen,
                    strokeThickness: this.strokeThickness,
                    strokeDashStyle: this.strokeDashStyle,
                    selected: this.selected,
                    visible: this.getVisible(),
                    locked: this.getLocked(),
                    tooltip: this.tooltip,
                    hyperLink: this.hyperLink,
                    shadowColor: this.shadowColor,
                    shadowOffsetX: this.getShadowOffsetX(),
                    shadowOffsetY: this.getShadowOffsetY(),
                    textAlignment: this.getTextAlignment(),
                    lineAlignment: this.getLineAlignment(),
                    style: this.style ? this.style.toJson() : null
                };
                return json
            },
            fromJson: function(json) {
                this.setZIndex(json.zIndex);
                this.setTag(json.tag);
                this.setId(json.id);
                this.setText(json.text);
                this.setBrush(json.brush);
                this.setPen(json.pen);
                this.strokeThickness = json.strokeThickness;
                this.strokeDashStyle = json.strokeDashStyle;
                this.layoutTraits = json.layoutTraits;
                this.textColor = json.textColor;
                this.textStroke = json.textStroke;
                this.textStrokeThickness = json.textStrokeThickness;
                if (json.textPadding) {
                    this.setTextPadding(Thickness.copy(json.textPadding))
                }
                if (json.visible !== undefined) {
                    this.setVisible(json.visible)
                }
                if (json.ignoreLayout) {
                    this.ignoreLayout = true
                }
                if (json.font) {
                    this.font = Font.copy(json.font)
                }
                if (json.style) {
                    this.style = new mdiag.Style(false);
                    this.style.fromJson(json.style)
                }
                if (json.locked !== undefined) {
                    this.locked = json.locked
                }
                this.tooltip = json.tooltip;
                this.hyperLink = json.hyperLink;
                this.shadowColor = json.shadowColor;
                this.shadowOffsetX = json.shadowOffsetX;
                this.shadowOffsetY = json.shadowOffsetY;
                if (json.textAlignment !== undefined) {
                    this.setTextAlignment(json.textAlignment)
                }
                if (json.lineAlignment !== undefined) {
                    this.setLineAlignment(json.lineAlignment)
                }
            },
            loadFromXml: function(xmlElement, context) {
                this.setZIndex(context.readInt("ZIndex", xmlElement));
                this.hyperLink = context.readString("HyperLink", xmlElement);
                this.locked = context.readBool("Locked", xmlElement);
                this.setVisible(context.readBool("Visible", xmlElement, true));
                this.brush = context.readBrush("Brush", xmlElement);
                this.style = context.readStyle("Style", xmlElement);
                var legacyPen = context.readPen("Pen", xmlElement);
                if (legacyPen) {
                    this.pen = legacyPen.brush;
                    this.strokeThickness = legacyPen.width;
                    this.strokeDashStyle = legacyPen.dashStyle
                } else {
                    this.pen = context.readBrush("Stroke", xmlElement);
                    this.strokeThickness = context.readFloat("StrokeThickness", xmlElement);
                    this.strokeDashStyle = MindFusion.Drawing.DashStyle[context.readString("StrokeDashStyle", xmlElement)];
                    if (this.strokeDashStyle === undefined) {
                        this.strokeDashStyle = context.readInt("StrokeDashStyle", xmlElement)
                    }
                }
                this.font = context.readFont("Font", xmlElement);
                if (!this.font) {
                    var fontFamily = context.readString("FontFamily", xmlElement);
                    var fontSize = context.readFloat("FontSize", xmlElement);
                    if (fontFamily != "" && fontSize > 0) {
                        this.font = new Font(fontFamily, fontSize)
                    }
                }
                this.setText(context.readString("Text", xmlElement));
                this.textColor = context.readBrush("TextBrush", xmlElement);
                this.setTextPadding(context.readThickness("TextPadding", xmlElement));
                this.ignoreLayout = context.readBool("IgnoreLayout", xmlElement);
                this.tooltip = context.readString("ToolTip", xmlElement);
                this.shadowColor = context.readBrush("ShadowBrush", xmlElement, this.shadowColor);
                this.shadowOffsetX = context.readFloat("ShadowOffsetX", xmlElement, context.diagram.getShadowOffsetX());
                this.shadowOffsetY = context.readFloat("ShadowOffsetY", xmlElement, context.diagram.getShadowOffsetY());
                this.tag = context.readTag(this, "Tag", xmlElement);
                this.id = context.readTag(this, "Id", xmlElement)
            },
            saveToXml: function(xmlElement, context) {
                context.writeInt(this.getZIndex(), "ZIndex", xmlElement);
                context.writeString(this.hyperLink, "HyperLink", xmlElement);
                context.writeBool(this.getLocked(), "Locked", xmlElement);
                context.writeBool(this.getVisible(), "Visible", xmlElement);
                if (this.brush) {
                    context.writeBrush(this.brush, "Brush", xmlElement)
                }
                if (this.constructor.xmlInfo) {
                    context.writeStyle(this.style, "Style", xmlElement, this.constructor.xmlInfo.classId + "Style")
                }
                if (this.pen) {
                    context.writeBrush(this.pen, "Stroke", xmlElement)
                }
                if (this.strokeThickness !== undefined) {
                    context.writeFloat(this.strokeThickness, "StrokeThickness", xmlElement)
                }
                if (this.strokeDashStyle !== undefined) {
                    context.writeInt(this.strokeDashStyle, "StrokeDashStyle", xmlElement)
                }
                if (this.font) {
                    context.writeFont(this.font, "Font", xmlElement)
                }
                context.writeString(this.getText(), "Text", xmlElement);
                context.writeBrush(this.textColor, "TextBrush", xmlElement);
                context.writeThickness(this.getTextPadding(), "TextPadding", xmlElement);
                context.writeBool(this.ignoreLayout, "IgnoreLayout", xmlElement);
                if (this.tooltip) {
                    context.writeString(this.tooltip, "ToolTip", xmlElement)
                }
                context.writeBrush(this.shadowColor, "ShadowBrush", xmlElement);
                if (this.shadowOffsetX !== undefined) {
                    context.writeFloat(this.shadowOffsetX, "ShadowOffsetX", xmlElement)
                }
                if (this.shadowOffsetY !== undefined) {
                    context.writeFloat(this.shadowOffsetY, "ShadowOffsetY", xmlElement)
                }
                context.writeTag(this, this.tag, "Tag", xmlElement);
                context.writeTag(this, this.id, "Id", xmlElement)
            },
            onLoad: function(items) {},
            getParent: function() {
                return this.parent
            },
            setParent: function(value) {
                this.parent = value
            },
            setDiagramDirty: function() {
                if (this.parent && this.parent.setDirty) {
                    this.parent.setDirty(true)
                }
            },
            setText: function(value) {
                if (value != undefined && value !== this.text.text) {
                    this.text.text = value + "";
                    this.invalidate()
                }
            },
            getText: function() {
                return this.text.text
            },
            setTextColor: function(value) {
                if (this.textColor !== value) {
                    this.textColor = value;
                    this.invalidate()
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextStroke: function(value) {
                if (this.textStroke !== value) {
                    this.textStroke = value;
                    this.invalidate()
                }
            },
            getTextStroke: function() {
                return this.textStroke
            },
            setTextStrokeThickness: function(value) {
                if (this.textStrokeThickness !== value) {
                    this.textStrokeThickness = value;
                    this.invalidate()
                }
            },
            getTextStrokeThickness: function() {
                return this.textStrokeThickness
            },
            setTextPadding: function(value) {
                if (this.textPadding !== value) {
                    this.textPadding = value;
                    this.text.padding = value;
                    this.invalidate()
                }
            },
            getTextPadding: function() {
                return this.textPadding
            },
            setFont: function(value) {
                if (this.font !== value) {
                    this.font = value;
                    this.invalidate()
                }
            },
            getFont: function() {
                return this.font
            },
            setBrush: function(value) {
                if (this.brush !== value) {
                    this.brush = value;
                    this.invalidate()
                }
            },
            getBrush: function() {
                return this.brush
            },
            setPen: function(value) {
                if (this.pen !== value) {
                    this.pen = value;
                    this.invalidate()
                }
            },
            getPen: function() {
                return this.pen
            },
            setStroke: function(value) {
                if (this.pen !== value) {
                    this.pen = value;
                    this.invalidate()
                }
            },
            getStroke: function() {
                return this.pen
            },
            setStrokeThickness: function(value) {
                if (this.strokeThickness !== value) {
                    this.strokeThickness = value;
                    this.invalidate()
                }
            },
            getStrokeThickness: function() {
                return this.strokeThickness
            },
            setStrokeDashStyle: function(value) {
                if (this.strokeDashStyle !== value) {
                    this.strokeDashStyle = value;
                    this.invalidate()
                }
            },
            getStrokeDashStyle: function() {
                return this.strokeDashStyle
            },
            setTag: function(value) {
                if (this.tag !== value) {
                    this.tag = value;
                    this.setDiagramDirty()
                }
            },
            getTag: function() {
                return this.tag
            },
            setWeight: function(value) {
                if (this.weight !== value) {
                    this.weight = value;
                    this.setDiagramDirty()
                }
            },
            getWeight: function() {
                if (this.weight === undefined) {
                    return 1
                }
                return this.weight
            },
            setId: function(value) {
                if (this.id !== value) {
                    this.id = value;
                    this.setDiagramDirty()
                }
            },
            getId: function() {
                return this.id
            },
            setTooltip: function(value) {
                if (this.tooltip !== value) {
                    this.tooltip = value;
                    this.setDiagramDirty()
                }
            },
            getTooltip: function() {
                return this.tooltip
            },
            setIgnoreLayout: function(value) {
                if (this.ignoreLayout !== value) {
                    this.ignoreLayout = value;
                    this.setDiagramDirty()
                }
            },
            getIgnoreLayout: function() {
                return this.ignoreLayout
            },
            getLayoutTraits: function() {
                if (!this.layoutTraits) {
                    this.layoutTraits = {}
                }
                return this.layoutTraits
            },
            isFrozen: function() {
                return this.ignoreLayout || !this.getVisible()
            },
            setZIndex: function(value) {
                if (this.graphicsContainer.zIndex !== value) {
                    this.graphicsContainer.zIndex = value;
                    if (this.parent && this.parent.invalidateZOrder) {
                        this.parent.invalidateZOrder()
                    }
                    this.setDiagramDirty()
                }
            },
            getZIndex: function() {
                return this.graphicsContainer.zIndex
            },
            getRuntimeIndex: function() {
                if (this.parent) {
                    return ArrayList.indexOf(this.parent.items, this)
                }
                return null
            },
            setSelectedState: function(value) {
                if (this.selected != value) {
                    this.selected = value;
                    this.invalidate()
                }
            },
            setSelected: function(value) {
                if (this.parent && this.selected != value) {
                    if (value) {
                        this.parent.selection.addItem(this)
                    } else {
                        this.parent.selection.removeItem(this)
                    }
                    this.setDiagramDirty()
                }
            },
            getSelected: function() {
                return this.selected
            },
            setHyperLink: function(value) {
                if (this.hyperLink !== value) {
                    this.hyperLink = value || "";
                    this.setDiagramDirty()
                }
            },
            getHyperLink: function() {
                return this.hyperLink || ""
            },
            getContainer: function() {
                return this.container
            },
            startDrag: function(ist) {},
            updateDrag: function(ist) {},
            endDrag: function(ist) {},
            allowDrag: function(ist) {
                return true
            },
            saveLocationState: function() {
                return null
            },
            restoreLocationState: function(ist) {},
            onRemove: function() {
                if (this.parent) {
                    if (this.container) {
                        this.container.remove(this, true)
                    }
                    this.parent.raiseDeleted(this);
                    this.parent = null
                }
            },
            containsPoint: function(point) {
                return false
            },
            hitTest: function(point, threshold, onlyNodes, onlyInteractive) {
                if (this.parent != null && !this.parent.isItemVisible(this)) {
                    return null
                }
                if (onlyInteractive && this.parent != null && !this.parent.isItemInteractive(this)) {
                    return null
                }
                var contains = threshold > 0 ? this.containsPoint(point, threshold) : this.containsPoint(point);
                return contains ? this : null
            },
            notInteractive: function() {
                return !this.getVisible() || this.locked
            },
            addCanvasElements: function() {
                this.graphicsContainer.item = this;
                this.parent.addElement(this.graphicsContainer);
                this.invalidate(false)
            },
            removeCanvasElements: function() {
                if (this.parent) {
                    this.parent.removeElement(this.graphicsContainer)
                }
            },
            onShapeLoaded: function() {},
            updateCanvasElements: function() {},
            invalidate: function(dirty) {
                this.graphicsContainer.invalidParent = this;
                if (this.parent) {
                    this.parent.invalidate();
                    if (dirty === undefined) {
                        dirty = true
                    }
                    if (dirty && this.parent.setDirty) {
                        this.parent.setDirty(true)
                    }
                }
            },
            setVisible: function(value) {
                if (this.graphicsContainer.invisible == !value) {
                    return
                }
                if (value) {
                    delete this.graphicsContainer.invisible;
                    if (this.onShow) {
                        this.onShow()
                    }
                } else {
                    this.graphicsContainer.invisible = true;
                    if (this.selected) {
                        this.setSelected(false)
                    }
                    if (this.onHide) {
                        this.onHide()
                    }
                }
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            getVisible: function() {
                return this.graphicsContainer.invisible ? false : true
            },
            setLocked: function(value) {
                if (this.locked !== value) {
                    this.locked = value;
                    this.setDiagramDirty()
                }
            },
            getLocked: function() {
                return this.locked ? true : false
            },
            getTopLevel: function() {
                if (this.parent) {
                    var ist = this.parent.mouseInputDispatcher;
                    if (ist && ist.currentController) {
                        if (ist.currentController.modifiedItem == this) {
                            return true
                        }
                        if (ist.currentController.modifiedItem == this.parent.selection && this.selected) {
                            return true
                        }
                    }
                }
                return this.topLevel
            },
            setTopLevel: function(value) {
                this.topLevel = value
            },
            hitTestManipulators: function(mousePosition) {
                return null
            },
            getObjectToEdit: function(point) {
                return this
            },
            getDiagramItem: function() {
                return this
            },
            getTextToEdit: function() {
                return this.text.text
            },
            setEditedText: function(newText) {
                this.setText(newText)
            },
            setShadowColor: function(value) {
                if (this.shadowColor !== value) {
                    this.shadowColor = value;
                    this.invalidate()
                }
            },
            getShadowColor: function() {
                return this.shadowColor
            },
            setShadowOffsetX: function(value) {
                if (this.shadowOffsetX !== value) {
                    this.shadowOffsetX = value;
                    this.invalidate()
                }
            },
            getShadowOffsetX: function() {
                if (this.shadowOffsetX === undefined) {
                    if (this.parent.getShadowOffsetX) {
                        return this.parent.getShadowOffsetX()
                    }
                    return 4
                }
                return this.shadowOffsetX
            },
            setShadowOffsetY: function(value) {
                if (this.shadowOffsetY !== value) {
                    this.shadowOffsetY = value;
                    this.invalidate()
                }
            },
            getShadowOffsetY: function() {
                if (this.shadowOffsetY === undefined) {
                    if (this.parent.getShadowOffsetY) {
                        return this.parent.getShadowOffsetY()
                    }
                    return 4
                }
                return this.shadowOffsetY
            },
            createShadow: function() {
                var shadowColor = this.getEffectiveShadowColor();
                return shadowColor ? new MindFusion.Drawing.Shadow(shadowColor, this.getShadowOffsetX(), this.getShadowOffsetY()) : undefined
            },
            setStyle: function(value) {
                if (this.style !== value) {
                    this.style = value;
                    this.invalidate()
                }
            },
            getStyle: function() {
                return this.style
            },
            setTextAlignment: function(value) {
                if (this.text.textAlignment != value) {
                    this.text.textAlignment = value;
                    this.invalidate()
                }
            },
            getTextAlignment: function() {
                return this.text.textAlignment
            },
            setLineAlignment: function(value) {
                if (this.text.lineAlignment != value) {
                    this.text.lineAlignment = value;
                    this.invalidate()
                }
            },
            getLineAlignment: function() {
                return this.text.lineAlignment
            },
            getGraphicsContent: function() {
                return this.graphicsContainer.content
            },
            resolveEffectiveStyle: function(check) {
                if (this.style && check.apply(this.style)) {
                    return this.style
                }
                if (this.parent) {
                    var parentStyle = this.parent.style;
                    if (parentStyle && check.apply(parentStyle)) {
                        return parentStyle
                    }
                    var theme = this.parent.theme;
                    if (theme) {
                        var themeStyle = this.resolveInheritedStyle(check, theme);
                        if (themeStyle) {
                            return themeStyle
                        }
                    }
                }
                return this.resolveInheritedStyle(check, mdiag.Theme.Default)
            },
            resolveInheritedStyle: function(check, theme) {
                var diagItemStyle = theme.styles["std:DiagramItem"];
                if (diagItemStyle) {
                    if (check.apply(diagItemStyle)) {
                        return diagItemStyle
                    }
                }
                var diagramStyle = theme.styles["std:Diagram"];
                if (diagramStyle) {
                    if (check.apply(diagramStyle)) {
                        return diagramStyle
                    }
                }
                return null
            },
            getEffectiveBrush: function() {
                if (this.brush) {
                    return this.brush
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasBrush);
                if (style) {
                    return style.getBrush()
                }
                return "white"
            },
            getEffectiveStroke: function() {
                if (this.pen) {
                    return this.pen
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasStroke);
                if (style) {
                    return style.getStroke()
                }
                return "white"
            },
            getEffectiveStrokeThickness: function() {
                if (this.strokeThickness !== undefined) {
                    return this.strokeThickness
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasStrokeThickness);
                if (style) {
                    return style.getStrokeThickness()
                }
                return 0
            },
            getEffectiveStrokeDashStyle: function() {
                if (this.strokeDashStyle !== undefined) {
                    return this.strokeDashStyle
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasStrokeDashStyle);
                if (style) {
                    return style.getStrokeDashStyle()
                }
                return 0
            },
            getEffectiveTextColor: function() {
                if (this.textColor) {
                    return this.textColor
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasTextColor);
                if (style) {
                    return style.getTextColor()
                }
                return "black"
            },
            getEffectiveTextStroke: function() {
                return this.textStroke
            },
            getEffectiveTextStrokeThickness: function() {
                return this.textStrokeThickness || 0
            },
            getEffectiveFont: function() {
                if (this.font) {
                    return this.font
                }
                var fontStyle = this.getEffectiveFontStyle();
                var bold = (fontStyle & FontStyle.Bold) != 0;
                var italic = (fontStyle & FontStyle.Italic) != 0;
                var underline = (fontStyle & FontStyle.Underline) != 0;
                return new Font(this.getEffectiveFontName(), this.getEffectiveFontSize(), bold, italic, underline)
            },
            getEffectiveFontName: function() {
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasFontName);
                if (style) {
                    return style.getFontName()
                }
                return "sans-serif"
            },
            getEffectiveFontSize: function() {
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasFontSize);
                if (style) {
                    return style.getFontSize()
                }
                return 4
            },
            getEffectiveFontStyle: function() {
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasFontStyle);
                if (style) {
                    return style.getFontStyle()
                }
                return FontStyle.Regular
            },
            getEffectiveShadowColor: function() {
                if (this.shadowColor) {
                    return this.shadowColor
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasShadowColor);
                if (style) {
                    return style.getShadowColor()
                }
                return "gray"
            },
            getEffectiveHandlesSize: function() {
                if (this.handlesSize) {
                    return this.handlesSize
                }
                if (this.parent) {
                    return this.parent.getAdjustmentHandlesSize()
                }
                return 2
            },
            getTextComponent: function() {
                return this.text
            },
            saveState: function() {
                var state = {};
                state.zIndex = this.getZIndex();
                state.tag = this.tag;
                state.text = this.getText();
                state.textColor = this.textColor;
                state.font = this.font;
                state.ignoreLayout = this.ignoreLayout;
                state.brush = this.brush;
                state.pen = this.pen;
                state.strokeThickness = this.strokeThickness;
                state.selected = this.selected;
                state.visible = this.getVisible();
                state.locked = this.getLocked();
                state.tooltip = this.tooltip;
                state.hyperLink = this.hyperLink;
                state.shadowColor = this.shadowColor;
                state.shadowOffsetX = this.getShadowOffsetX();
                state.shadowOffsetY = this.getShadowOffsetY();
                state.style = this.style;
                state.textAlignment = this.getTextAlignment();
                state.lineAlignment = this.getLineAlignment();
                return state
            },
            restoreState: function(state) {
                this.setZIndex(state.zIndex);
                this.setTag(state.tag);
                this.setText(state.text);
                this.setBrush(state.brush);
                this.setPen(state.pen);
                this.strokeThickness = state.strokeThickness;
                this.textColor = state.textColor;
                this.setVisible(state.visible);
                this.ignoreLayout = state.ignoreLayout;
                this.font = state.font;
                this.style = state.style;
                this.locked = state.locked;
                this.tooltip = state.tooltip;
                this.hyperLink = state.hyperLink;
                this.shadowColor = state.shadowColor;
                this.shadowOffsetX = state.shadowOffsetX;
                this.shadowOffsetY = state.shadowOffsetY;
                if (state.textAlignment) {
                    this.setTextAlignment(state.textAlignment)
                }
                if (state.lineAlignment) {
                    this.setLineAlignment(state.lineAlignment)
                }
            }
        };
        DiagramItem.useStyles = true;
        MindFusion.registerClass(DiagramItem, "MindFusion.Diagramming.DiagramItem")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var ArrayList = MindFusion.Collections.ArrayList;
        var DiagramNode = mdiag.DiagramNode = function(parent) {
            mflayer.initializeBase(DiagramNode, this, [parent]);
            this.rotationAngle = 0;
            this.enabledHandles = mdiag.AdjustmentHandles.All & ~mdiag.AdjustmentHandles.Rotate;
            this.handlesStyle = mdiag.HandlesStyle.SquareHandles;
            this.incomingLinks = [];
            this.outgoingLinks = [];
            this.allowIncomingLinks = true;
            this.allowOutgoingLinks = true;
            this.obstacle = true;
            this.anchorPattern = null;
            this.anchorPointVisuals = new ArrayList();
            this.isAnchorPatternVisible = false;
            this.expandable = false;
            this.expanded = true;
            this.showDeleteButton = false;
            this.nodeEffects = [];
            this.setTextAlignment(mdiag.Alignment.Center);
            this.setLineAlignment(mdiag.Alignment.Center);
            if (parent && parent.nodesExpandable) {
                this.setExpandable(true)
            }
        };
        DiagramNode.nodesIntersect = function(node1, node2) {
            if (!node1.considerBounds() || !node2.considerBounds()) {
                return false
            }
            var rect = node1.bounds.intersect(node2.bounds);
            if (rect.height > 0 && rect.width > 0) {
                return true
            }
            return false
        };
        DiagramNode.prototype = {
            clone: function() {
                var copy = mflayer.callBaseMethod(DiagramNode, this, "clone", []);
                copy.rotationAngle = this.rotationAngle;
                copy.enabledHandles = this.enabledHandles;
                copy.handlesStyle = this.handlesStyle;
                copy.allowIncomingLinks = this.allowIncomingLinks;
                copy.allowOutgoingLinks = this.allowOutgoingLinks;
                copy.obstacle = this.obstacle;
                copy.anchorPattern = this.anchorPattern;
                copy.setExpandable(this.expandable);
                copy.expanded = this.expanded;
                copy.allowIncomingLinks = this.allowIncomingLinks;
                copy.allowOutgoingLinks = this.allowOutgoingLinks;
                copy.obstacle = this.obstacle;
                copy.nodeEffects = this.nodeEffects.slice(0);
                copy.text = this.text.clone();
                copy.setShowDeleteButton(this.showDeleteButton);
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(DiagramNode, this, "toJson", []);
                json.bounds = this.bounds;
                if (this.anchorPattern) {
                    json.anchorPattern = this.anchorPattern.toJson()
                }
                json.rotationAngle = this.rotationAngle;
                json.enabledHandles = this.enabledHandles;
                json.handlesStyle = this.handlesStyle;
                json.expanded = this.expanded;
                json.expandable = this.expandable;
                json.allowIncomingLinks = this.allowIncomingLinks;
                json.allowOutgoingLinks = this.allowOutgoingLinks;
                json.obstacle = this.obstacle;
                json.showDeleteButton = this.showDeleteButton;
                if (this.masterNode) {
                    json.master = this.masterNode.instanceId
                }
                if (this.container) {
                    json.container = this.container.instanceId
                }
                var effects = [];
                for (var i = 0, l = this.nodeEffects.length; i < l; i++) {
                    if (this.nodeEffects[i] == null) {
                        effects.push(null)
                    } else {
                        effects.push(this.nodeEffects[i].toJson())
                    }
                }
                json.effects = effects;
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(DiagramNode, this, "fromJson", [json]);
                this.setBounds(new Rect(json.bounds.x, json.bounds.y, json.bounds.width, json.bounds.height));
                if (json.anchorPattern) {
                    var id = json.anchorPattern.id;
                    var ap;
                    if (id) {
                        ap = mdiag.AnchorPattern.fromId(id)
                    } else {
                        ap = new mdiag.AnchorPattern();
                        ap.fromJson(json.anchorPattern)
                    }
                    ap.serverRegistered = true;
                    this.setAnchorPattern(ap)
                }
                this.setRotationAngle(json.rotationAngle);
                this.setEnabledHandles(json.enabledHandles);
                if (json.handlesStyle !== undefined) {
                    this.handlesStyle = json.handlesStyle
                }
                if (json.expanded !== undefined) {
                    this.expanded = json.expanded
                }
                if (json.expandable !== undefined) {
                    this.setExpandable(json.expandable)
                }
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                if (json.showDeleteButton !== undefined) {
                    this.setShowDeleteButton(json.showDeleteButton)
                }
                if (json.allowIncomingLinks !== undefined) {
                    this.setAllowIncomingLinks(json.allowIncomingLinks)
                }
                if (json.allowOutgoingLinks !== undefined) {
                    this.setAllowOutgoingLinks(json.allowOutgoingLinks)
                }
                if (json.obstacle !== undefined) {
                    this.setObstacle(json.obstacle)
                }
                if (json.master !== undefined) {
                    this.masterId = json.master
                }
                if (json.container !== undefined) {
                    this.containerId = json.container
                }
                this.nodeEffects = [];
                if (json.effects) {
                    for (var i = 0, l = json.effects.length; i < l; i++) {
                        if (json.effects[i] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var type = mflayer.parseType(json.effects[i].typeName);
                        if (type) {
                            var effect = new type(this);
                            effect.fromJson(json.effects[i]);
                            this.nodeEffects.push(effect)
                        }
                    }
                }
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(DiagramNode, this, "loadFromXml", [xmlElement, context]);
                this.setBounds(context.readRectangleF("Bounds", xmlElement));
                this.setRotationAngle(context.readFloat("RotationAngle", xmlElement));
                this.anchorPattern = context.readAnchorPattern("AnchorPattern", xmlElement);
                this.obstacle = context.readBool("Obstacle", xmlElement, true);
                this.allowIncomingLinks = context.readBool("AllowIncomingLinks", xmlElement, true);
                this.allowOutgoingLinks = context.readBool("AllowOutgoingLinks", xmlElement, true);
                this.setShowDeleteButton(context.readBool("ShowDeleteButton", xmlElement, false));
                this.expanded = context.readBool("Expanded", xmlElement, true);
                this.setExpandable(context.readBool("Expandable", xmlElement));
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                this.enabledHandles = context.readInt("EnabledHandles", xmlElement, this.enabledHandles);
                this.handlesStyle = context.readInt("HandlesStyle", xmlElement, this.handlesStyle);
                var group = context.readGroup("SubordinateGroup", xmlElement);
                if (group) {
                    for (var i = 0; i < group.attachedNodes.length; i++) {
                        group.attachedNodes[i].attachTo(this)
                    }
                    for (var i = 0; i < group.children.length; i++) {
                        this.add(group.children[i])
                    }
                }
                this.loadEffects("Effects", xmlElement, context)
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(DiagramNode, this, "saveToXml", [xmlElement, context]);
                context.writeRectangleF(this.getBounds(), "Bounds", xmlElement);
                context.writeFloat(this.getRotationAngle(), "RotationAngle", xmlElement);
                context.writeAnchorPattern(this.anchorPattern, "AnchorPattern", xmlElement);
                context.writeBool(this.obstacle, "Obstacle", xmlElement);
                context.writeBool(this.allowIncomingLinks, "AllowIncomingLinks", xmlElement);
                context.writeBool(this.allowOutgoingLinks, "AllowOutgoingLinks", xmlElement);
                context.writeBool(this.getShowDeleteButton(), "ShowDeleteButton", xmlElement);
                context.writeBool(this.expanded, "Expanded", xmlElement);
                context.writeBool(this.getExpandable(), "Expandable", xmlElement);
                context.writeInt(this.enabledHandles, "EnabledHandles", xmlElement);
                context.writeInt(this.handlesStyle, "HandlesStyle", xmlElement);
                var group = {
                    mainItem: this
                };
                if (this.attachedNodes && this.attachedNodes.length > 0) {
                    group.attachedNodes = this.getAttachedNodes()
                }
                if (this.children && this.children.length > 0) {
                    group.children = this.children
                }
                if (group.attachedNodes || group.children) {
                    context.writeGroup(group, "SubordinateGroup", xmlElement)
                }
                this.saveEffects("Effects", xmlElement, context)
            },
            loadEffects: function(elementName, parentElement, context) {
                this.nodeEffects = [];
                var element = context.selectSingleNode("Effects", parentElement);
                if (!element) {
                    return
                }
                var effectElements = element.getElementsByTagName("Effect");
                for (var i = 0; i < effectElements.length; i++) {
                    var effectElement = effectElements[i];
                    this.nodeEffects.push(context.readEffect(effectElement))
                }
            },
            saveEffects: function(elementName, parentElement, context) {
                var effectsElement = context.addChildElement(elementName, parentElement);
                for (var i = 0; i < this.nodeEffects.length; i++) {
                    context.writeEffect(this.nodeEffects[i], Effect, parentElement)
                }
            },
            onLoad: function(items) {
                mflayer.callBaseMethod(DiagramNode, this, "onLoad", [items]);
                if (this.masterId !== undefined) {
                    this.attachTo(items[this.masterId]);
                    delete this.masterId
                }
                if (this.containerId !== undefined) {
                    var container = items[this.containerId];
                    container.children.push(this);
                    this.container = container;
                    delete this.containerId
                }
            },
            getIncomingLinks: function() {
                return this.incomingLinks
            },
            getOutgoingLinks: function() {
                return this.outgoingLinks
            },
            setAllowIncomingLinks: function(value) {
                if (this.allowIncomingLinks !== value) {
                    this.allowIncomingLinks = value;
                    this.setDiagramDirty()
                }
            },
            getAllowIncomingLinks: function() {
                return this.allowIncomingLinks
            },
            setAllowOutgoingLinks: function(value) {
                if (this.allowOutgoingLinks !== value) {
                    this.allowOutgoingLinks = value;
                    this.setDiagramDirty()
                }
            },
            getAllowOutgoingLinks: function() {
                return this.allowOutgoingLinks
            },
            acceptLinks: function(outgoing) {
                if (outgoing && !this.allowOutgoingLinks) {
                    return false
                }
                if (!outgoing && !this.allowIncomingLinks) {
                    return false
                }
                return true
            },
            setRotationAngle: function(value, updateDependencies) {
                if (this.rotationAngle != value) {
                    this.rotationAngle = value;
                    if (this.parent) {
                        if (updateDependencies) {
                            this.updateLinks()
                        }
                        if (this.anchorPattern) {
                            this.updateAnchorPositions2()
                        }
                    }
                    this.invalidate()
                }
            },
            getRotationAngle: function() {
                return this.rotationAngle
            },
            raiseClicked: function(mousePosition, mouseButton) {
                var args = new mdiag.NodeEventArgs({
                    node: this,
                    mousePosition: mousePosition,
                    mouseButton: mouseButton
                });
                this.parent.raiseEvent(mdiag.Events.nodeClicked, args);
                return args.getHandled()
            },
            raiseDoubleClicked: function(mousePosition, mouseButton) {
                var args = new mdiag.NodeEventArgs({
                    node: this,
                    mousePosition: mousePosition,
                    mouseButton: mouseButton
                });
                this.parent.raiseEvent(mdiag.Events.nodeDoubleClicked, args);
                return args.getHandled()
            },
            createConnectionPoint: function(link, point, incoming) {
                var cp = new mdiag.ConnectionPoint(this, link, incoming);
                cp.anchorPointDetails.point = point;
                return cp
            },
            addIncomingLink: function(link) {
                if (!ArrayList.contains(this.incomingLinks, link)) {
                    this.incomingLinks.push(link)
                }
            },
            addOutgoingLink: function(link) {
                if (!ArrayList.contains(this.outgoingLinks, link)) {
                    this.outgoingLinks.push(link)
                }
            },
            removeIncomingLink: function(link) {
                ArrayList.remove(this.incomingLinks, link)
            },
            removeOutgoingLink: function(link) {
                ArrayList.remove(this.outgoingLinks, link)
            },
            getAllIncomingLinks: function(links) {
                for (var i = 0; i < this.incomingLinks.length; i++) {
                    if (links.indexOf(this.incomingLinks[i]) === -1) {
                        links.push(this.incomingLinks[i])
                    }
                }
            },
            getAllOutgoingLinks: function(links) {
                for (var i = 0; i < this.outgoingLinks.length; i++) {
                    if (links.indexOf(this.outgoingLinks[i]) === -1) {
                        links.push(this.outgoingLinks[i])
                    }
                }
            },
            getAllLinks: function() {
                var links = [];
                this.getAllIncomingLinks(links);
                this.getAllOutgoingLinks(links);
                return links
            },
            deleteLinks: function() {
                if (this.parent) {
                    var links = [];
                    this.getAllIncomingLinks(links);
                    this.getAllOutgoingLinks(links);
                    for (var i = 0; i < links.length; i++) {
                        this.parent.removeItem(links[i])
                    }
                }
            },
            updateDrag: function(ist) {
                var originalState = ist.originalStates.get(this);
                if (originalState == null) {
                    return
                }
                var oldBounds = originalState.bounds;
                var newRect = this.updateRect(oldBounds, this.bounds, ist);
                this.setBounds(newRect, false);
                this.updateAnchorVisibility4()
            },
            endDrag: function(ist) {
                var originalState = ist.originalStates.get(this);
                if (originalState == null) {
                    return
                }
                var oldBounds = originalState.bounds;
                if (this.obstacle) {
                    this.parent.routeLinksAt([oldBounds, this.bounds])
                }
                if (this.container) {
                    this.container.onChildModified(this, ist.adjustmentHandle.index)
                }
            },
            allowDrag: function(ist) {
                if (this.parent) {
                    return this.parent.onItemDragging(this, ist.currentPoint)
                }
                return true
            },
            onDragOver: function(item) {
                return false
            },
            onDragOut: function(item) {},
            saveLocationState: function() {
                return {
                    bounds: this.bounds,
                    rotationAngle: this.rotationAngle
                }
            },
            restoreLocationState: function(ist) {
                var state = ist.originalStates.get(this);
                if (state != null) {
                    this.setBounds(state.bounds)
                }
            },
            updateLinks: function() {
                var links = this.getAllLinks();
                for (var i = 0, l = links.length; i < l; i++) {
                    var link = links[i];
                    link.updatePosFromOrgAndDest()
                }
            },
            setBounds: function(bounds, updateDependencies) {
                if (updateDependencies) {
                    this.setBoundsWithRules(bounds)
                } else {
                    this.setBoundsImpl(bounds)
                }
            },
            setBoundsWithRules: function(bounds, rules) {
                var mediator = new mdiag.DiagramMediator(this);
                if (rules) {
                    mediator.rules = rules
                }
                this.setBoundsImpl(bounds);
                mediator.updateDependencies()
            },
            setBoundsWithRules2: function(bounds, updateLinks, updateChildren) {
                if (updateLinks && updateChildren) {
                    this.setBounds(bounds, true)
                } else {
                    if (updateLinks) {
                        this.setBoundsWithRules(bounds, mdiag.DiagramMediator.LinkRules)
                    } else {
                        if (updateChildren) {
                            this.setBoundsWithRules(bounds, mdiag.DiagramMediator.GroupRules)
                        } else {
                            this.setBounds(bounds, false)
                        }
                    }
                }
            },
            setBoundsImpl: function(bounds) {
                var oldRect = this.bounds;
                this.bounds = bounds;
                this.updateAnchorPositions2();
                this.updateManipulators();
                this.invalidate();
                this.onUpdateBounds()
            },
            getBounds: function() {
                return this.bounds
            },
            onUpdateBounds: function() {
                if (this.parent && this.parent.invalidateLabelLayout) {
                    this.parent.invalidateLabelLayout()
                }
            },
            setCenterAndSize: function(coords, dx, dy, updateLinks, updateChildren) {
                var w = coords.width;
                var h = coords.height;
                var rect = new Rect(coords.x - w / 2 + dx, coords.y - h / 2 + dy, w, h);
                this.setBoundsWithRules2(rect, updateLinks, updateChildren)
            },
            move: function(dx, dy, updateLinks, updateChildren) {
                var w = this.bounds.width;
                var h = this.bounds.height;
                var rect = new Rect(dx, dy, w, h);
                this.setBoundsWithRules2(rect, updateLinks, updateChildren)
            },
            updateRect: function(original, current, ist) {
                var point = ist.currentPoint.clone();
                var start = ist.startPoint.clone();
                if (ist.adjustmentHandle.index === 8) {
                    return this.updateRectMove(original, point, ist)
                }
                if (ist.action == mdiag.Action.Modify) {
                    var handledItem = ist.adjustmentHandle.item;
                    if (handledItem.rotationAngle) {
                        var originalState = ist.originalStates;
                        if (originalState != null) {
                            var savedBounds = originalState.get(handledItem).bounds;
                            point = mdiag.Utils.rotatePointAt(point, savedBounds.center(), -handledItem.rotationAngle);
                            start = mdiag.Utils.rotatePointAt(start, savedBounds.center(), -handledItem.rotationAngle)
                        }
                    }
                    var delta = mdiag.Utils.subtract(point, start);
                    var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                    var originalHandles = mdiag.HandleUtils.getHandlePositions(original, mm);
                    point = originalHandles[ist.adjustmentHandle.index];
                    point.addVector(delta)
                }
                if (this.parent.alignToGrid && !this.rotationAngle) {
                    point = this.parent.alignResize(this, point, ist.adjustmentHandle)
                }
                var rc = original;
                var pivot = rc.center();
                switch (ist.adjustmentHandle.index) {
                    case 0:
                        rc = this.makeRect(point.x, point.y, rc.right(), rc.bottom());
                        break;
                    case 1:
                        rc = this.makeRect(rc.x, point.y, point.x, rc.bottom());
                        break;
                    case 2:
                        rc = this.makeRect(rc.x, rc.y, point.x, point.y);
                        break;
                    case 3:
                        rc = this.makeRect(point.x, rc.y, rc.right(), point.y);
                        break;
                    case 4:
                        rc = this.makeRect(rc.x, point.y, rc.right(), rc.bottom());
                        break;
                    case 5:
                        rc = this.makeRect(rc.x, rc.y, point.x, rc.bottom());
                        break;
                    case 6:
                        rc = this.makeRect(rc.x, rc.y, rc.right(), point.y);
                        break;
                    case 7:
                        rc = this.makeRect(point.x, rc.y, rc.right(), rc.bottom());
                        break
                }
                if (rc.width === 0) {
                    rc.width = this.parent.alignToGrid ? this.parent.gridSizeX : GraphicsUnit.getPixel(this.parent.measureUnit)
                }
                if (rc.height === 0) {
                    rc.height = this.parent.alignToGrid ? this.parent.gridSizeY : GraphicsUnit.getPixel(this.parent.measureUnit)
                }
                if (this.rotationAngle !== 0) {
                    var pt1 = new Point(rc.x, rc.y);
                    var pt2 = new Point(rc.right(), rc.bottom());
                    pt1 = mdiag.Utils.rotatePointAt(pt1, pivot, this.rotationAngle);
                    pt2 = mdiag.Utils.rotatePointAt(pt2, pivot, this.rotationAngle);
                    pivot = new Point((pt1.x + pt2.x) / 2, (pt1.y + pt2.y) / 2);
                    pt1 = mdiag.Utils.rotatePointAt(pt1, pivot, -this.rotationAngle);
                    pt2 = mdiag.Utils.rotatePointAt(pt2, pivot, -this.rotationAngle);
                    rc = Rect.fromPoints(pt1, pt2)
                }
                return rc
            },
            updateRectMove: function(rect, point, ist) {
                if (this.parent.alignToGrid) {
                    var originalState = ist.originalStates;
                    if (originalState == null) {
                        return rect
                    }
                    var savedBounds = originalState.get(this).bounds;
                    var newBounds = mdiag.Utils.offset(savedBounds, mdiag.Utils.subtract(point, ist.startPoint));
                    var rotationDiff = new Point(0, 0);
                    if (this.rotationAngle !== 0) {
                        var newRotatedBounds = this.getRotatedBounds1(newBounds, mdiag.Utils.getCenter(newBounds), this.rotationAngle);
                        rotationDiff = mdiag.Utils.subtract(newRotatedBounds.topLeft(), newBounds.topLeft());
                        newBounds = newRotatedBounds
                    }
                    var ptLeftTop = this.parent.alignMove(this, newBounds);
                    ptLeftTop.x -= rotationDiff.x;
                    ptLeftTop.y -= rotationDiff.y;
                    var topLeft = ptLeftTop
                } else {
                    var delta = mdiag.Utils.subtract(point, ist.startPoint);
                    var topLeft = rect.topLeft().addVector(delta)
                }
                var accept = this.checkKeepInsideParent();
                var newRect = new Rect(topLeft.x, topLeft.y, rect.width, rect.height);
                return (accept) ? newRect : this.bounds
            },
            checkKeepInsideParent: function() {
                return true
            },
            getHandlePosition: function(handle, rect) {
                if (rect == null) {
                    rect = this.bounds
                }
                var handlePosition = this.nonRotatedHandlePosition(handle, rect);
                if (this.rotationAngle !== 0) {
                    handlePosition = mdiag.Utils.rotatePointAt(handlePosition, rect.center(), this.rotationAngle)
                }
                return handlePosition
            },
            handleAtPoint: function(point) {
                if (!this.parent) {
                    return null
                }
                if (this.handlesStyle == mdiag.HandlesStyle.Custom) {
                    var handleIndex = this.parent.raiseHitTestAdjustmentHandles(this, point);
                    return handleIndex !== undefined ? {
                        item: this,
                        index: handleIndex
                    } : null
                }
                return mdiag.HandleUtils.pointInHandle(point, this)
            },
            nonRotatedHandlePosition: function(handle, rect) {
                if (rect == null) {
                    rect = this.bounds
                }
                var tl = rect.topLeft();
                var br = rect.bottomRight();
                var center = rect.center();
                switch (handle) {
                    case 0:
                        return tl;
                    case 1:
                        return new Point(br.x, tl.y);
                    case 2:
                        return br;
                    case 3:
                        return new Point(tl.x, br.y);
                    case 4:
                        return new Point(center.x, tl.y);
                    case 5:
                        return new Point(br.x, center.y);
                    case 6:
                        return new Point(center.x, br.y);
                    case 7:
                        return new Point(tl.x, center.y);
                    case 8:
                        return center;
                    case 9:
                        return new Point(center.x, tl.y - GraphicsUnit.getPixel(this.parent.measureUnit) * 6)
                }
                return center
            },
            containsPoint: function(point) {
                return this.bounds.containsPoint(point)
            },
            getCenter: function() {
                return new Point((this.bounds.x + (this.bounds.x + this.bounds.width)) / 2, (this.bounds.y + (this.bounds.y + this.bounds.height)) / 2)
            },
            getRotatedBounds: function() {
                return this.getRotatedBounds1(this.bounds)
            },
            getRotatedBounds1: function(rect) {
                var p = [];
                p.push(rect.topLeft());
                p.push(rect.topRight());
                p.push(rect.bottomRight());
                p.push(rect.bottomLeft());
                mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(rect), this.rotationAngle);
                var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                return Rect.fromLTRB(minX, minY, maxX, maxY)
            },
            getIntersection: function(point1, point2) {
                if (point1.equals(point2)) {
                    return point1.clone()
                }
                var center = this.getCenter();
                if (this.bounds.width !== 0 && this.bounds.height !== 0) {
                    if (this.bounds.containsPoint(point1) && this.bounds.containsPoint(point2)) {
                        return center
                    }
                    mdiag.Utils.getPolygonIntersection(this.getOutline(), point1, point2, center)
                }
                return center
            },
            getTopIntr: function(xfactor) {
                var rotatedBounds = this.getRotatedBounds();
                var center = new Point(rotatedBounds.left(), (rotatedBounds.top() + rotatedBounds.bottom()) / 2);
                center.x += xfactor * rotatedBounds.width;
                var upper = new Point(center.x, center.y - 3 * Math.abs(this.bounds.height));
                var intr = this.getIntersection(upper, center);
                if (!rotatedBounds.contains(intr)) {
                    intr = new Point(rotatedBounds.left() + rotatedBounds.width * xfactor, rotatedBounds.top())
                }
                return intr
            },
            intersects: function(rect) {
                var r = this.getRotatedBounds();
                return r.intersectsWith(rect)
            },
            makeRect: function(x1, y1, x2, y2) {
                return new Rect.fromLTRB(x1, y1, x2, y2)
            },
            considerBounds: function() {
                return true
            },
            sortHandles: function(a, b) {
                return a.d - b.d
            },
            getAnchor: function(point, link, incoming) {
                var pointDetails = this.getNearestAnchor(point, link, incoming);
                if (pointDetails.index === -1) {
                    return null
                }
                return pointDetails
            },
            getAnchorFromIndex: function(index, incoming) {
                if (this.anchorPattern == null) {
                    return
                }
                var ancPoints = this.anchorPattern.getPoints();
                if (index < 0 || index >= ancPoints.length) {
                    return
                }
                var apt = ancPoints[index];
                var pt = MindFusion.Diagramming.Utils.rectPtFromPercent(new Point(apt.x, apt.y), this.bounds);
                var positions = [pt];
                if (this.rotationAngle !== 0) {
                    var transform = this.rotateRect(this.bounds);
                    transform.transformPoints(positions)
                }
                return {
                    index: index,
                    point: positions[0],
                    location: mdiag.Utils.getRectPtPercent(positions[0], this.bounds)
                }
            },
            getNearestAnchor: function(point, link, incoming) {
                var nearestPt = this.getNearestBorderPoint(point);
                if (this.anchorPattern == null) {
                    return {
                        index: 0,
                        point: nearestPt,
                        location: nearestPt
                    }
                }
                var points = [];
                var positions = [];
                var indices = [];
                var ancPoints = this.anchorPattern.getPoints();
                for (var i = 0; i < ancPoints.length; i++) {
                    var apt = ancPoints[i];
                    if (incoming && !apt.getAllowIncoming()) {
                        continue
                    }
                    if (!incoming && !apt.getAllowOutgoing()) {
                        continue
                    }
                    var pt = MindFusion.Diagramming.Utils.rectPtFromPercent(new Point(apt.x, apt.y), this.bounds);
                    positions.push(pt);
                    indices.push(i)
                }
                if (this.rotationAngle !== 0) {
                    var transform = this.rotateRect(this.bounds);
                    transform.transformPoints(positions)
                }
                for (var i = 0; i < positions.length; i++) {
                    var pp = positions[i];
                    var index = indices[i];
                    points.push({
                        p: pp,
                        d: point.distance(pp),
                        i: index
                    })
                }
                points.sort(this.sortHandles);
                if (points.length > 0) {
                    return {
                        index: points[0].i,
                        point: points[0].p,
                        location: mdiag.Utils.getRectPtPercent(points[0].p, this.bounds)
                    }
                } else {
                    return {
                        index: 0,
                        point: nearestPt,
                        location: nearestPt
                    }
                }
            },
            removeCanvasElements: function() {
                this.removeAnchorPointVisuals(this.anchorPointVisuals);
                mflayer.callBaseMethod(DiagramNode, this, "removeCanvasElements", [])
            },
            getHandlePositions: function() {
                var bounds = this.bounds;
                var tl = bounds.topLeft();
                var br = bounds.bottomRight();
                var center = bounds.center();
                var positions = [];
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeTopLeft) !== 0) {
                    positions.push(tl)
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeTopRight) !== 0) {
                    positions.push(bounds.topRight())
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeBottomRight) !== 0) {
                    positions.push(br)
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeBottomLeft) !== 0) {
                    positions.push(bounds.bottomLeft())
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeTopCenter) !== 0) {
                    positions.push(new Point(center.x, tl.y))
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeMiddleRight) !== 0) {
                    positions.push(new Point(br.x, center.y))
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeBottomCenter) !== 0) {
                    positions.push(new Point(center.x, br.y))
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.ResizeMiddleLeft) !== 0) {
                    positions.push(new Point(tl.x, center.y))
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.Move) !== 0) {
                    positions.push(center)
                }
                if ((this.enabledHandles & mdiag.AdjustmentHandles.Rotate) !== 0) {
                    positions.push(new Point(center.x, tl.y - GraphicsUnit.getMillimeter(this.parent.measureUnit) * 6))
                }
                if (this.rotationAngle !== 0) {
                    var transform = this.rotateRect(this.bounds);
                    transform.transformPoints(positions)
                }
                return positions
            },
            rotateRect: function(rect) {
                var matrix = new MindFusion.Drawing.Matrix();
                matrix.rotateAt(this.rotationAngle, rect.center().x, rect.center().y);
                return matrix
            },
            removeRotation: function(point) {
                if (this.rotationAngle != 0) {
                    var pivot = this.getBounds().center();
                    return mdiag.Utils.rotatePointAt(point, pivot, -this.rotationAngle)
                }
                return point
            },
            drawHandles: function(context) {
                context.save();
                var bounds = this.bounds;
                context.translate(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2);
                context.rotate(mdiag.Utils.radians(this.rotationAngle));
                context.translate(-bounds.x - bounds.width / 2, -bounds.y - bounds.height / 2);
                if (this.handlesStyle == mdiag.HandlesStyle.Custom) {
                    this.parent.raiseDrawAdjustmentHandles(this, context)
                } else {
                    mdiag.HandleUtils.drawAdjustmentHandles(context, this)
                }
                context.restore()
            },
            setEnabledHandles: function(value) {
                if (this.enabledHandles != value) {
                    this.enabledHandles = value;
                    this.invalidate()
                }
            },
            getEnabledHandles: function() {
                return this.enabledHandles
            },
            setHandlesStyle: function(value) {
                if (this.handlesStyle != value) {
                    this.handlesStyle = value;
                    this.invalidate()
                }
            },
            getHandlesStyle: function() {
                return this.handlesStyle
            },
            setObstacle: function(value) {
                if (this.obstacle !== value) {
                    this.obstacle = value;
                    this.setDiagramDirty()
                }
            },
            getObstacle: function() {
                return this.obstacle
            },
            setExpandable: function(value) {
                if (this.expandable != value) {
                    this.expandable = value;
                    if (value) {
                        this.expandButton = new mdiag.ExpandButton(this);
                        this.addManipulator(this.expandButton)
                    } else {
                        this.removeManipulator(this.expandButton);
                        delete this.expandButton
                    }
                }
            },
            getExpandable: function() {
                return this.expandable
            },
            setExpanded: function(value) {
                if (this.expanded != value) {
                    if (value) {
                        this.expand()
                    } else {
                        this.collapse()
                    }
                }
            },
            getExpanded: function() {
                return this.expanded
            },
            setShowDeleteButton: function(value) {
                if (this.showDeleteButton != value) {
                    this.showDeleteButton = value;
                    if (value) {
                        this.deleteButton = new mdiag.DeleteButton(this);
                        this.addManipulator(this.deleteButton)
                    } else {
                        this.removeManipulator(this.deleteButton);
                        delete this.deleteButton
                    }
                }
            },
            getShowDeleteButton: function() {
                return this.showDeleteButton
            },
            addManipulator: function(manipulator) {
                if (!this.manipulators) {
                    this.manipulators = new ArrayList()
                }
                this.manipulators.push(manipulator);
                this.graphicsContainer.content.push(manipulator);
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            removeManipulator: function(manipulator) {
                if (!this.manipulators) {
                    return
                }
                this.manipulators.remove(manipulator);
                ArrayList.remove(this.graphicsContainer.content, manipulator);
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            updateManipulators: function() {
                if (!this.manipulators) {
                    return
                }
                this.manipulators.forEach(function(mnp) {
                    mnp.updateLocation()
                })
            },
            hitTestManipulators: function(mousePosition) {
                if (!this.manipulators) {
                    return null
                }
                for (var i = 0; i < this.manipulators.length; i++) {
                    var mnp = this.manipulators[i];
                    if (mnp.hitTest(mousePosition)) {
                        return mnp
                    }
                }
                return null
            },
            addManipulatorVisuals: function(content) {
                if (this.manipulators) {
                    this.manipulators.forEach(function(item) {
                        content.push(item)
                    })
                }
            },
            collapse: function(collapsedSet) {
                if (collapsedSet) {
                    if (collapsedSet.contains(this)) {
                        return
                    }
                    collapsedSet.add(this);
                    this.setVisible(false);
                    if (this.selected && this.parent) {
                        this.parent.selection.removeItem(this)
                    }
                    if (!this.expanded) {
                        return
                    }
                } else {
                    collapsedSet = this.collapsedSet = new MindFusion.Collections.Set();
                    collapsedSet.add(this);
                    this.expanded = false;
                    if (this.expandButton) {
                        this.expandButton.updateContent()
                    }
                    if (this.parent) {
                        this.parent.invalidate()
                    }
                }
                var links = [];
                if (this.parent.expandOnIncoming) {
                    this.getAllIncomingLinks(links)
                } else {
                    this.getAllOutgoingLinks(links)
                }
                ArrayList.forEach(links, function(link) {
                    link.collapse(collapsedSet)
                })
            },
            expand: function() {
                this.expanded = true;
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                if (this.parent) {
                    this.parent.invalidate()
                }
                if (this.collapsedSet) {
                    this.collapsedSet.forEach(function(item) {
                        item.setVisible(true)
                    });
                    delete this.collapsedSet
                } else {
                    var links = [];
                    if (parent.expandOnIncoming) {
                        this.getAllIncomingLinks(links);
                        ArrayList.forEach(links, function(link) {
                            link.setVisible(true);
                            var node = link.getOrigin();
                            node.setVisible(true);
                            if (node.expandButton) {
                                node.expanded = false;
                                node.expandButton.updateContent()
                            }
                        })
                    } else {
                        this.getAllOutgoingLinks(links);
                        ArrayList.forEach(links, function(link) {
                            link.setVisible(true);
                            var node = link.getDestination();
                            node.setVisible(true);
                            if (node.expandButton) {
                                node.expanded = false;
                                node.expandButton.updateContent()
                            }
                        })
                    }
                }
            },
            setProperty: function(property, oldValue, newValue) {
                switch (property) {
                    default: mflayer.callBaseMethod(DiagramNode, this, "setProperty", [property, oldValue, newValue]);
                    break
                }
            },
            getOutline: function() {
                return this.bounds.getCornerPoints()
            },
            getNearestBorderPoint: function(point) {
                var outline = this.getOutline();
                outline.push(outline[0].clone());
                var segment = {
                    value: 0
                };
                mdiag.Utils.distToPolyline(point, outline, outline.length, segment);
                return mdiag.Utils.getClosestSegmentPoint(point, outline[segment.value], outline[segment.value + 1])
            },
            getAnchorPattern: function() {
                return this.anchorPattern
            },
            setAnchorPattern: function(value) {
                if (this.anchorPattern != null) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals)
                }
                this.anchorPattern = value;
                this.updateAnchorVisibility4();
                this.invalidate()
            },
            addAnchorPointVisuals: function(anchorPattern, pointVisuals, updatePositions) {
                if (anchorPattern == null) {
                    return
                }
                this.isAnchorPatternVisible = true;
                for (var i = 0; i < anchorPattern.getPoints().length; i++) {
                    var p = anchorPattern.getPoints()[i];
                    var v = this.createAnchorPointVisual(p);
                    if (!v) {
                        continue
                    }
                    this.parent.addElement(v);
                    pointVisuals.push(v)
                }
            },
            removeAnchorPointVisuals: function(anchorPoints) {
                if (anchorPoints == null) {
                    return
                }
                this.isAnchorPatternVisible = false;
                var v = anchorPoints.pop();
                while (v) {
                    this.parent.removeElement(v);
                    v = anchorPoints.pop()
                }
            },
            createAnchorPointVisual: function(point) {
                var bounds = this.bounds;
                var width = 1;
                if (point) {
                    width = point.getSize()
                }
                var pt = MindFusion.Diagramming.Utils.rectPtFromPercent(new Point(point.getX(), point.getY()), bounds);
                var offset;
                if (this.rotationAngle !== 0) {
                    var newPoint = mdiag.Utils.rotatePointAt(pt, bounds.center(), this.rotationAngle);
                    offset = MindFusion.Diagramming.Utils.newRect(newPoint, width)
                } else {
                    offset = MindFusion.Diagramming.Utils.newRect(pt, width)
                }
                var l = offset.x;
                var t = offset.y;
                var size = point.getSize();
                var radius = size / 2;
                var stringFormat = MindFusion.Diagramming.Utils.stringFormat;
                var path;
                switch (point.getMarkStyle()) {
                    case MindFusion.Diagramming.MarkStyle.Cross:
                        var strPath = "M{0},{1} L{2},{1} M{3},{4} L{3},{5}";
                        strPath = stringFormat(strPath, l, (t + radius), (l + size), (l + radius), t, (t + size));
                        path = new MindFusion.Drawing.Path(strPath);
                        break;
                    case MindFusion.Diagramming.MarkStyle.X:
                        var strPath = "M{0},{1} L{2},{3} M{0},{3} L{2},{1}";
                        strPath = stringFormat(strPath, l, t, l + size, t + size);
                        path = new MindFusion.Drawing.Path(strPath);
                        break;
                    case MindFusion.Diagramming.MarkStyle.Circle:
                        path = new MindFusion.Drawing.Arc(l + radius, t + radius, radius, 0, 360, 0);
                        break;
                    case MindFusion.Diagramming.MarkStyle.Rectangle:
                        path = new Rect(l, t, size, size);
                        break;
                    case MindFusion.Diagramming.MarkStyle.None:
                        return
                }
                path.pen = point.getColor();
                path.brush = "transparent";
                return path
            },
            updateAnchorVisibility4: function() {
                if (this.parent && this.parent.getAutoAnchorsNode) {
                    this.updateAnchorVisibility(this.parent.getAutoAnchorsNode())
                }
            },
            updateAnchorVisibility2: function(isVisible) {
                this.updateAnchorVisibility3(this.anchorPattern, this.anchorPointVisuals, isVisible)
            },
            updateAnchorVisibility3: function(pat, visuals, isVisible) {
                if (this.anchorPattern == null) {
                    return
                }
                var points = pat.getPoints();
                if (this.isAnchorPatternVisible && !isVisible) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals)
                }
                if (!this.isAnchorPatternVisible && isVisible) {
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
                if (this.isAnchorPatternVisible && isVisible) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals);
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
            },
            updateAnchorVisibility: function(newAutoAnchorsNode) {
                this.updateAnchorVisibility2(this.calcAnchorVisibility(newAutoAnchorsNode))
            },
            calcAnchorVisibility: function(newAutoAnchorsNode) {
                if (this.parent == null || !this.getVisible()) {
                    return false
                }
                var showAnchors = this.parent.getShowAnchors();
                var visible = newAutoAnchorsNode == this || showAnchors == MindFusion.Diagramming.ShowAnchors.Always || this.getSelected() && showAnchors == MindFusion.Diagramming.ShowAnchors.Selected;
                return visible
            },
            updateAnchorPositions2: function() {
                if (this.anchorPattern == null) {
                    return
                }
                this.removeAnchorPointVisuals(this.anchorPointVisuals);
                if (!this.parent || !this.parent.getAutoAnchorsNode) {
                    return
                }
                if (this.calcAnchorVisibility(this.parent.getAutoAnchorsNode())) {
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
            },
            getAnchorPointPos: function(point) {
                var width = 1;
                if (pointVisual) {
                    width = pointVisual.getBounds().width
                }
                return MindFusion.Diagramming.Utils.rectPtFromPercent(new Point(apt.x, apt.y), this.getBounds())
            },
            getAnchorRect: function() {
                return this.bounds.getSizeRect()
            },
            attachTo: function(node) {
                node.attach(this)
            },
            detach: function() {
                if (this.masterNode) {
                    this.masterNode.detachSub(this);
                    this.setDiagramDirty()
                }
            },
            attach: function(subordinate) {
                if (!this.attachedNodes) {
                    this.attachedNodes = new ArrayList()
                }
                this.attachedNodes.push(subordinate);
                subordinate.attachment = {
                    offsetX: subordinate.bounds.x - this.bounds.x,
                    offsetY: subordinate.bounds.y - this.bounds.y
                };
                subordinate.masterNode = this;
                this.setDiagramDirty()
            },
            detachSub: function(subordinate) {
                if (!this.attachedNodes) {
                    return
                }
                if (subordinate.masterNode == this) {
                    this.attachedNodes.remove(subordinate);
                    delete subordinate.attachment;
                    delete subordinate.masterNode
                }
            },
            getMasterNode: function() {
                return this.masterNode
            },
            getAttachedNodes: function() {
                if (!this.attachedNodes) {
                    return []
                }
                var nodes = [];
                this.attachedNodes.forEach(function(node) {
                    nodes.push(node)
                });
                return nodes
            },
            getTopLevel: function() {
                if (!MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    return true
                }
                var master = this.getAbsoluteMaster();
                if (master) {
                    return mflayer.callBaseMethod(DiagramNode, master, "getTopLevel", [])
                }
                return mflayer.callBaseMethod(DiagramNode, this, "getTopLevel", [])
            },
            getAbsoluteMaster: function() {
                var curentSearch = searchId++;
                var master = this.masterNode;
                while (master != null && master.masterNode != null) {
                    if (master == this) {
                        break
                    }
                    if (master.__currentSearch == curentSearch) {
                        break
                    }
                    master.__currentSearch = curentSearch;
                    master = master.masterNode
                }
                return master
            },
            getEditRect: function(point) {
                return this.getRotatedBounds()
            },
            createEditArgs: function(oldText, newText) {
                return new mdiag.NodeEventArgs({
                    node: this,
                    oldText: oldText,
                    newText: newText
                })
            },
            onDropOver: function(item) {
                return false
            },
            onHide: function() {
                this.removeAnchorPointVisuals(this.anchorPointVisuals)
            },
            onShow: function() {
                if (this.anchorPattern) {
                    this.updateAnchorVisibility4()
                }
            },
            getLayoutMaster: function(includeGroups) {
                if (this.container) {
                    return this.container
                }
                if (includeGroups && this.masterNode) {
                    return this.masterNode
                }
                return null
            },
            resolveInheritedStyle: function(check, theme) {
                var nodeStyle = theme.styles["std:DiagramNode"];
                if (nodeStyle) {
                    if (check.apply(nodeStyle)) {
                        return nodeStyle
                    }
                }
                return mflayer.callBaseMethod(DiagramNode, this, "resolveInheritedStyle", [check, theme])
            },
            getEffects: function() {
                if (this.nodeEffects === undefined) {
                    this.nodeEffects = []
                }
                return this.nodeEffects
            },
            getEffectiveEffects: function() {
                if (this.nodeEffects && this.nodeEffects.length) {
                    return this.nodeEffects
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasNodeEffects);
                if (style) {
                    return style.getNodeEffects()
                }
                return []
            },
            applyEffects: function(context, params) {
                if (!this.parent) {
                    return
                }
                params.isEllipse = this.shape && this.shape.isElliptic && this.shape.isElliptic();
                params.unitsPerPixel = GraphicsUnit.getPixel(this.parent.measureUnit);
                var nodeEffects = this.getEffectiveEffects();
                var discardDiagramEffects = nodeEffects.length > 0 && nodeEffects[0] == null;
                if (!discardDiagramEffects) {
                    if (this.parent.getEffectiveNodeEffects) {
                        var effects = this.parent.getEffectiveNodeEffects();
                        for (var i = 0, l = effects.length; i < l; i++) {
                            if (effects[i] != null) {
                                effects[i].apply(this, context, params)
                            }
                        }
                    }
                }
                for (var i = 0, l = nodeEffects.length; i < l; i++) {
                    if (nodeEffects[i] != null) {
                        nodeEffects[i].apply(this, context, params)
                    }
                }
            },
            updateAnimation: function(animation, animationDelta) {
                var b = this.bounds;
                var y = animation.getFromValue() + (animation.getToValue() - animation.getFromValue()) * animationDelta;
                this.setBounds(new Rect(b.x, y, b.width, b.height), true)
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(DiagramNode, this, "saveState", []);
                state.bounds = this.bounds.clone();
                state.anchorPattern = this.anchorPattern;
                state.rotationAngle = this.rotationAngle;
                state.enabledHandles = this.enabledHandles;
                state.handlesStyle = this.handlesStyle;
                state.expanded = this.expanded;
                state.expandable = this.expandable;
                state.allowIncomingLinks = this.allowIncomingLinks;
                state.allowOutgoingLinks = this.allowOutgoingLinks;
                state.obstacle = this.obstacle;
                state.master = this.masterNode;
                state.container = this.container;
                state.nodeEffects = this.nodeEffects;
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(DiagramNode, this, "restoreState", [state]);
                this.setBounds(state.bounds);
                this.setAnchorPattern(state.anchorPattern);
                this.setRotationAngle(state.rotationAngle);
                this.setEnabledHandles(state.enabledHandles);
                this.handlesStyle = state.handlesStyle;
                this.setExpanded(state.expanded);
                this.setExpandable(state.expandable);
                this.setAllowIncomingLinks(state.allowIncomingLinks);
                this.setAllowOutgoingLinks(state.allowOutgoingLinks);
                this.setObstacle(state.obstacle);
                this.masterId = state.master;
                this.containerId = state.container;
                this.nodeEffects = state.nodeEffects
            }
        };
        MindFusion.registerClass(DiagramNode, "MindFusion.Diagramming.DiagramNode", mdiag.DiagramItem);
        var searchId = 0
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Container = MindFusion.Drawing.Container;
        var Size = MindFusion.Drawing.Size;
        var Rect = MindFusion.Drawing.Rect;
        var LayoutAlignment = MindFusion.Drawing.LayoutAlignment;
        var Thickness = MindFusion.Drawing.Thickness;
        var Visibility = MindFusion.Drawing.Visibility;
        var Panel = mdiag.Panel = function() {
            mflayer.initializeBase(Panel, this);
            this.content = this.children = []
        };
        Panel.prototype = {
            getComponents: function() {
                return this.children
            },
            measure: function(maxWidth, maxHeight) {
                this.measureMax = maxWidth;
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    child.parent = this
                }
            },
            measureChild: function(child, maxWidth, maxHeight) {
                if (child.measure) {
                    child.measure(maxWidth, maxHeight);
                    return new Size(this.desiredWidthMargins(child), this.desiredHeightMargins(child))
                }
                return new Size(null, null)
            },
            arrangeChild: function(child, x, y, w, h) {
                if (child.arrange) {
                    child.arrange(x, y, w, h)
                } else {
                    if (child.setBounds) {
                        child.setBounds(new Rect(x, y, w, h))
                    }
                }
            },
            childMeasuredWidth: function(child) {
                return child.effectiveMeasuredWidth ? child.effectiveMeasuredWidth() : null
            },
            childMeasuredHeight: function(child) {
                return child.effectiveMeasuredHeight ? child.effectiveMeasuredHeight() : null
            },
            desiredWidthMargins: function(child) {
                var w = this.childMeasuredWidth(child);
                var mw = 0;
                if (child.margin) {
                    mw = child.margin.width()
                }
                return w == null ? null : w + mw
            },
            desiredHeightMargins: function(child) {
                var h = this.childMeasuredHeight(child);
                var mh = 0;
                if (child.margin) {
                    mh = child.margin.height()
                }
                return h == null ? null : h + mh
            },
            canWrap: function(child) {
                return child.constructor == MindFusion.Drawing.Text
            },
            arrangeInRect: function(child, x, y, w, h) {
                var childMargin = child.margin ? child.margin : new Thickness(0, 0, 0, 0);
                var horizontalAlignment = child.horizontalAlignment || LayoutAlignment.Near;
                var verticalAlignment = child.verticalAlignment || LayoutAlignment.Near;
                var width = w - childMargin.width();
                var mw = this.childMeasuredWidth(child);
                var willWrap = mw != null && mw > width && this.canWrap(child);
                if (mw != null && mw < width && horizontalAlignment != LayoutAlignment.Stretch) {
                    width = mw
                }
                var height = h - childMargin.height();
                var mh = this.childMeasuredHeight(child);
                if (mh != null && mh < height && !willWrap && verticalAlignment != LayoutAlignment.Stretch) {
                    height = mh
                }
                var left = x;
                var top = y;
                switch (horizontalAlignment) {
                    case LayoutAlignment.Near:
                        left += childMargin.left;
                        break;
                    case LayoutAlignment.Center:
                        left += w / 2 - width / 2;
                        break;
                    case LayoutAlignment.Far:
                        left += w - width - childMargin.right;
                        break;
                    case LayoutAlignment.Stretch:
                        left += childMargin.left;
                        break
                }
                switch (verticalAlignment) {
                    case LayoutAlignment.Near:
                        top += childMargin.top;
                        break;
                    case LayoutAlignment.Center:
                        top += h / 2 - height / 2;
                        break;
                    case LayoutAlignment.Far:
                        top += h - height - childMargin.bottom;
                        break;
                    case LayoutAlignment.Stretch:
                        top += childMargin.top;
                        break
                }
                this.arrangeChild(child, left, top, width, height)
            },
            hitTest: function(point) {
                var result = mflayer.callBaseMethod(Panel, this, "hitTest", [point]);
                if (result) {
                    var localPoint = point.newWithOffset(-this.x, -this.y);
                    for (var c = this.children.length - 1; c >= 0; c--) {
                        var child = this.children[c];
                        var visibility = child.visibility;
                        if (typeof visibility == "undefined") {
                            visibility = Visibility.Visible
                        }
                        if (visibility == Visibility.Visible) {
                            if (child.hitTest) {
                                var childResult = child.hitTest(localPoint);
                                if (childResult) {
                                    return childResult
                                }
                            }
                            if (child.getBounds) {
                                if (child.getBounds().containsPoint(localPoint)) {
                                    return child
                                }
                            }
                        }
                    }
                }
                return result
            }
        };
        MindFusion.registerClass(Panel, "MindFusion.Diagramming.Panel", Container)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var LayoutAlignment = MindFusion.Drawing.LayoutAlignment;
        var Thickness = MindFusion.Drawing.Thickness;
        var ComponentLoader = mdiag.ComponentLoader = function(imageLoadHandler) {
            this.nameMap = {};
            this.propertyMap = {};
            this.imageLoadHandler = imageLoadHandler
        };
        ComponentLoader.prototype = {
            processedProps: ["component", "name", "children", "rowDefinitions", "columnDefinitions", "autoProperty", "location"],
            componentFromJson: function(jsonTemplate) {
                var ctor = jsonTemplate.component;
                var component = this.createComponent(ctor);
                var name = jsonTemplate.name;
                if (name) {
                    this.nameMap[name] = component
                }
                if (ctor == "Image" && jsonTemplate.location) {
                    var imageLoadHandler = this.imageLoadHandler;
                    if (imageLoadHandler) {
                        mflayer.addHandlers(component.image, {
                            load: function() {
                                component.loaded = true;
                                imageLoadHandler()
                            }
                        })
                    } else {
                        component.loaded = true
                    }
                    component.image.src = jsonTemplate.location
                }
                var autoProperty = jsonTemplate.autoProperty;
                if (autoProperty && name) {
                    var getter = "get" + name;
                    var setter = "set" + name;
                    this.propertyMap[getter] = function() {
                        return this.namedComponents[name].getDefaultProperty()
                    };
                    this.propertyMap[setter] = function(value) {
                        this.namedComponents[name].setDefaultProperty(value);
                        this.invalidate()
                    }
                }
                for (var prop in jsonTemplate) {
                    if (this.processedProps.indexOf(prop) > -1) {
                        continue
                    }
                    if (jsonTemplate.hasOwnProperty(prop)) {
                        if (prop == "orientation" && typeof jsonTemplate[prop] == "string") {
                            switch (jsonTemplate[prop]) {
                                case "Horizontal":
                                    component[prop] = mdiag.Orientation.Horizontal;
                                    break;
                                case "Vertical":
                                    component[prop] = mdiag.Orientation.Vertical;
                                    break
                            }
                        } else {
                            if (prop == "imageAlign" && typeof jsonTemplate[prop] == "string") {
                                component[prop] = MindFusion.Drawing.ImageAlign[jsonTemplate[prop]]
                            } else {
                                if (prop == "visibility" && typeof jsonTemplate[prop] == "string") {
                                    component[prop] = MindFusion.Drawing.Visibility[jsonTemplate[prop]]
                                } else {
                                    if ((prop == "horizontalAlignment" || prop == "verticalAlignment") && typeof jsonTemplate[prop] == "string") {
                                        component[prop] = MindFusion.Drawing.LayoutAlignment[jsonTemplate[prop]]
                                    } else {
                                        if ((prop == "margin" || prop == "padding") && typeof jsonTemplate[prop] == "string") {
                                            var parts = jsonTemplate[prop].split(",");
                                            if (parts.length == 1) {
                                                var uniform = parseFloat(parts[0]);
                                                component[prop] = new Thickness(uniform, uniform, uniform, uniform)
                                            } else {
                                                if (parts.length == 4) {
                                                    var l = parseFloat(parts[0]);
                                                    var t = parseFloat(parts[1]);
                                                    var r = parseFloat(parts[2]);
                                                    var b = parseFloat(parts[3]);
                                                    component[prop] = new Thickness(l, t, r, b)
                                                }
                                            }
                                        } else {
                                            if (prop == "font" && typeof jsonTemplate[prop] == "string") {
                                                var parts = jsonTemplate[prop].split(" ");
                                                var fontName = parts[0];
                                                var size = 4;
                                                var bold = false;
                                                var italic = false;
                                                for (var p = 1; p < parts.length; p++) {
                                                    if (parts[p] == "bold") {
                                                        bold = true
                                                    } else {
                                                        if (parts[p] == "italic") {
                                                            italic = true
                                                        } else {
                                                            size = parseFloat(parts[p])
                                                        }
                                                    }
                                                }
                                                component[prop] = new MindFusion.Drawing.Font(fontName, size, bold, italic)
                                            } else {
                                                component[prop] = jsonTemplate[prop]
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (jsonTemplate.rowDefinitions) {
                    var rows = [];
                    for (var r = 0; r < jsonTemplate.rowDefinitions.length; r++) {
                        var rdef = jsonTemplate.rowDefinitions[r];
                        var row = new mdiag.GridRow();
                        if (rdef == "*") {
                            row.lengthType = mdiag.LengthType.Relative
                        } else {
                            if (rdef != "Auto") {
                                row.height = parseFloat(rdef)
                            }
                        }
                        rows.push(row)
                    }
                    component.rows = rows
                }
                if (jsonTemplate.columnDefinitions) {
                    var cols = [];
                    for (var c = 0; c < jsonTemplate.columnDefinitions.length; c++) {
                        var cdef = jsonTemplate.columnDefinitions[c];
                        var col = new mdiag.GridColumn();
                        if (cdef == "*") {
                            col.lengthType = mdiag.LengthType.Relative
                        } else {
                            if (cdef != "Auto") {
                                col.width = parseFloat(cdef)
                            }
                        }
                        cols.push(col)
                    }
                    component.columns = cols
                }
                if (jsonTemplate.children) {
                    for (var ct = 0; ct < jsonTemplate.children.length; ct++) {
                        var childTemplate = jsonTemplate.children[ct];
                        var childComponent = this.componentFromJson(childTemplate);
                        component.children.push(childComponent)
                    }
                }
                this.setDefaults(component);
                return component
            },
            setDefaults: function(component) {
                if (component.constructor == MindFusion.Drawing.Text) {
                    component.fitInBounds = true;
                    component.ignoreTransform = true
                }
            },
            createComponent: function(name) {
                if (name.indexOf("Panel") !== -1) {
                    return new mdiag[name]()
                }
                if (name.indexOf(".") == -1) {
                    return new MindFusion.Drawing[name]()
                }
                return new this.ctorFromName(name)
            },
            ctorFromName: function(name) {
                var parts = name.split(".");
                var current = (window || this);
                for (var i = 0; i < parts.length; i++) {
                    current = current[parts[i]]
                }
                if (typeof current !== "function") {
                    throw new Error("Class not found.")
                }
                return current
            }
        };
        MindFusion.registerClass(ComponentLoader, "MindFusion.Diagramming.ComponentLoader")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GridColumn = mdiag.GridColumn = function() {
            this.x = 0;
            this.width = null;
            this.measuredWidth = null;
            this.lengthType = mdiag.LengthType.Auto
        };
        GridColumn.prototype = {
            setLengthType: function(value) {
                this.lengthType = value
            },
            getLengthType: function() {
                return this.lengthType
            },
            setWidth: function(value) {
                this.width = value
            },
            getWidth: function() {
                return this.width
            },
            fixedSize: function() {
                return this.width
            },
            measuredSize: function() {
                return this.width != null ? this.width : this.measuredWidth
            },
            setPos: function(pos, size) {
                this.x = pos;
                this.layoutWidth = size
            },
            relativeSize: function() {
                if (this.width != null) {
                    return false
                }
                return this.measuredWidth == null || this.lengthType == mdiag.LengthType.Relative
            }
        };
        MindFusion.registerClass(GridColumn, "MindFusion.Diagramming.GridColumn")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Visibility = MindFusion.Drawing.Visibility;
        var GridPanel = mdiag.GridPanel = function() {
            mflayer.initializeBase(GridPanel, this);
            this.rows = [new mdiag.GridRow()];
            this.columns = [new mdiag.GridColumn()]
        };
        GridPanel.prototype = {
            getRows: function() {
                return this.rows
            },
            getColumns: function() {
                return this.columns
            },
            measure: function(maxWidth, maxHeight) {
                mflayer.callBaseMethod(GridPanel, this, "measure", [maxWidth, maxHeight]);
                for (var r = 0; r < this.rows.length; r++) {
                    var row = this.rows[r];
                    row.measuredHeight = null
                }
                for (var c = 0; c < this.columns.length; c++) {
                    var col = this.columns[c];
                    col.measuredWidth = null
                }
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    var desiredSize = this.measureChild(child, maxWidth, maxHeight);
                    var gridRow = child.gridRow;
                    if (!gridRow) {
                        gridRow = 0
                    }
                    if (gridRow < this.rows.length) {
                        var row = this.rows[gridRow];
                        row.measuredHeight = this.max(row.measuredHeight, desiredSize.height)
                    }
                    var gridCol = child.gridColumn;
                    if (!gridCol) {
                        gridCol = 0
                    }
                    if (gridCol < this.columns.length) {
                        var col = this.columns[gridCol];
                        col.measuredWidth = this.max(col.measuredWidth, desiredSize.width)
                    }
                }
                this.desiredHeight = null;
                for (var r = 0; r < this.rows.length; r++) {
                    var row = this.rows[r];
                    this.desiredHeight = this.add(this.desiredHeight, row.measuredSize())
                }
                this.desiredWidth = null;
                for (var c = 0; c < this.columns.length; c++) {
                    var col = this.columns[c];
                    this.desiredWidth = this.add(this.desiredWidth, col.measuredSize())
                }
                this.desiredWidth = this.desiredHeight = null
            },
            assignCoords: function(elements, availableSize) {
                var autoSizeTotal = 0;
                var fixedSizeTotal = 0;
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var fixedSize = element.fixedSize();
                    if (fixedSize) {
                        fixedSizeTotal += fixedSize
                    } else {
                        if (!element.relativeSize()) {
                            autoSizeTotal += element.measuredSize()
                        }
                    }
                }
                var overrideAutoSize = autoSizeTotal > availableSize - fixedSizeTotal;
                var allocated = 0;
                var relativeSized = 0;
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var size = element.measuredSize();
                    if (element.fixedSize() || !element.relativeSize() && !overrideAutoSize) {
                        allocated += size
                    } else {
                        relativeSized++
                    }
                }
                var autoSize = 0;
                if (relativeSized > 0) {
                    autoSize = (availableSize - allocated) / relativeSized
                }
                if (autoSize < 0) {
                    autoSize = 0
                }
                var pos = 0;
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var ms = element.measuredSize();
                    var layoutSize = autoSize;
                    if (element.fixedSize() || !element.relativeSize() && !overrideAutoSize) {
                        layoutSize = ms
                    }
                    element.setPos(pos, layoutSize);
                    pos = this.add(pos, layoutSize)
                }
                return autoSize
            },
            arrange: function(x, y, w, h) {
                mflayer.callBaseMethod(GridPanel, this, "arrange", [x, y, w, h]);
                var autoHeight = this.assignCoords(this.rows, h);
                var autoWidth = this.assignCoords(this.columns, w);
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    var row = null;
                    var gridRow = child.gridRow;
                    if (!gridRow) {
                        gridRow = 0
                    }
                    if (gridRow < this.rows.length) {
                        row = this.rows[gridRow]
                    }
                    var col = null;
                    var gridCol = child.gridColumn;
                    if (!gridCol) {
                        gridCol = 0
                    }
                    if (gridCol < this.columns.length) {
                        col = this.columns[gridCol]
                    }
                    if (col != null && row != null) {
                        var availableHeight = row.layoutHeight;
                        var rowSpan = child.rowSpan;
                        if (!rowSpan) {
                            rowSpan = 1
                        }
                        for (var r = 1; r < rowSpan; r++) {
                            var spanRow = this.rows[gridRow + r];
                            if (!spanRow) {
                                continue
                            }
                            availableHeight += spanRow.layoutHeight
                        }
                        var availableWidth = col.layoutWidth;
                        var colSpan = child.columnSpan;
                        if (!colSpan) {
                            colSpan = 1
                        }
                        for (var l = 1; l < colSpan; l++) {
                            var spanCol = this.columns[gridCol + l];
                            if (!spanCol) {
                                continue
                            }
                            availableWidth += spanCol.layoutWidth
                        }
                        this.arrangeInRect(child, col.x, row.y, availableWidth, availableHeight)
                    }
                }
            }
        };
        MindFusion.registerClass(GridPanel, "MindFusion.Diagramming.GridPanel", mdiag.Panel)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GridRow = mdiag.GridRow = function() {
            this.y = 0;
            this.height = null;
            this.measuredHeight = null;
            this.lengthType = mdiag.LengthType.Auto
        };
        GridRow.prototype = {
            setLengthType: function(value) {
                this.lengthType = value
            },
            getLengthType: function() {
                return this.lengthType
            },
            setHeight: function(value) {
                this.height = value
            },
            getHeight: function() {
                return this.height
            },
            fixedSize: function() {
                return this.height
            },
            measuredSize: function() {
                return this.height != null ? this.height : this.measuredHeight
            },
            setPos: function(pos, size) {
                this.y = pos;
                this.layoutHeight = size
            },
            relativeSize: function() {
                if (this.height != null) {
                    return false
                }
                return this.measuredHeight == null || this.lengthType == mdiag.LengthType.Relative
            }
        };
        MindFusion.registerClass(GridRow, "MindFusion.Diagramming.GridRow")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Visibility = MindFusion.Drawing.Visibility;
        var SimplePanel = mdiag.SimplePanel = function() {
            mflayer.initializeBase(SimplePanel, this)
        };
        SimplePanel.prototype = {
            measure: function(maxWidth, maxHeight) {
                mflayer.callBaseMethod(SimplePanel, this, "measure", [maxWidth, maxHeight]);
                var width = 0;
                var height = 0;
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    var desiredSize = this.measureChild(child, maxWidth, maxHeight);
                    var w = desiredSize.width == null ? 0 : desiredSize.width;
                    var h = desiredSize.height == null ? 0 : desiredSize.height;
                    width = Math.max(w, width);
                    height = Math.max(h, height)
                }
                this.desiredWidth = width;
                this.desiredHeight = height
            },
            arrange: function(x, y, w, h) {
                mflayer.callBaseMethod(SimplePanel, this, "arrange", [x, y, w, h]);
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    this.arrangeInRect(child, 0, 0, w, h)
                }
            }
        };
        MindFusion.registerClass(SimplePanel, "MindFusion.Diagramming.SimplePanel", mdiag.Panel)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Visibility = MindFusion.Drawing.Visibility;
        var LayoutAlignment = MindFusion.Drawing.LayoutAlignment;
        var StackPanel = mdiag.StackPanel = function() {
            mflayer.initializeBase(StackPanel, this);
            this.orientation = mdiag.Orientation.Horizontal
        };
        StackPanel.prototype = {
            measure: function(maxWidth, maxHeight) {
                mflayer.callBaseMethod(StackPanel, this, "measure", [maxWidth, maxHeight]);
                var primaryMeasure = null;
                var secondaryMeasure = null;
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    var desiredSize = this.measureChild(child, maxWidth, maxHeight);
                    var cp = this.primaryMeasure(child);
                    primaryMeasure = this.add(primaryMeasure, cp);
                    var cs = this.secondaryMeasure(child);
                    secondaryMeasure = this.max(secondaryMeasure, cs)
                }
                this.setMeasures(primaryMeasure, secondaryMeasure)
            },
            arrange: function(x, y, w, h) {
                mflayer.callBaseMethod(StackPanel, this, "arrange", [x, y, w, h]);
                var allocated = 0;
                var autoSized = 0;
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    if (w < this.measureMax) {
                        this.measureChild(child, w, null)
                    }
                    var cp = this.primaryMeasure(child);
                    if (cp !== null) {
                        allocated += cp
                    } else {
                        autoSized++
                    }
                }
                var s = this.primarySize(this);
                var autoSize = 0;
                if (autoSized > 0) {
                    autoSize = (s - allocated) / autoSized
                }
                if (autoSize < 0) {
                    autoSize = 0
                }
                var posPrim = 0;
                var sizeSec = this.secondarySize(this);
                for (var c = 0; c < this.children.length; c++) {
                    var child = this.children[c];
                    if (child.visibility == Visibility.Collapsed) {
                        continue
                    }
                    var cp = this.primaryMeasure(child);
                    var sizePrim = cp !== null ? cp : autoSize;
                    this.arrangeChildOrient(child, posPrim, sizePrim, 0, sizeSec);
                    posPrim += sizePrim
                }
            },
            getOrientation: function() {
                return this.orientation
            },
            setOrientation: function(value) {
                if (this.orientation != value) {
                    this.orientation = value;
                    this.invalidateLayout()
                }
            },
            primaryMeasure: function(component) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        return this.desiredWidthMargins(component);
                    case mdiag.Orientation.Vertical:
                        return this.desiredHeightMargins(component)
                }
                return 0
            },
            secondaryMeasure: function(component) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        return this.desiredHeightMargins(component);
                    case mdiag.Orientation.Vertical:
                        return this.desiredWidthMargins(component)
                }
                return 0
            },
            primarySize: function(component) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        return component.actualWidth;
                    case mdiag.Orientation.Vertical:
                        return component.actualHeight
                }
                return 0
            },
            secondarySize: function(component) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        return component.actualHeight;
                    case mdiag.Orientation.Vertical:
                        return component.actualWidth
                }
                return 0
            },
            arrangeChildOrient: function(child, posPrim, sizePrim, posSec, sizeSec) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        this.arrangeInRect(child, posPrim, posSec, sizePrim, sizeSec);
                        break;
                    case mdiag.Orientation.Vertical:
                        this.arrangeInRect(child, posSec, posPrim, sizeSec, sizePrim);
                        break
                }
            },
            setMeasures: function(primary, secondary) {
                switch (this.orientation) {
                    case mdiag.Orientation.Horizontal:
                        this.desiredWidth = primary;
                        this.desiredHeight = secondary;
                        break;
                    case mdiag.Orientation.Vertical:
                        this.desiredHeight = primary;
                        this.desiredWidth = secondary;
                        break
                }
                if (this.horizontalAlignment == LayoutAlignment.Stretch) {
                    this.desiredWidth = null
                }
                if (this.verticalAlignment == LayoutAlignment.Stretch) {
                    this.desiredHeight = null
                }
            }
        };
        MindFusion.registerClass(StackPanel, "MindFusion.Diagramming.StackPanel", mdiag.Panel)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var SinglePointerController = mdiag.SinglePointerController = function(modifiedItem, adjustmentHandle) {
            mflayer.initializeBase(SinglePointerController, this);
            this.modifiedItem = modifiedItem;
            this.adjustmentHandle = adjustmentHandle;
            this.controlPointStart = adjustmentHandle == null ? new MindFusion.Drawing.Point(0, 0) : modifiedItem.getHandlePosition(adjustmentHandle.index);
            this.action = mdiag.Action.Modify;
            this.originalStates = new MindFusion.Collections.Dictionary();
            if (modifiedItem) {
                this.originalStates.set(modifiedItem, modifiedItem.saveLocationState())
            }
        };
        SinglePointerController.prototype = {
            start: function(position) {
                this.startPoint = position.clone();
                if (this.action == mdiag.Action.Modify && this.originalStates.getCount() > 0) {
                    var affectedItems = this.originalStates.keys();
                    var diagram = affectedItems[0].getParent();
                    diagram.startCompositeOperation();
                    diagram.onStartInteraction(affectedItems);
                    this.modifiedDiagram = diagram
                }
            },
            move: function(position) {
                this.currentPoint = position.clone()
            },
            validate: function(position) {
                return true
            },
            commit: function(position) {
                if (this.modifiedDiagram) {
                    var diagram = this.modifiedDiagram;
                    if (diagram.autoResize != mdiag.AutoResize.None) {
                        diagram.resizeToFitItem(this.modifiedItem)
                    }
                    diagram.commitCompositeOperation()
                }
            },
            cancel: function(position) {
                this.originalStates.forEach(function(item, state) {
                    item.restoreLocationState(this)
                }, this);
                if (this.modifiedDiagram) {
                    this.modifiedDiagram.cancelCompositeOperation()
                }
            },
            cancelNow: function() {
                this.cancelDrag = true
            },
            shouldCancelDrag: function() {
                return this.cancelDrag
            },
            drawInteraction: function(context) {},
            delta: function() {
                return mdiag.Utils.subtract(this.currentPoint, this.controlPointStart)
            },
            supportsAutoScroll: function() {
                return true
            },
            supportsCursors: function() {
                return true
            }
        };
        MindFusion.registerClass(SinglePointerController, "MindFusion.Diagramming.SinglePointerController")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var CreateLinkController = mdiag.CreateLinkController = function(diagram, link) {
            mflayer.initializeBase(CreateLinkController, this, [link, {
                item: link,
                index: link.points.length - 1
            }]);
            this.diagram = diagram;
            this.link = link;
            this.action = mdiag.Action.Create
        };
        CreateLinkController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(CreateLinkController, this, "start", [position]);
                this.link.startDrag(this)
            },
            move: function(position) {
                mflayer.callBaseMethod(CreateLinkController, this, "move", [position]);
                this.link.updateDrag(this);
                this.lastPosition = position.clone()
            },
            validate: function(position) {
                var link = this.link;
                return link.parent.raiseCreating(link, this) && link.allowDrag(this)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                var link = this.link;
                link.endDrag(this);
                this.diagram.addItem(link);
                this.diagram.raiseCreated(link);
                mflayer.callBaseMethod(CreateLinkController, this, "commit", [position])
            },
            drawInteraction: function(context) {
                this.link.graphicsContainer.draw(context, true, false)
            }
        };
        MindFusion.registerClass(CreateLinkController, "MindFusion.Diagramming.CreateLinkController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var CreateNodeController = mdiag.CreateNodeController = function(diagram, node) {
            mflayer.initializeBase(CreateNodeController, this, [node, {
                item: node,
                index: 2
            }]);
            this.diagram = diagram;
            this.node = node;
            this.action = mdiag.Action.Create
        };
        CreateNodeController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(CreateNodeController, this, "start", [position]);
                this.node.startDrag(this)
            },
            move: function(position) {
                mflayer.callBaseMethod(CreateNodeController, this, "move", [position]);
                this.node.updateDrag(this);
                this.lastPosition = position.clone()
            },
            validate: function(position) {
                var node = this.node;
                return node.parent.raiseCreating(node, this) && node.allowDrag(this)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                var node = this.node;
                node.endDrag(this);
                node = this.replaceNewItem(node);
                var diagram = this.diagram;
                diagram.addItem(node);
                diagram.raiseCreated(node);
                diagram.onItemDropped(node, position);
                mflayer.callBaseMethod(CreateNodeController, this, "commit", [position])
            },
            drawInteraction: function(context) {
                this.node.graphicsContainer.draw(context, true, false)
            },
            rectFromPoints: function(point1, point2, minSize) {
                var rect = Rect.fromPoints(point1, point2);
                if (rect.width < minSize) {
                    rect.width = minSize
                }
                if (rect.height < minSize) {
                    rect.height = minSize
                }
                return rect
            },
            replaceNewItem: function(item) {
                if (this.convertToShape && item.standardShapeReplacement) {
                    return item.standardShapeReplacement(this.diagram.freeFormTargets, this.diagram.defaultShape)
                }
                return item
            }
        };
        MindFusion.registerClass(CreateNodeController, "MindFusion.Diagramming.CreateNodeController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var CreateSelectionController = mdiag.CreateSelectionController = function(selection) {
            mflayer.initializeBase(CreateSelectionController, this, [selection]);
            this.selection = selection;
            this.action = mdiag.Action.Create
        };
        CreateSelectionController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(CreateSelectionController, this, "start", [position]);
                this.selection.startDrag(this);
                this.selectionRect = new Rect(position.x, position.y, 1, 1);
                this.selectionRect.pen = "gray";
                this.selectionRect.brush = "rgba(200,200,200,0.5)"
            },
            move: function(position) {
                mflayer.callBaseMethod(CreateSelectionController, this, "move", [position]);
                this.selection.updateDrag(this);
                this.lastPosition = position.clone();
                mdiag.Utils.setRect(this.selectionRect, Rect.fromPoints(this.startPoint, position));
                this.selection.parent.invalidate(false)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                this.selection.endDrag(this);
                mflayer.callBaseMethod(CreateSelectionController, this, "commit", [position])
            },
            drawInteraction: function(context) {
                this.selectionRect.draw(context, false)
            }
        };
        MindFusion.registerClass(CreateSelectionController, "MindFusion.Diagramming.CreateSelectionController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Keyboard = mdiag.Keyboard = {
            state: {}
        };
        var Touch = mdiag.Touch = {
            lastTouch: null
        };
        var Mouse = mdiag.Mouse = {
            LeftButton: 0,
            RightButton: 2,
            NoButton: -1
        }
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var ItemFollowsContainerRule = {
            dependencies: function(master) {
                if (mflayer.isInstanceOfType(mdiag.ContainerNode, master)) {
                    return master.children
                }
                return []
            },
            dependentUpon: function(dependency) {
                return [dependency.container]
            },
            recognize: function(dependency) {
                return mflayer.isInstanceOfType(mdiag.DiagramNode, dependency) && dependency.container != null
            },
            updateFromMasters: function(dependency, originalStates) {
                var container = dependency.container;
                var newCtrRect = container.getBounds();
                var oldCtrRect = originalStates.get(container).bounds;
                var p1 = newCtrRect.topLeft();
                var p2 = oldCtrRect.topLeft();
                var translation = mdiag.Utils.subtract(p1, p2);
                var oldRect = originalStates.get(dependency).bounds;
                dependency.setBounds(mdiag.Utils.offset(oldRect, translation))
            }
        };
        var AttachedFollowsMasterRule = {
            dependencies: function(master) {
                var deps = [];
                if (master.attachedNodes) {
                    master.attachedNodes.forEach(function(node) {
                        if (!node.attachment) {
                            node.attachment = {}
                        }
                        node.attachment.offsetX = node.bounds.x - master.bounds.x;
                        node.attachment.offsetY = node.bounds.y - master.bounds.y;
                        deps.push(node)
                    })
                }
                return deps
            },
            dependentUpon: function(dependency) {
                return [dependency.masterNode]
            },
            recognize: function(dependency) {
                return dependency.masterNode != null
            },
            updateFromMasters: function(dependency, originalStates) {
                var master = dependency.masterNode;
                var attachment = dependency.attachment;
                if (master) {
                    var bounds = dependency.bounds.clone();
                    bounds.x = master.bounds.x + attachment.offsetX;
                    bounds.y = master.bounds.y + attachment.offsetY;
                    dependency.setBounds(bounds)
                }
            }
        };
        var LinkFollowsNodesRule = {
            dependencies: function(master) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, master)) {
                    return master.getAllLinks()
                }
                return []
            },
            dependentUpon: function(dependency) {
                return [dependency.getOrigin(), dependency.getDestination()]
            },
            recognize: function(dependency) {
                return mflayer.isInstanceOfType(mdiag.DiagramLink, dependency)
            },
            updateFromMasters: function(dependency, originalStates) {
                dependency.updatePosFromOrgAndDest()
            }
        };
        var NodeFollowsSelectionRule = {
            dependencies: function(master) {
                if (mflayer.isInstanceOfType(mdiag.Selection, master)) {
                    return master.nodes
                }
                return []
            },
            dependentUpon: function(dependency) {
                return [dependency.parent.selection]
            },
            recognize: function(dependency) {
                return dependency.selected && mflayer.isInstanceOfType(mdiag.DiagramNode, dependency)
            },
            updateFromMasters: function(dependency, originalStates, ist) {
                var selection = dependency.parent.selection;
                var state = originalStates.get(selection);
                if (state) {
                    if (!dependency.parent.allowMultipleResize) {
                        var delta = mdiag.Utils.subtract(selection.bounds.topLeft(), state.bounds.topLeft());
                        var bounds = originalStates.get(dependency).bounds.clone();
                        bounds.x += delta.x;
                        bounds.y += delta.y;
                        dependency.setBounds(bounds)
                    } else {
                        if (ist.adjustmentHandle.index == 9) {
                            var node = ist.adjustmentHandle.item;
                            var oldRotationAngle = originalStates.get(dependency).rotationAngle;
                            dependency.setRotationAngle(oldRotationAngle + ist.angleDelta)
                        } else {
                            dependency.updateDrag(ist)
                        }
                    }
                }
            }
        };
        var DiagramMediator = mdiag.DiagramMediator = function(masterItem) {
            mflayer.initializeBase(DiagramMediator, this);
            this.masterItem = masterItem;
            var items = this.items = [masterItem];
            this.collectDependencies();
            this.originalStates = new MindFusion.Collections.Dictionary();
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                this.originalStates.set(item, item.saveLocationState())
            }
        };
        DiagramMediator.AllRules = [NodeFollowsSelectionRule, ItemFollowsContainerRule, AttachedFollowsMasterRule, LinkFollowsNodesRule];
        DiagramMediator.LinkRules = [LinkFollowsNodesRule];
        DiagramMediator.GroupRules = [ItemFollowsContainerRule, AttachedFollowsMasterRule];
        DiagramMediator.prototype = {
            rules: DiagramMediator.AllRules,
            updateDependencies: function() {
                var items = this.items;
                var rules = this.rules;
                var cycleGuard = 0;
                var lastItem = items[items.length - 1];
                var queue = items.slice(1);
                while (queue.length > 0) {
                    var item = queue.shift();
                    var allMastersProcessed = true;
                    for (var r = 0; r < rules.length && allMastersProcessed; r++) {
                        var rule = rules[r];
                        if (!rule.recognize(item)) {
                            continue
                        }
                        var masters = rule.dependentUpon(item);
                        if (cycleGuard <= r) {
                            for (var m = 0; m < masters.length; m++) {
                                if (queue.indexOf(masters[m]) >= 0) {
                                    allMastersProcessed = false;
                                    break
                                }
                            }
                        }
                    }
                    if (allMastersProcessed) {
                        for (var r = 0; r < rules.length; r++) {
                            var rule = rules[r];
                            if (this.canApplyRule(rule, item, queue)) {
                                rule.updateFromMasters(item, this.originalStates, this.ist)
                            }
                        }
                    } else {
                        queue.push(item)
                    }
                    if (item == lastItem) {
                        cycleGuard++;
                        lastItem = queue[queue.length - 1]
                    }
                }
                if (this.ist && typeof this.ist.angleDelta != "undefined") {
                    return
                }
                this.translateLinkPoints()
            },
            canApplyRule: function(rule, item, unprocessed) {
                if (!rule.recognize(item)) {
                    return false
                }
                var masters = rule.dependentUpon(item);
                for (var m = 0; m < masters.length; m++) {
                    var master = masters[m];
                    if (this.items.indexOf(master) >= 0 && unprocessed.indexOf(master) == -1) {
                        return true
                    }
                }
                return false
            },
            collectDependencies: function() {
                var items = this.items;
                var rules = this.rules;
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    for (var r = 0; r < rules.length; r++) {
                        var rule = rules[r];
                        var dependencies = rule.dependencies(item);
                        for (var d = 0; d < dependencies.length; d++) {
                            var dependency = dependencies[d];
                            if (items.indexOf(dependency) === -1) {
                                items.push(dependency)
                            }
                        }
                    }
                }
            },
            translateLinkPoints: function() {
                for (var i = 0; i < this.items.length; i++) {
                    if (!mflayer.isInstanceOfType(mdiag.DiagramLink, this.items[i])) {
                        continue
                    }
                    var link = this.items[i];
                    var origin = link.getOrigin();
                    var destination = link.getDestination();
                    var bothEndsDragged = origin != null && destination != null && this.items.indexOf(origin) > -1 && this.items.indexOf(destination) > -1;
                    if (bothEndsDragged) {
                        var offset = this.sameOffset(origin, destination);
                        if (offset) {
                            mdiag.Utils.offsetPointCollection(link.points, this.originalStates.get(link).controlPoints, offset);
                            link.updateFromPoints(false)
                        }
                    }
                }
            },
            sameOffset: function(node1, node2) {
                var epsilon = GraphicsUnit.getMillimeter(node1.parent.measureUnit) / 10000;
                var newBounds1 = node1.bounds;
                var oldBounds1 = this.originalStates.get(node1).bounds;
                if (!newBounds1.sameSize(oldBounds1)) {
                    return false
                }
                var newBounds2 = node2.bounds;
                var oldBounds2 = this.originalStates.get(node2).bounds;
                if (!newBounds2.sameSize(oldBounds2)) {
                    return false
                }
                var offset1 = Vector.fromPoints(oldBounds1.topLeft(), newBounds1.topLeft());
                var offset2 = Vector.fromPoints(oldBounds2.topLeft(), newBounds2.topLeft());
                if (Math.abs(offset1.x - offset2.x) < epsilon && Math.abs(offset1.y - offset2.y) < epsilon) {
                    return offset1
                }
                return null
            }
        };
        MindFusion.registerClass(DiagramMediator, "MindFusion.Diagramming.DiagramMediator")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var InplaceEditController = mdiag.InplaceEditController = function(modifiedItem) {
            mflayer.initializeBase(InplaceEditController, this);
            this.modifiedItem = modifiedItem;
            this.diagram = this.modifiedItem.getParent ? this.modifiedItem.getParent() : this.modifiedItem.parent.grid.parent
        };
        InplaceEditController.prototype = {
            start: function(point) {
                var diagram = this.diagram;
                var item = this.modifiedItem;
                var editObject = this.inplaceObject = item.getObjectToEdit(point);
                var text = editObject.getTextToEdit();
                var rect = editObject.getEditRect(point);
                var customEditor = null;
                var createEditControl = mflayer.getHandler(diagram, "createEditControl");
                if (createEditControl != null) {
                    var args = new mdiag.InplaceEditEventArgs({
                        item: item,
                        control: null,
                        bounds: diagram.getInplaceEditBounds(rect)
                    });
                    diagram.raiseEvent(mdiag.Events.createEditControl, args);
                    customEditor = args.control
                }
                if (customEditor == null) {
                    this.inplaceTextBox = document.createElement("textarea");
                    this.inplaceTextBox.id = diagram.get_element().id + "_inplaceInput";
                    this.inplaceTextBox.value = text;
                    this.inplaceTextBox.style.position = "absolute";
                    this.inplaceTextBox.style.zIndex = 2;
                    this.setInplaceEditBounds(rect);
                    this.inplaceTextBox.style.border = "1px solid #5C87B2";
                    document.body.appendChild(this.inplaceTextBox)
                } else {
                    this.inplaceTextBox = customEditor
                }
                this.inplaceTextBox.onkeyup = mflayer.createDelegate(this, this.inplaceKeyUp);
                diagram.keyboardHandler.setTargetElement(this.inplaceTextBox);
                var thisObj = this;
                setTimeout(function() {
                    thisObj.focusInput.apply(thisObj)
                }, 100);
                diagram.raiseEvent(mdiag.Events.enterInplaceEditMode, new mdiag.InplaceEditEventArgs({
                    item: item,
                    control: this.inplaceTextBox
                }))
            },
            focusInput: function() {
                if (this.inplaceTextBox) {
                    this.inplaceTextBox.focus()
                }
            },
            setInplaceEditBounds: function(rect) {
                var bounds = this.diagram.getInplaceEditBounds(rect);
                this.inplaceTextBox.style.left = bounds.x + "px";
                this.inplaceTextBox.style.top = bounds.y + "px";
                this.inplaceTextBox.style.width = bounds.width + "px";
                this.inplaceTextBox.style.height = bounds.height + "px"
            },
            validate: function(position) {
                var diagram = this.diagram;
                var pointInInplaceEdit = (this.inplaceTextBox != null) && diagram.inplaceEditBounds.containsPoint(position);
                if (pointInInplaceEdit) {
                    return false
                }
                return true
            },
            commit: function() {
                var diagram = this.diagram;
                diagram.raiseEvent(mdiag.Events.leaveInplaceEditMode, new mdiag.InplaceEditEventArgs({
                    item: this.inplaceObject,
                    control: this.inplaceTextBox
                }));
                var oldText = this.inplaceObject.getTextToEdit();
                var newText = this.inplaceTextBox.value;
                this.inplaceTextBox.style.visibility = "hidden";
                document.body.removeChild(this.inplaceTextBox);
                this.inplaceTextBox = null;
                var lastIO = this.inplaceObject;
                this.inplaceObject = null;
                var command = null;
                var item = lastIO.getDiagramItem();
                if (item) {
                    command = diagram.startItemChange(lastIO.getDiagramItem())
                }
                lastIO.setEditedText(newText);
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, lastIO)) {
                    diagram.raiseEvent(mdiag.Events.nodeTextEdited, lastIO.createEditArgs(oldText, newText))
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, lastIO)) {
                        diagram.raiseEvent(mdiag.Events.linkTextEdited, lastIO.createEditArgs(oldText, newText))
                    } else {
                        if (mflayer.isInstanceOfType(mdiag.CellEditor, lastIO)) {
                            diagram.raiseEvent(mdiag.Events.cellTextEdited, lastIO.createEditArgs(oldText, newText))
                        } else {
                            if (mflayer.isInstanceOfType(MindFusion.Diagramming.Lanes.Cell, lastIO)) {
                                diagram.raiseEvent(mdiag.Events.laneGridCellTextEdited, lastIO.createEditArgs(oldText, newText))
                            }
                        }
                    }
                }
                if (command) {
                    diagram.endItemChange(command)
                }
                diagram.mouseInputDispatcher.currentController = null;
                diagram.keyboardHandler.setTargetElement(diagram.get_focusElement())
            },
            cancel: function() {
                var diagram = this.diagram;
                diagram.raiseEvent(mdiag.Events.leaveInplaceEditMode, new mdiag.InplaceEditEventArgs({
                    item: this.inplaceObject,
                    control: this.inplaceTextBox
                }));
                this.inplaceTextBox.style.visibility = "hidden";
                document.body.removeChild(this.inplaceTextBox);
                this.inplaceTextBox = null;
                var lastIO = this.inplaceObject;
                this.inplaceObject = null;
                diagram.mouseInputDispatcher.currentController = null;
                diagram.keyboardHandler.setTargetElement(diagram.get_focusElement())
            },
            inplaceKeyUp: function(e) {
                if (e.keyCode == 27) {
                    this.cancel();
                    this.diagram.get_focusElement().focus()
                }
            },
            drawInteraction: function(context) {},
            move: function(position) {},
            shouldCancelDrag: function() {
                return false
            },
            supportsAutoScroll: function() {
                return false
            },
            supportsCursors: function() {
                return false
            }
        };
        MindFusion.registerClass(InplaceEditController, "MindFusion.Diagramming.InplaceEditController")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var KeyboardEventHandler = mdiag.KeyboardEventHandler = function(view) {
            mflayer.initializeBase(KeyboardEventHandler, this);
            this.view = view;
            this.canvasElement = view.get_element();
            this.targetElement = view.get_focusElement();
            this.inputDispatcher = view.keyboardInputDispatcher;
            this.keyUpDelegate = mflayer.createDelegate(this, this.onKeyUp)
        };
        KeyboardEventHandler.prototype = {
            attachHandlers: function() {
                mflayer.addHandlers(this.targetElement, {
                    keyup: this.keyUpDelegate
                })
            },
            setTargetElement: function(element) {
                if (element != this.targetElement) {
                    mflayer.removeHandler(this.targetElement, "keyup", this.keyUpDelegate);
                    this.targetElement = element;
                    this.attachHandlers()
                }
            },
            onKeyUp: function(e) {
                this.inputDispatcher.onKeyUp(this.targetElement.id, e.keyCode, null)
            }
        };
        MindFusion.registerClass(KeyboardEventHandler, "MindFusion.Diagramming.KeyboardEventHandler")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var KeyboardInputDispatcher = mdiag.KeyboardInputDispatcher = function(diagram) {
            mflayer.initializeBase(KeyboardInputDispatcher, this);
            this.diagram = diagram;
            this.inputState = {}
        };
        KeyboardInputDispatcher.prototype = {
            onKeyUp: function(targetId, keyCode, recorded, value) {
                var diagram = this.diagram;
                if (!diagram.enabled) {
                    return
                }
                var target = document.getElementById(targetId);
                if (target == this.diagram.get_focusElement()) {
                    if (keyCode == 46 || keyCode == 127 || (navigator.platform.toLowerCase().indexOf("mac") > -1 && keyCode == 8)) {
                        if (diagram.mouseInputDispatcher.currentController == null) {
                            if (diagram.delKeyAction == mdiag.DelKeyAction.DeleteActiveItem) {
                                diagram.deleteItem(diagram.activeItem)
                            }
                            if (diagram.delKeyAction == mdiag.DelKeyAction.DeleteSelectedItems) {
                                diagram.deleteSelection()
                            }
                        }
                    }
                } else {
                    if (recorded) {
                        target.value = value
                    }
                }
            }
        };
        MindFusion.registerClass(KeyboardInputDispatcher, "MindFusion.Diagramming.KeyboardInputDispatcher")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var LaneGridController = mdiag.LaneGridController = function(diagram, header, resizingHeaderWidth, headerBounds) {
            mflayer.initializeBase(LaneGridController, this, []);
            this.diagram = diagram;
            this.header = header;
            this.resizingHeaderWidth = resizingHeaderWidth;
            this.dragOffset = new MindFusion.Drawing.Size(0, 0);
            this.dragInitialPos = new MindFusion.Drawing.Point(0, 0);
            this.headerBounds = headerBounds
        };
        LaneGridController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(LaneGridController, this, "start", [position]);
                if (this.resizingHeaderWidth) {
                    this.current = this.last = position.x
                } else {
                    this.current = this.last = position.y
                }
            },
            move: function(position) {
                mflayer.callBaseMethod(LaneGridController, this, "move", [position]);
                if (this.resizingHeaderWidth) {
                    this.current = position.x;
                    var oldWidth = this.headerBounds.width;
                    var newWidth = Math.max(GraphicsUnit.getMillimeter(this.diagram.measureUnit), this.headerBounds.width + (this.current - this.last));
                    this.setWidth(newWidth);
                    if (!this.diagram.raiseHeaderResizing(this.header, this.resizingHeaderWidth)) {
                        this.setWidth(oldWidth)
                    } else {
                        this.resizing = true
                    }
                    if (oldWidth != this.headerBounds.width) {
                        this.last = this.current
                    }
                } else {
                    this.current = position.y;
                    var oldHeight = this.headerBounds.height;
                    var newHeight = Math.max(GraphicsUnit.getMillimeter(this.diagram.measureUnit), this.headerBounds.height + (this.current - this.last));
                    this.setHeight(newHeight);
                    if (!this.diagram.raiseHeaderResizing(this.header, this.resizingHeaderWidth)) {
                        this.setHeight(oldHeight)
                    } else {
                        this.resizing = true
                    }
                    if (oldHeight != this.headerBounds.height) {
                        this.last = this.current
                    }
                }
                this.diagram.invalidate()
            },
            commit: function(position) {
                if (this.resizing) {
                    this.diagram.raiseHeaderResized(this.header, this.resizingHeaderWidth)
                }
                this.resizing = false
            },
            cancel: function(position) {},
            getHeadersOnLevel: function(header) {
                var result = [];
                var parent = header.parent;
                if (parent.parent) {
                    for (var i = 0; i < parent.parent.subHeaders.length; i++) {
                        var pp = parent.parent.subHeaders[i];
                        for (var k = 0; k < pp.subHeaders.length; k++) {
                            result.push(pp.subHeaders[k])
                        }
                    }
                } else {
                    for (var i = 0; i < parent.subHeaders.length; i++) {
                        result.push(parent.subHeaders[i])
                    }
                }
                return result
            },
            setHeight: function(height) {
                if (this.header.isRowHeader()) {
                    this.header.setHeight(height)
                } else {
                    var headers = this.getHeadersOnLevel(this.header);
                    for (var i = 0; i < headers.length; i++) {
                        headers[i].setHeight(height)
                    }
                }
            },
            setWidth: function(width) {
                if (this.header.isRowHeader()) {
                    var headers = this.getHeadersOnLevel(this.header);
                    for (var i = 0; i < headers.length; i++) {
                        headers[i].setWidth(width)
                    }
                } else {
                    this.header.setWidth(width)
                }
            }
        };
        MindFusion.registerClass(LaneGridController, "MindFusion.Diagramming.LaneGridController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var MagnifyController = mdiag.MagnifyController = function(diagram) {
            mflayer.initializeBase(MagnifyController, this, []);
            this.diagram = diagram
        };
        MagnifyController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(MagnifyController, this, "start", [position]);
                this.diagram.invalidate()
            },
            move: function(position) {
                mflayer.callBaseMethod(MagnifyController, this, "move", [position]);
                this.diagram.invalidate()
            },
            drawInteraction: function(context) {
                this.diagram.drawMagnifier(this.currentPoint)
            }
        };
        MindFusion.registerClass(MagnifyController, "MindFusion.Diagramming.MagnifyController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var ManipulatorController = mdiag.ManipulatorController = function(diagram, manipulator) {
            mflayer.initializeBase(ManipulatorController, this, []);
            this.diagram = diagram;
            this.manipulator = manipulator
        };
        ManipulatorController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(ManipulatorController, this, "start", [position]);
                this.manipulator.onMouseDown(position)
            },
            move: function(position) {
                mflayer.callBaseMethod(ManipulatorController, this, "move", [position]);
                this.manipulator.onMouseMove(position);
                this.diagram.invalidate()
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                this.manipulator.onMouseUp(position);
                mflayer.callBaseMethod(ManipulatorController, this, "commit", [position])
            },
            cancel: function(position) {
                this.manipulator.cancel()
            }
        };
        MindFusion.registerClass(ManipulatorController, "MindFusion.Diagramming.ManipulatorController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var ModifyLinkController = mdiag.ModifyLinkController = function(link, adjustmentHandle) {
            mflayer.initializeBase(ModifyLinkController, this, [link, adjustmentHandle]);
            this.link = link
        };
        ModifyLinkController.prototype = {
            start: function(position) {
                this.mediator = new mdiag.DiagramMediator(this.link);
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(ModifyLinkController, this, "start", [position]);
                this.link.startDrag(this)
            },
            move: function(position) {
                mflayer.callBaseMethod(ModifyLinkController, this, "move", [position]);
                this.link.updateDrag(this);
                this.mediator.updateDependencies();
                this.lastPosition = position.clone()
            },
            validate: function(position) {
                var link = this.link;
                return link.parent.raiseModifying(link, this) && link.allowDrag(this)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                var link = this.link;
                link.endDrag(this);
                link.parent.raiseModified(link, position, this.adjustmentHandle.index);
                mflayer.callBaseMethod(ModifyLinkController, this, "commit", [position])
            }
        };
        MindFusion.registerClass(ModifyLinkController, "MindFusion.Diagramming.ModifyLinkController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var ModifyNodeController = mdiag.ModifyNodeController = function(node, adjustmentHandle) {
            mflayer.initializeBase(ModifyNodeController, this, [node, adjustmentHandle]);
            this.node = node;
            this.startBounds = node.bounds.clone()
        };
        ModifyNodeController.prototype = {
            start: function(position) {
                this.mediator = new mdiag.DiagramMediator(this.node);
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(ModifyNodeController, this, "start", [position]);
                this.node.startDrag(this)
            },
            move: function(position) {
                mflayer.callBaseMethod(ModifyNodeController, this, "move", [position]);
                var node = this.node;
                var handle = this.adjustmentHandle.index;
                if (handle === 9) {
                    var a = MindFusion.Geometry.cartesianToPolar(mdiag.Utils.getCenter(node.bounds), position).a;
                    node.setRotationAngle(90 - a * 180 / Math.PI, false)
                } else {
                    node.updateDrag(this)
                }
                this.mediator.updateDependencies();
                this.lastPosition = position.clone()
            },
            validate: function(position) {
                var node = this.node;
                return node.parent.raiseModifying(node, this) && node.allowDrag(this)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                var node = this.node;
                node.endDrag(this);
                var diagram = node.parent;
                diagram.raiseModified(node, position, this.adjustmentHandle.index);
                diagram.onItemDropped(node, position);
                mflayer.callBaseMethod(ModifyNodeController, this, "commit", [position])
            }
        };
        MindFusion.registerClass(ModifyNodeController, "MindFusion.Diagramming.ModifyNodeController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var ModifySelectionController = mdiag.ModifySelectionController = function(selection, adjustmentHandle) {
            mflayer.initializeBase(ModifySelectionController, this, [selection, adjustmentHandle]);
            this.selection = selection
        };
        ModifySelectionController.prototype = {
            start: function(position) {
                this.mediator = new mdiag.DiagramMediator(this.selection);
                this.mediator.ist = this;
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(ModifySelectionController, this, "start", [position]);
                this.selection.startDrag(this)
            },
            move: function(position) {
                mflayer.callBaseMethod(ModifySelectionController, this, "move", [position]);
                var handle = this.adjustmentHandle.index;
                if (handle === 9) {
                    var node = this.adjustmentHandle.item;
                    var oldRotationAngle = this.originalStates.get(node).rotationAngle;
                    var a = MindFusion.Geometry.cartesianToPolar(mdiag.Utils.getCenter(node.bounds), position).a;
                    a = 90 - a * 180 / Math.PI;
                    this.angleDelta = a - oldRotationAngle
                } else {
                    this.selection.updateDrag(this)
                }
                this.mediator.updateDependencies();
                this.lastPosition = position.clone()
            },
            validate: function(position) {
                var selection = this.selection;
                return selection.parent.raiseModifying(selection, this) && selection.allowDrag(this)
            },
            commit: function(position) {
                if (!position.equals(this.lastPosition)) {
                    this.move(position)
                }
                var selection = this.selection;
                selection.endDrag(this);
                var diagram = selection.parent;
                diagram.raiseModified(selection, position, this.adjustmentHandle.index);
                diagram.onItemDropped(selection, position);
                mflayer.callBaseMethod(ModifySelectionController, this, "commit", [position])
            }
        };
        MindFusion.registerClass(ModifySelectionController, "MindFusion.Diagramming.ModifySelectionController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var MouseEventHandler = mdiag.MouseEventHandler = function(view) {
            mflayer.initializeBase(MouseEventHandler, this);
            this.view = view;
            this.canvasElement = view.get_element();
            this.inputDispatcher = view.mouseInputDispatcher
        };
        MouseEventHandler.prototype = {
            attachHandlers: function() {
                var canvasElement = this.canvasElement;
                mflayer.addHandlers(canvasElement, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(canvasElement, {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                mflayer.addHandlers(canvasElement, {
                    mouseup: mflayer.createDelegate(this, this.onMouseUp)
                })
            },
            onMouseDown: function(e) {
                mdiag.Keyboard.state = e;
                var view = this.view;
                view.stopCursorChange = false;
                if (mdiag.Touch.lastTouch && new Date() - Touch.lastTouch < 500) {
                    return
                }
                if (!view.enabled) {
                    return
                }
                view.updateFocusable(e);
                var canvasElement = this.canvasElement;
                if (canvasElement.setCapture) {
                    canvasElement.setCapture()
                }
                var position = mdiag.Utils.getCursorPos(e, canvasElement);
                this.inputDispatcher.onMouseDown(position, e.button)
            },
            onMouseMove: function(e) {
                mdiag.Keyboard.state = e;
                var view = this.view;
                if (!view.enabled) {
                    return
                }
                view.clearTooltip();
                var position = mdiag.Utils.getCursorPos(e, this.canvasElement);
                this.inputDispatcher.onMouseMove(position)
            },
            onMouseUp: function(e) {
                mdiag.Keyboard.state = e;
                var view = this.view;
                view.stopCursorChange = false;
                view.stopAutoScroll();
                if (mdiag.Touch.lastTouch && new Date() - Touch.lastTouch < 500) {
                    return
                }
                if (!view.enabled) {
                    return
                }
                var position = mdiag.Utils.getCursorPos(e, this.canvasElement);
                this.inputDispatcher.onMouseUp(position, e.button);
                if (document.releaseCapture) {
                    document.releaseCapture()
                }
            }
        };
        MindFusion.registerClass(MouseEventHandler, "MindFusion.Diagramming.MouseEventHandler")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var LeftButton = 0;
        var RightButton = 2;
        var NoButton = -1;
        var MouseInputDispatcher = mdiag.MouseInputDispatcher = function(diagram) {
            mflayer.initializeBase(MouseInputDispatcher, this);
            this.diagram = diagram;
            this.buttonDown = NoButton;
            this.inputState = {}
        };
        MouseInputDispatcher.prototype = {
            onMouseDown: function(position, button) {
                var diagram = this.diagram;
                var diagramPoint = diagram.clientToDoc(position);
                this.pointerPosition = diagram.pointerPosition = diagramPoint;
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                if (this.buttonDown == NoButton) {
                    var now = new Date();
                    var dc = this.doubleClickCheck;
                    if (dc && now - dc.time < 500 && dc.button == button && mdiag.Utils.DistanceSq(diagramPoint, dc.position) < mm) {
                        this.onDoubleClick(dc.position, button);
                        this.doubleClickCheck = null;
                        return
                    }
                    this.buttonDown = button;
                    this.buttonDownPosition = diagramPoint;
                    this.buttonDownItem = this.getPointedItem();
                    this.doubleClickCheck = {
                        position: diagramPoint,
                        button: button,
                        time: new Date()
                    }
                }
            },
            onMouseMove: function(position) {
                var currentController = this.currentController;
                var diagram = this.diagram;
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                var diagramPoint = diagram.clientToDoc(position);
                this.pointerPosition = diagram.pointerPosition = diagramPoint;
                this.pointedItem = null;
                if ((diagram.showAnchors & mdiag.ShowAnchors.Auto) != 0) {
                    diagram.setAutoAnchorsNode(diagram.getNodeAt(diagramPoint, true, true))
                }
                if (this.buttonDown != NoButton) {
                    if (currentController == null && diagramPoint.distance(this.buttonDownPosition) >= mm) {
                        currentController = this.currentController = this.selectController();
                        if (currentController) {
                            currentController.start(this.buttonDownPosition)
                        }
                    }
                } else {
                    diagram.trackMouseMovement(diagramPoint)
                }
                if (currentController) {
                    if (diagram.autoScroll && currentController.supportsAutoScroll()) {
                        diagram.checkAutoScroll(diagramPoint)
                    }
                    currentController.move(diagramPoint);
                    if (currentController.supportsCursors()) {
                        diagram.get_element().style.cursor = currentController.validate(diagramPoint) ? diagram.currentBehavior.currentCursor : MouseCursors.NotAllowed
                    }
                    if (currentController.shouldCancelDrag()) {
                        currentController.cancel(diagramPoint);
                        this.currentController = null;
                        this.buttonDown = NoButton
                    }
                }
            },
            onMouseUp: function(position, button) {
                var diagram = this.diagram;
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                var diagramPoint = diagram.clientToDoc(position);
                if (this.currentController) {
                    if (this.buttonDown == button && this.currentController.validate(diagramPoint)) {
                        this.currentController.commit(diagramPoint);
                        this.currentController = null
                    } else {
                        if (!mflayer.isInstanceOfType(mdiag.InplaceEditController, this.currentController)) {
                            this.currentController.cancel(diagramPoint);
                            this.currentController = null
                        }
                    }
                } else {
                    var downPoint = this.buttonDownPosition;
                    if (!downPoint) {
                        downPoint = diagramPoint
                    }
                    if (diagramPoint.distance(downPoint) < mm) {
                        diagram.onClick(downPoint, button)
                    }
                }
                this.buttonDown = NoButton
            },
            onDoubleClick: function(position, button) {
                var diagram = this.diagram;
                var diagramPoint = diagram.clientToDoc(position);
                var itemUnderMouse = diagram.getItemAt(position, true, true);
                if (itemUnderMouse == null) {
                    if (diagram.getShowLaneGrid() && diagram.laneGrid.getAllowInplaceEdit()) {
                        var cellBounds = {};
                        var cell = diagram.laneGrid.getCellFromPoint(position, cellBounds);
                        if (cell != null) {
                            cell.setInplaceEditBounds(cellBounds.cellBounds);
                            cell.setIndex(cellBounds.column, cellBounds.row);
                            this.currentController = new mdiag.InplaceEditController(cell);
                            this.currentController.start(position)
                        }
                    }
                } else {
                    diagram.raiseDoubleClicked(itemUnderMouse, position, button);
                    if (diagram.allowInplaceEdit && !itemUnderMouse.notInteractive() && itemUnderMouse.hitTestManipulators(diagramPoint) == null) {
                        this.currentController = new mdiag.InplaceEditController(itemUnderMouse);
                        this.currentController.start(position)
                    }
                }
            },
            selectController: function() {
                var ist = this.inputState;
                ist.buttonDown = this.buttonDown;
                ist.pointerPosition = this.buttonDownPosition;
                ist.pointedItem = this.buttonDownItem;
                ist.pointedHandle = ist.pointedItem ? ist.pointedItem.handleAtPoint(ist.pointerPosition) : null;
                return this.diagram.currentBehavior.createController(ist)
            },
            getPointedItem: function() {
                if (this.pointedItem) {
                    return this.pointedItem
                }
                this.pointedItem = this.diagram.getItemAt(this.pointerPosition, true, true);
                return this.pointedItem
            }
        };
        MindFusion.registerClass(MouseInputDispatcher, "MindFusion.Diagramming.MouseInputDispatcher")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var PanController = mdiag.PanController = function(diagram) {
            mflayer.initializeBase(PanController, this, []);
            this.diagram = diagram
        };
        PanController.prototype = {
            start: function(position) {
                mflayer.callBaseMethod(PanController, this, "start", [position]);
                this.startScroll = this.diagram.getScrollPosition();
                this.panPoint = this.diagram.docToClient(position);
                this.mouseMoved = false
            },
            move: function(position) {
                mflayer.callBaseMethod(PanController, this, "move", [position]);
                var newPoint = this.diagram.docToClient(position);
                var sx = this.startScroll.x - this.diagram.clientToDocLength(newPoint.x - this.panPoint.x);
                var sy = this.startScroll.y - this.diagram.clientToDocLength(newPoint.y - this.panPoint.y);
                var rcPage = this.diagram.getViewport();
                this.diagram.scrollStayInDoc(sx, sy, rcPage);
                this.mouseMoved = true
            },
            supportsAutoScroll: function() {
                return false
            }
        };
        MindFusion.registerClass(PanController, "MindFusion.Diagramming.PanController", mdiag.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var RecordingKeyboardDispatcher = mdiag.RecordingKeyboardDispatcher = function(diagram, startTime) {
            mflayer.initializeBase(RecordingKeyboardDispatcher, this, [diagram]);
            this.data = [];
            this.startTimeStamp = startTime;
            this.eventDispatcher = null
        };
        RecordingKeyboardDispatcher.prototype = {
            onKeyUp: function(targetId, key) {
                mflayer.callBaseMethod(RecordingKeyboardDispatcher, this, "onKeyUp", [targetId, key, null]);
                this.addData("onKeyUp", targetId, key)
            },
            addData: function(func, targetId, key) {
                this.ellapsedTime = new Date().getTime();
                var time = (this.ellapsedTime - this.startTimeStamp);
                var target = document.getElementById(targetId);
                this.data.push({
                    func: func,
                    time: time,
                    targetId: targetId,
                    key: key,
                    value: target.value
                });
                if (this.addDataId) {
                    clearTimeout(this.addDataId);
                    this.addDataId = null
                }
            }
        };
        MindFusion.registerClass(RecordingKeyboardDispatcher, "MindFusion.Diagramming.RecordingKeyboardDispatcher", mdiag.KeyboardInputDispatcher)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var RecordingMouseDispatcher = mdiag.RecordingMouseDispatcher = function(diagram, startTime) {
            mflayer.initializeBase(RecordingMouseDispatcher, this, [diagram]);
            this.data = [];
            this.startTimeStamp = startTime;
            this.eventDispatcher = null
        };
        RecordingMouseDispatcher.prototype = {
            onMouseDown: function(position, button) {
                mflayer.callBaseMethod(RecordingMouseDispatcher, this, "onMouseDown", [position, button]);
                this.addData("onMouseDown", position, button)
            },
            onMouseMove: function(position) {
                mflayer.callBaseMethod(RecordingMouseDispatcher, this, "onMouseMove", [position]);
                if (!this.addDataId) {
                    var thisObj = this;
                    this.addDataId = setTimeout(function() {
                        thisObj.addData("onMouseMove", position)
                    }, 20)
                }
            },
            onMouseUp: function(position, button) {
                mflayer.callBaseMethod(RecordingMouseDispatcher, this, "onMouseUp", [position, button]);
                this.addData("onMouseUp", position, button)
            },
            addData: function(func, position, button) {
                this.ellapsedTime = new Date().getTime();
                var time = (this.ellapsedTime - this.startTimeStamp);
                this.data.push({
                    func: func,
                    time: time,
                    position: position,
                    button: button
                });
                if (this.addDataId) {
                    clearTimeout(this.addDataId);
                    this.addDataId = null
                }
            }
        };
        MindFusion.registerClass(RecordingMouseDispatcher, "MindFusion.Diagramming.RecordingMouseDispatcher", mdiag.MouseInputDispatcher)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Vector = MindFusion.Drawing.Vector;
        var TouchEventHandler = mdiag.TouchEventHandler = function(view) {
            mflayer.initializeBase(TouchEventHandler, this);
            this.view = view;
            this.canvasElement = view.get_element();
            this.inputDispatcher = view.mouseInputDispatcher
        };
        TouchEventHandler.prototype = {
            attachHandlers: function() {
                var canvasElement = this.canvasElement;
                canvasElement.addEventListener("touchstart", mflayer.createDelegate(this, this.onTouchStart), false);
                canvasElement.addEventListener("touchmove", mflayer.createDelegate(this, this.onTouchMove), false);
                canvasElement.addEventListener("touchend", mflayer.createDelegate(this, this.onTouchEnd), false);
                canvasElement.addEventListener("touchcancel", mflayer.createDelegate(this, this.onTouchEnd), false)
            },
            emulateMouse: function(e) {
                var touches = e.touches;
                var mouseEvent = {
                    button: 0,
                    clientX: touches[0].clientX,
                    clientY: touches[0].clientY,
                    preventDefault: function() {}
                };
                return mouseEvent
            },
            onTouchStart: function(e) {
                var diagram = this.view;
                diagram.touchThreshold = 2.5 * GraphicsUnit.getMillimeter(diagram.measureUnit);
                var mouseHandler = diagram.mouseHandler;
                var currentController = this.inputDispatcher.currentController;
                var touches = e.touches;
                if (diagram.preventDefaultTouch && !currentController) {
                    mdiag.Touch.lastTouch = null;
                    this.lastTouch = this.emulateMouse(e);
                    mouseHandler.onMouseDown(this.lastTouch);
                    mdiag.Touch.lastTouch = new Date()
                } else {
                    if (diagram.preventDefaultTouch && currentController && touches.length > 1) {
                        currentController.cancel();
                        this.inputDispatcher.currentController = null
                    }
                }
            },
            onTouchMove: function(e) {
                var diagram = this.view;
                var mouseHandler = diagram.mouseHandler;
                var touches = e.touches;
                if (diagram.preventDefaultTouch && touches.length == 1) {
                    this.lastTouch = this.emulateMouse(e);
                    mouseHandler.onMouseMove(this.lastTouch);
                    e.preventDefault()
                }
            },
            onTouchEnd: function(e) {
                var diagram = this.view;
                var mouseHandler = diagram.mouseHandler;
                if (diagram.preventDefaultTouch) {
                    mdiag.Touch.lastTouch = null;
                    mouseHandler.onMouseUp(this.lastTouch);
                    mdiag.Touch.lastTouch = new Date()
                }
                diagram.touchThreshold = 0
            }
        };
        MindFusion.registerClass(TouchEventHandler, "MindFusion.Diagramming.TouchEventHandler")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var AnchorPoint = MindFusion.Diagramming.AnchorPoint;
        var MarkStyle = MindFusion.Diagramming.MarkStyle;
        var AnchorPattern = mdiag.AnchorPattern = function(points, patternId) {
            this.points = (points) ? points : [];
            this.regIndex = -1;
            if (patternId != undefined) {
                this.setPatternId(patternId)
            }
            this.serverRegistered = false
        };
        AnchorPattern.prototype = {
            toJson: function() {
                var json = {
                    id: this.patternId
                };
                if (!json.id || json.id == "" || !this.serverRegistered) {
                    json.points = this.serializePoints()
                }
                return json
            },
            serializePoints: function() {
                var result = [];
                var instanceId = 0;
                for (var i = 0, l = this.points.length; i < l; i++) {
                    var point = this.points[i];
                    point.instanceId = instanceId++;
                    var json = point.toJson();
                    result.push(json)
                }
                return result
            },
            fromJson: function(json) {
                var points = [];
                for (var i = 0; i < json.points.length; i++) {
                    if (json.points[i]) {
                        var point = new AnchorPoint();
                        point.fromJson(json.points[i]);
                        this.points.push(point)
                    }
                }
            },
            setPatternId: function(id) {
                if (AnchorPattern.idMap.contains(id)) {
                    throw new ArgumentException("The AnchorPattern string identifier must be unique.")
                }
                this.patternId = id;
                AnchorPattern.idMap.set(this.patternId, this)
            },
            allowLinkDirection: function(outgoing, node, rowIndex) {
                if (this.points == null) {
                    return false
                }
                for (i = 0; i < this.points.length; ++i) {
                    var pt = this.points[i];
                    if (outgoing) {
                        if (pt.allowOutgoing() && node.raiseValidateAnchorPoint(null, true, i, rowIndex)) {
                            return true
                        }
                    } else {
                        if (pt.allowIncoming() && node.raiseValidateAnchorPoint(null, false, i, rowIndex)) {
                            return true
                        }
                    }
                }
                return false
            },
            assignId: function(id) {
                if (this.patternId != "") {
                    return
                }
                if (AnchorPattern.idMap.contains(id)) {
                    return
                }
                this.setPatternId(id)
            },
            apply: function(pattern) {
                this.points = [];
                for (var i = 0; i < pattern.points.length; i++) {
                    var point = pattern.points[i];
                    this.points.add(point.clone())
                }
            },
            getRegIndex: function() {
                return this.regIndex
            },
            setPoints: function(value) {
                this.points = value
            },
            getPoints: function() {
                return this.points
            },
            getId: function() {
                return this.patternId
            },
            isRegistered: function() {
                if (AnchorPattern.idMap.contains(this.patternId)) {
                    return true
                }
                return false
            }
        };
        AnchorPattern.idMap = new MindFusion.Collections.Dictionary();
        AnchorPattern.decision2In2Out = new AnchorPattern([new AnchorPoint(50, 0, true, false, MarkStyle.Circle, "blue"), new AnchorPoint(0, 50, true, false, MarkStyle.Circle, "blue"), new AnchorPoint(50, 100, false, true, MarkStyle.Rectangle, "green"), new AnchorPoint(100, 50, false, true, MarkStyle.Rectangle, "red")], "Decision2In2Out");
        AnchorPattern.decision1In3Out = new AnchorPattern([new AnchorPoint(50, 0, true, false, MarkStyle.Circle, "blue"), new AnchorPoint(0, 50, false, true, MarkStyle.Rectangle, "red"), new AnchorPoint(50, 100, false, true, MarkStyle.Rectangle, "green"), new AnchorPoint(100, 50, false, true, MarkStyle.Rectangle, "red")], "Decision1In3Out");
        AnchorPattern.leftInRightOut = new AnchorPattern([new AnchorPoint(0, 50, true, false, MarkStyle.Circle, "blue"), new AnchorPoint(100, 50, false, true, MarkStyle.Rectangle, "blue")], "LeftInRightOut");
        AnchorPattern.topInBottomOut = new AnchorPattern([new AnchorPoint(50, 0, true, false, MarkStyle.Circle, "blue"), new AnchorPoint(50, 100, false, true, MarkStyle.Rectangle, "green")], "TopInBottomOut");
        AnchorPattern.fromId = function(id) {
            if (AnchorPattern.idMap.contains(id)) {
                return AnchorPattern.idMap.get(id)
            }
        };
        MindFusion.registerClass(AnchorPattern, "MindFusion.Diagramming.AnchorPattern")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var BehaviorBase = mdiag.BehaviorBase = function(parent) {
            mflayer.initializeBase(BehaviorBase, this);
            this.diagram = parent;
            this.currentCursor = MouseCursors.Move
        };
        BehaviorBase.prototype = {
            createController: function(state) {
                var diagram = this.diagram;
                var point = state.pointerPosition;
                var onlySelection = false;
                var activeManipulator = diagram.hitTestManipulators(point);
                if (activeManipulator != null) {
                    if (activeManipulator.needsMouseMessages(point)) {
                        return new mdiag.ManipulatorController(diagram, activeManipulator)
                    }
                    activeManipulator.onClick(point);
                    return null
                }
                var panMode = diagram.enabled && (diagram.behavior == mdiag.Behavior.Pan || diagram.buttonMappedTo(state.buttonDown, mdiag.MouseButtonActions.Pan) || (state.buttonDown == 0 && diagram.modifierKeyActions.getKeys(mdiag.ModifierKeyAction.Pan, mdiag.Keyboard.state)));
                if (panMode) {
                    return new mdiag.PanController(diagram)
                }
                var magnifyMode = diagram.enabled && (diagram.buttonMappedTo(state.buttonDown, mdiag.MouseButtonActions.Magnify) || (state.buttonDown == 0 && diagram.modifierKeyActions.getKeys(mdiag.ModifierKeyAction.Magnify, mdiag.Keyboard.state)));
                if (magnifyMode) {
                    return new mdiag.MagnifyController(diagram)
                }
                if (state.buttonDown == 0 && diagram.getShowLaneGrid() && diagram.getLaneGrid().allowResizeHeaders) {
                    var data = diagram.canResizeLaneHeader(point);
                    if (data) {
                        return new mdiag.LaneGridController(diagram, data.header, data.resizingHeaderWidth, data.headerBounds)
                    }
                }
                if (!diagram.buttonMappedTo(state.buttonDown, mdiag.MouseButtonActions.Draw)) {
                    if (!diagram.buttonMappedTo(state.buttonDown, mdiag.MouseButtonActions.Select)) {
                        return null
                    }
                    onlySelection = true
                }
                if ((state.buttonDown == 0 && diagram.modifierKeyActions.getKeys(mdiag.ModifierKeyAction.Select, mdiag.Keyboard.state)) || onlySelection) {
                    var controller = new mdiag.CreateSelectionController(diagram.selection);
                    return controller
                }
                var item = null;
                if (diagram.selection.nodes.length > 1) {
                    var adjustmentHandle = diagram.selection.handleAtPoint(point);
                    if (adjustmentHandle && !mflayer.isInstanceOfType(mdiag.FreeFormHandle, adjustmentHandle)) {
                        item = diagram.selection;
                        var controller = new mdiag.ModifySelectionController(diagram.selection, adjustmentHandle);
                        return controller
                    }
                }
                var adjustmentHandle = diagram.getHandleAt(point);
                item = diagram.activeItem;
                if (item && adjustmentHandle == null) {
                    adjustmentHandle = item.handleAtPoint(point)
                }
                if (adjustmentHandle) {
                    var item = adjustmentHandle.item;
                    if (item == diagram.autoHandlesItem) {
                        diagram.selection.clear();
                        diagram.selection.addItem(item);
                        diagram.setAutoHandlesItem(null)
                    }
                    var controller = mflayer.isInstanceOfType(mdiag.DiagramNode, item) ? new mdiag.ModifyNodeController(item, adjustmentHandle) : new mdiag.ModifyLinkController(item, adjustmentHandle);
                    return controller
                }
                return null
            },
            createLink: function(origin, point) {
                var link = new mdiag.DiagramLink(this.diagram, origin, point);
                link.originConnection.chooseBestAnchorPoint(point);
                return link
            },
            setModfCursor: function(point, adjustmentHandle) {
                var handle = adjustmentHandle.index;
                var node = mflayer.isInstanceOfType(mdiag.DiagramNode, adjustmentHandle.item) ? adjustmentHandle.item : null;
                if (node == null || handle == 8 || mflayer.isInstanceOfType(mdiag.FreeFormHandle, adjustmentHandle)) {
                    return this.setCurrentCursor(MouseCursors.Move)
                }
                if (handle == 9) {
                    return this.setCurrentCursor(MouseCursors.Rotate)
                }
                if (node.getRotationAngle() != 0) {
                    var a = 0,
                        r = 0;
                    var d = 360 / 16;
                    var ctp = MindFusion.Geometry.cartesianToPolar(node.getCenter(), point);
                    ctp.a = MindFusion.Geometry.radianToDegree(ctp.a);
                    a = parseInt((360 - ctp.a) % 360);
                    if (a >= 1 * d && a < 3 * d) {
                        this.currentCursor = MouseCursors.DiagonalResize
                    } else {
                        if (a >= 3 * d && a < 5 * d) {
                            this.currentCursor = MouseCursors.VerticalResize
                        } else {
                            if (a >= 5 * d && a < 7 * d) {
                                this.currentCursor = MouseCursors.CounterDiagonalResize
                            } else {
                                if (a >= 7 * d && a < 9 * d) {
                                    this.currentCursor = MouseCursors.HorizontalResize
                                } else {
                                    if (a >= 9 * d && a < 11 * d) {
                                        this.currentCursor = MouseCursors.DiagonalResize
                                    } else {
                                        if (a >= 11 * d && a < 13 * d) {
                                            this.currentCursor = MouseCursors.VerticalResize
                                        } else {
                                            if (a >= 13 * d && a < 15 * d) {
                                                this.currentCursor = MouseCursors.CounterDiagonalResize
                                            } else {
                                                this.currentCursor = MouseCursors.HorizontalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (handle == 0 || handle == 2) {
                        this.currentCursor = MouseCursors.DiagonalResize
                    }
                    if (handle == 1 || handle == 3) {
                        this.currentCursor = MouseCursors.CounterDiagonalResize
                    }
                    if (handle == 4 || handle == 6) {
                        this.currentCursor = MouseCursors.VerticalResize
                    }
                    if (handle == 5 || handle == 7) {
                        this.currentCursor = MouseCursors.HorizontalResize
                    }
                }
                return this.currentCursor
            },
            getResizeCursor: function(handle) {
                if (handle == 0 || handle == 2) {
                    return MouseCursors.DiagonalResize
                }
                if (handle == 1 || handle == 3) {
                    return MouseCursors.CounterDiagonalResize
                }
                if (handle == 4 || handle == 6) {
                    return MouseCursors.VerticalResize
                }
                if (handle == 5 || handle == 7) {
                    return MouseCursors.HorizontalResize
                }
                return null
            },
            setMouseCursor: function(point, startInteraction) {},
            setCurrentCursor: function(value) {
                this.currentCursor = value;
                return value
            }
        };
        MindFusion.registerClass(BehaviorBase, "MindFusion.Diagramming.BehaviorBase")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Rect = MindFusion.Drawing.Rect;
        var CellEditor = mdiag.CellEditor = function(table, cellInfo) {
            this.table = table;
            this.cell = cellInfo.cell;
            this.rect = cellInfo.cellRect;
            this.column = cellInfo.column;
            this.row = cellInfo.row
        };
        CellEditor.prototype = {
            getTextToEdit: function() {
                return this.cell.getText()
            },
            getEditRect: function(point) {
                if (this.table.rotationAngle == 0) {
                    return this.rect
                } else {
                    return mdiag.Utils.rotateRect(this.rect.clone(), this.table.getBounds().center(), this.table.rotationAngle)
                }
            },
            createEditArgs: function(oldText, newText) {
                return new mdiag.CellEventArgs({
                    node: this.table,
                    cell: this.cell,
                    oldText: oldText,
                    newText: newText,
                    column: this.column,
                    row: this.row
                })
            },
            setEditedText: function(newText) {
                this.cell.setText(newText)
            },
            getDiagramItem: function() {
                return this.table
            }
        };
        MindFusion.registerClass(CellEditor, "MindFusion.Diagramming.CellEditor")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var ColumnStyle = MindFusion.Diagramming.ColumnStyle;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var ColumnResizer = mdiag.ColumnResizer = function(node, columnIndex) {
            mflayer.initializeBase(ColumnResizer, this, [node]);
            this.columnIndex = columnIndex;
            this.column = this.node.getColumn(this.columnIndex);
            this.startWidth = this.column.width;
            this.autoWidth = this.column.columnStyle == ColumnStyle.AutoWidth
        };
        ColumnResizer.prototype = {
            hitTest: function(mousePosition) {
                return false
            },
            needsMouseMessages: function(mousePosition) {
                return true
            },
            setMouseCursor: function(mousePosition) {
                if (this.node.getRotationAngle() != 0) {
                    var a = this.node.getRotationAngle();
                    if (a >= -180 && a < -135) {
                        return MouseCursors.DiagonalResize
                    } else {
                        if (a >= -135 && a < -90) {
                            return MouseCursors.VerticalResize
                        } else {
                            if (a >= -90 && a < -45) {
                                return MouseCursors.CounterDiagonalResize
                            } else {
                                if (a >= -45 && a < 0) {
                                    return MouseCursors.HorizontalResize
                                } else {
                                    if (a >= 0 && a < 45) {
                                        return MouseCursors.DiagonalResize
                                    } else {
                                        if (a >= 45 && a < 90) {
                                            return MouseCursors.VerticalResize
                                        } else {
                                            if (a >= 90 && a < 135) {
                                                return MouseCursors.CounterDiagonalResize
                                            } else {
                                                return MouseCursors.HorizontalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return MouseCursors.HorizontalResize
            },
            localPoint: function(point) {
                if (this.node.getRotationAngle() != 0) {
                    return mdiag.Utils.rotatePointAt(point, this.node.bounds.center(), -this.node.getRotationAngle())
                }
                return point.clone()
            },
            onMouseDown: function(mousePosition) {
                this.mouseDown = true;
                var localPoint = this.localPoint(mousePosition);
                this.current = this.last = localPoint.x
            },
            onMouseMove: function(mousePosition) {
                if (!this.mouseDown) {
                    return
                }
                var localPoint = this.localPoint(mousePosition);
                this.current = localPoint.x;
                var diagram = this.node.getParent();
                if (!this.resizing) {
                    if (Math.abs(this.current - this.last) >= GraphicsUnit.getMillimeter(diagram.measureUnit) * 2) {
                        this.resizing = true;
                        if (diagram.getUndoEnabled()) {
                            this.cmd = new mdiag.ResizeTableColumnCommand(diagram, this.node, this.column)
                        }
                    }
                }
                if (this.resizing) {
                    if (this.column.columnStyle == ColumnStyle.AutoWidth) {
                        this.node.setColumnStyle(this.column, ColumnStyle.FixedWidth)
                    }
                    var oldWidth = this.column.width;
                    this.node.setColumnWidth(this.column, Math.max(GraphicsUnit.getMillimeter(diagram.measureUnit), this.column.width + (this.current - this.last)));
                    var shouldCancel = {
                        value: undefined
                    };
                    if (!diagram.raiseTableColumnResizing(this.node, this.columnIndex, mousePosition, 0, shouldCancel)) {
                        this.node.setColumnWidth(this.column, oldWidth)
                    }
                    if (shouldCancel.value) {
                        this.cancel()
                    }
                    if (oldWidth != this.column.width) {
                        this.last = this.current
                    }
                }
            },
            onMouseUp: function(mousePosition) {
                if (this.resizing) {
                    var diagram = this.node.getParent();
                    if (diagram.getUndoEnabled()) {
                        diagram.undoManager.executeCommand(this.cmd)
                    }
                    diagram.raiseTableColumnResized(this.node, this.columnIndex, mousePosition, 0)
                }
                this.mouseDown = false;
                this.resizing = false
            },
            cancel: function() {
                if (this.resizing) {
                    this.mouseDown = false;
                    this.resizing = false;
                    this.node.setColumnWidth(this.column, this.startWidth);
                    if (this.autoWidth) {
                        this.column.setColumnStyle(ColumnStyle.AutoWidth)
                    }
                    this.cmd = null
                }
            }
        };
        MindFusion.registerClass(ColumnResizer, "MindFusion.Diagramming.ColumnResizer", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Command = mdiag.Command = function(diagram) {
            this.diagram = diagram
        };
        Command.prototype = {
            execute: function() {},
            undo: function() {},
            redo: function() {}
        };
        MindFusion.registerClass(Command, "MindFusion.Diagramming.Command")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Component = MindFusion.Drawing.Component;
        var CompositeNode = mdiag.CompositeNode = function(parent) {
            mflayer.initializeBase(CompositeNode, this, [parent]);
            this.root = new mdiag.SimplePanel()
        };
        CompositeNode.classFromTemplate = function(className, jsonTemplate, init) {
            var shortName = className;
            var ns = window;
            var qualifiedNameParts = className.split(".");
            if (qualifiedNameParts.length > 1) {
                shortName = qualifiedNameParts[qualifiedNameParts.length - 1];
                ns = eval(qualifiedNameParts.slice(0, -1).join("."))
            }
            var ctor = ns[shortName] = function(parent) {
                mflayer.initializeBase(ctor, this, [parent]);
                this.loadTemplate(jsonTemplate);
                if (init) {
                    init.apply(this, [parent])
                }
            };
            ctor.prototype = {};
            MindFusion.registerClass(ctor, className, CompositeNode);
            return ctor
        };
        CompositeNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(CompositeNode, this, "clone", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var setter = props["set" + method.substring(3)];
                        setter.call(copy, getter.call(this))
                    }
                }
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            firstCharLower: function(string) {
                return string.charAt(0).toLowerCase() + string.slice(1)
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(CompositeNode, this, "toJson", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        json[propName] = getter.call(this)
                    }
                }
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(CompositeNode, this, "fromJson", [json]);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "set") {
                            continue
                        }
                        var setter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        setter.call(this, json[propName])
                    }
                }
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(CompositeNode, this, "saveState", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        state[propName] = getter.call(this)
                    }
                }
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(CompositeNode, this, "restoreState", [state]);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "set") {
                            continue
                        }
                        var setter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        setter.call(this, state[propName])
                    }
                }
            },
            loadTemplate: function(jsonTemplate) {
                var loader = new mdiag.ComponentLoader(this.invalidate.bind(this));
                var rootPanel = loader.componentFromJson(jsonTemplate);
                this.root = rootPanel;
                this.namedComponents = loader.nameMap;
                this.propertyMap = loader.propertyMap;
                var prototype = this.constructor.prototype;
                for (method in loader.propertyMap) {
                    if (!prototype[method]) {
                        prototype[method] = loader.propertyMap[method]
                    }
                }
            },
            getComponent: function(name) {
                return this.namedComponents[name]
            },
            updateCanvasElements: function() {
                var rect = this.bounds;
                this.graphicsContainer.content = [this.root];
                Component.context = this.parent;
                this.root.measure(rect.width, rect.height);
                this.root.arrange(rect.x, rect.y, rect.width, rect.height)
            },
            getObjectToEdit: function(point) {
                var component = this.root.hitTest(point);
                if (mflayer.isInstanceOfType(MindFusion.Drawing.Text, component)) {
                    return new mdiag.TextEditor(this, component)
                }
                return this
            },
            diagramCoords: function(component) {
                var bounds = component.getBounds().clone();
                while (component.parent != null) {
                    component = component.parent;
                    bounds.x += component.x;
                    bounds.y += component.y
                }
                return bounds
            }
        };
        MindFusion.registerClass(CompositeNode, "MindFusion.Diagramming.CompositeNode", mdiag.DiagramNode);
        var TextEditor = mdiag.TextEditor = function(node, component) {
            this.node = node;
            this.component = component
        };
        TextEditor.prototype = {
            getTextToEdit: function() {
                return this.component.getText()
            },
            getEditRect: function(point) {
                return this.node.diagramCoords(this.component)
            },
            createEditArgs: function(oldText, newText) {
                return new mdiag.ComponentEventArgs({
                    node: this.node,
                    component: this.component,
                    oldText: oldText,
                    newText: newText
                })
            },
            setEditedText: function(newText) {
                this.component.setText(newText)
            },
            getDiagramItem: function() {
                return this.node
            }
        };
        MindFusion.registerClass(TextEditor, "MindFusion.Diagramming.TextEditor")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Point = MindFusion.Drawing.Point;
        var ConnectionPoint = mdiag.ConnectionPoint = function(node, link, incoming) {
            this.node = node;
            this.link = link;
            this.incoming = incoming;
            this.anchorPointDetails = {
                index: -1,
                point: new MindFusion.Drawing.Point(0, 0)
            };
            this.type = this.constructor.__typeName
        };
        ConnectionPoint.prototype = {
            addLinkToNode: function() {
                if (this.incoming) {
                    this.node.addIncomingLink(this.link)
                } else {
                    this.node.addOutgoingLink(this.link)
                }
            },
            removeLinkFromNode: function() {
                if (this.incoming) {
                    this.node.removeIncomingLink(this.link)
                } else {
                    this.node.removeOutgoingLink(this.link)
                }
            },
            sameNode: function(connectionPoint) {
                var node = connectionPoint.node;
                return (node != null && node === this.node)
            },
            saveEndRelative: function(ctrRelative) {
                if (ctrRelative === undefined) {
                    ctrRelative = true
                }
                var point = this.incoming ? this.link.getEndPoint() : this.link.getStartPoint();
                var angle = this.node.rotationAngle;
                if (angle !== 0) {
                    var pivot = mdiag.Utils.getCenter(this.node.bounds);
                    point = mdiag.Utils.rotatePointAt(point, pivot, -angle)
                }
                if (ctrRelative) {
                    var container = mdiag.ContainerNode.getFoldedContainer(this.node);
                    if (container) {
                        var ctrBounds = container.getBounds();
                        this.relativePosition = mdiag.Utils.getRectPtPercent(point, ctrBounds);
                        return
                    }
                }
                this.relativePosition = mdiag.Utils.getRectPtPercent(point, this.node.bounds)
            },
            chooseBestAnchorPoint: function(point) {
                this.anchorPointDetails = this.getNearestAnchorPoint(point);
                if (!this.anchorPointDetails) {
                    this.anchorPointDetails = this.getNearestBorderPoint(point)
                }
            },
            getNearestAnchorPoint: function(point) {
                if (!this.node.anchorPattern) {
                    return null
                }
                var pointDetails = this.node.getNearestAnchor(point, this.link, this.incoming);
                if (pointDetails.index === -1) {
                    return null
                }
                return pointDetails
            },
            getNearestBorderPoint: function(point) {
                var borderPoint = this.node.getNearestBorderPoint(point);
                var relativePoint = mdiag.Utils.getRectPtPercent(borderPoint, this.node.bounds);
                return {
                    point: borderPoint,
                    location: relativePoint,
                    index: -1
                }
            },
            alignEndPointToBorder: function(point) {
                this.anchorPointDetails = this.getNearestAnchor(point, this.link, this.incoming)
            },
            linkChanges: function(item, point) {
                return (this.node !== item)
            },
            getInitialPoint: function() {
                return this.node.getCenter()
            },
            nodesIntersect: function(connectionPoint) {
                return mdiag.DiagramNode.nodesIntersect(this.node, connectionPoint.node)
            },
            getIntersection: function(point1, point2) {
                return this.node.getIntersection(point1, point2)
            },
            getNodeRect: function() {
                return this.node.bounds
            },
            getLocation: function() {
                var container = mdiag.ContainerNode.getFoldedContainer(this.node);
                if (container) {
                    var location = mdiag.Utils.rectPtFromPercent(this.relativePosition, container.getBounds());
                    return location
                }
                return this.getEndPoint()
            },
            getEndPoint: function() {
                var point = mdiag.Utils.rectPtFromPercent(this.relativePosition, this.node.bounds);
                var angle = this.node.rotationAngle;
                if (angle !== 0) {
                    var pivot = mdiag.Utils.getCenter(this.node.bounds);
                    point = mdiag.Utils.rotatePointAt(point, pivot, angle)
                }
                return point
            },
            canMoveLink: function(point) {
                return this.node.containsPoint(point)
            },
            getType: function() {
                return this.type
            },
            getNearestAnchor: function(point, link, incoming) {
                return this.node.getNearestAnchor(point, link, incoming)
            },
            clone: function(link, node) {
                var copy = node.createConnectionPoint(link, new Point(), this.incoming);
                if (!mflayer.isInstanceOfType(mdiag.DummyNode, node) && node.anchorPattern && node.anchorPattern.points.length > this.anchorPointDetails.index) {
                    copy.anchorPointDetails.index = this.anchorPointDetails.index
                }
                copy.relativePosition = this.relativePosition;
                return copy
            }
        };
        MindFusion.registerClass(ConnectionPoint, "MindFusion.Diagramming.ConnectionPoint");
        var DummyConnectionPoint = mdiag.DummyConnectionPoint = function(link, incoming, point) {
            mflayer.initializeBase(DummyConnectionPoint, this, [null, link, incoming]);
            this.point = point;
            this.node = this.link.getDummyNode()
        };
        DummyConnectionPoint.prototype = {
            getInitialPoint: function() {
                return this.point
            },
            getNearestAnchor: function(point, link, incoming) {
                return {
                    index: 0,
                    point: this.point,
                    location: this.point
                }
            },
            getNearestBorderPoint: function(point) {
                return {
                    index: 0,
                    point: point,
                    location: point
                }
            }
        };
        MindFusion.registerClass(DummyConnectionPoint, "MindFusion.Diagramming.DummyConnectionPoint", ConnectionPoint)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Line = MindFusion.Drawing.Line;
        var Dictionary = MindFusion.Collections.Dictionary;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var Path = MindFusion.Drawing.Path;
        var ContainerNode = mdiag.ContainerNode = function(parent) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(ContainerNode, this, [parent]);
            this.captionHeight = 6;
            this.text.fitInBounds = true;
            this.children = [];
            this.margin = 3;
            this.allowAddChildren = true;
            this.allowRemoveChildren = true;
            this.zOrder = [];
            this.clipChildren = true;
            ContainerNode.usingContainerNodes = true;
            this.graphicsContainer.drawCallback = mflayer.createCallback(this.drawChildren, this);
            mdiag.Diagram.suppressSetDirty = false
        };
        ContainerNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(ContainerNode, this, "clone", []);
                copy.captionHeight = this.captionHeight;
                copy.captionBackBrush = this.captionBackBrush;
                copy.shape = this.shape;
                copy.allowAddChildren = this.allowAddChildren;
                copy.allowRemoveChildren = this.allowRemoveChildren;
                copy.margin = this.margin;
                copy.foldIconSize = this.foldIconSize;
                copy.setFoldable(this.getFoldable());
                copy.setFolded(this.getFolded());
                copy.unfoldedSize = this.unfoldedSize;
                copy.shape = this.shape;
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(ContainerNode, this, "toJson", []);
                json.captionHeight = this.captionHeight;
                json.captionBackBrush = this.captionBackBrush;
                json.allowAddChildren = this.allowAddChildren;
                json.allowRemoveChildren = this.allowRemoveChildren;
                json.margin = this.margin;
                json.clipChildren = this.clipChildren;
                json.foldIconSize = this.foldIconSize;
                json.foldable = this.getFoldable();
                json.folded = this.getFolded();
                json.unfoldedSize = this.unfoldedSize;
                json.shape = this.shape;
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(ContainerNode, this, "fromJson", [json]);
                this.captionHeight = json.captionHeight;
                this.captionBackBrush = json.captionBackBrush;
                this.allowAddChildren = json.allowAddChildren;
                this.allowRemoveChildren = json.allowRemoveChildren;
                this.margin = json.margin;
                if (json.clipChildren != undefined) {
                    this.clipChildren = json.clipChildren
                }
                if (json.foldIconSize != undefined) {
                    this.foldIconSize = json.foldIconSize
                }
                this.setFoldable(json.foldable);
                this.setFolded(json.folded);
                if (json.folded) {
                    this.setBounds(new Rect(json.bounds.x, json.bounds.y, json.bounds.width, json.bounds.height))
                }
                if (json.unfoldedSize) {
                    this.unfoldedSize = MindFusion.Drawing.Size.copy(json.unfoldedSize)
                }
                if (json.shape) {
                    this.setShape(json.shape)
                }
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(ContainerNode, this, "loadFromXml", [xmlElement, context]);
                if (this.getText() == "") {
                    this.setText(context.readString("Caption", xmlElement))
                }
                this.captionHeight = context.readFloat("CaptionHeight", xmlElement);
                this.captionBackBrush = context.readBrush("CaptionBackBrush", xmlElement);
                var legacyCaptionFormat = context.readStringFormat("CaptionFormat", xmlElement);
                if (legacyCaptionFormat) {
                    this.setTextAlignment(legacyCaptionFormat.alignment);
                    this.setLineAlignment(legacyCaptionFormat.lineAlignment)
                } else {
                    this.setTextAlignment(context.readInt("TextAlignment", xmlElement));
                    this.setLineAlignment(context.readInt("TextVerticalAlignment", xmlElement))
                }
                this.margin = context.readFloat("Margin", xmlElement);
                this.foldIconSize = context.readFloat("FoldIconSize", xmlElement, null);
                this.folded = context.readBool("Folded", xmlElement);
                this.setFoldable(context.readBool("Foldable", xmlElement));
                this.unfoldedSize = context.readSizeF("UnfoldedSize", xmlElement);
                this.shape = context.readInt("Shape", xmlElement, mdiag.SimpleShape.Rectangle);
                this.allowAddChildren = context.readBool("AllowAddChildren", xmlElement, true);
                this.allowRemoveChildren = context.readBool("AllowRemoveChildren", xmlElement, true);
                this.clipChildren = context.readBool("ClipChildren", xmlElement, true)
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(ContainerNode, this, "saveToXml", [xmlElement, context]);
                context.writeFloat(this.captionHeight, "CaptionHeight", xmlElement);
                context.writeBrush(this.captionBackBrush, "CaptionBackBrush", xmlElement);
                context.writeInt(this.getTextAlignment(), "TextAlignment", xmlElement);
                context.writeInt(this.getLineAlignment(), "TextVerticalAlignment", xmlElement);
                context.writeFloat(this.margin, "Margin", xmlElement);
                if (this.foldIconSize) {
                    context.writeFloat(this.foldIconSize, "FoldIconSize", xmlElement)
                }
                context.writeBool(this.folded, "Folded", xmlElement);
                context.writeBool(this.getFoldable(), "Foldable", xmlElement);
                if (this.unfoldedSize) {
                    context.writeSizeF(this.unfoldedSize, "UnfoldedSize", xmlElement)
                }
                context.writeInt(this.getShape(), "Shape", xmlElement);
                context.writeBool(this.allowAddChildren, "AllowAddChildren", xmlElement);
                context.writeBool(this.allowRemoveChildren, "AllowRemoveChildren", xmlElement);
                context.writeBool(this.clipChildren, "ClipChildren", xmlElement)
            },
            add: function(node) {
                if (node.containsRecursively && node.containsRecursively(this)) {
                    return
                }
                var master = node.getMasterNode();
                if (master) {
                    if (master == this) {
                        return
                    }
                    master.detachSub(node)
                }
                master = this.getMasterNode();
                if (master == node) {
                    return
                }
                if (node.container) {
                    if (node.container == this) {
                        return
                    }
                    node.container.remove(node)
                }
                this.children.push(node);
                node.container = this;
                this.setDiagramDirty()
            },
            remove: function(node, raiseEvent) {
                if (ArrayList.remove(this.children, node)) {
                    this.setDiagramDirty();
                    delete node.container;
                    if (raiseEvent) {
                        this.raiseChildRemoved(node)
                    }
                    if (this.parent) {
                        this.parent.invalidateZOrder()
                    }
                }
            },
            drawChildren: function(context, drawShadows, shadowsOnly, node) {
                if (node.folded) {
                    return
                }
                context.save();
                var clip = node.clipChildren ? node.getContentPath() : null;
                if (clip) {
                    clip.addToContext(context, false);
                    context.clip()
                }
                for (var i = 0, l = node.zOrder.length; i < l; i++) {
                    var child = node.zOrder[i];
                    if (child.getVisible() && !child.getTopLevel()) {
                        child.graphicsContainer.draw(context, drawShadows, shadowsOnly)
                    }
                }
                context.restore()
            },
            hitTest: function(point, threshold, onlyNodes, onlyInteractive) {
                if (this.parent != null && !this.parent.isItemVisible(this)) {
                    return null
                }
                if (!this.folded) {
                    for (var i = this.zOrder.length - 1; i >= 0; i--) {
                        var item = this.zOrder[i];
                        if (onlyNodes && mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                            continue
                        }
                        var hitResult = item.hitTest(point, threshold, onlyNodes, onlyInteractive);
                        if (hitResult != null) {
                            return hitResult
                        }
                    }
                }
                return mflayer.callBaseMethod(ContainerNode, this, "hitTest", [point, threshold, onlyNodes, onlyInteractive])
            },
            getContentPath: function() {
                var rect = this.bounds.clone();
                rect.y += this.captionHeight;
                rect.height -= this.captionHeight;
                var framePath = new Path();
                if (rect.width > 0 && rect.height > 0) {
                    framePath.addRect(rect.x, rect.y, rect.width, rect.height);
                    var rotationAngle = this.getRotationAngle();
                    if (rotationAngle != 0) {
                        var center = this.getCenter();
                        var matrix = new MindFusion.Drawing.Matrix();
                        matrix.rotateAt(rotationAngle, center.x, center.y);
                        framePath.transform = matrix
                    }
                } else {
                    framePath.addRect(this.bounds.x, this.bounds.y, 0, 0)
                }
                return framePath
            },
            getClipChildren: function() {
                return this.clipChildren
            },
            setClipChildren: function(value) {
                if (this.clipChildren !== value) {
                    this.clipChildren = value;
                    this.setDiagramDirty()
                }
            },
            getChildren: function() {
                return this.children
            },
            addToZOrder: function(item) {
                this.zOrder.push(item);
                item.setTopLevel(false)
            },
            updateZOrder: function() {
                this.zOrder = [];
                this.visitChildren();
                this.zOrder.sort(this.sortByIndex)
            },
            sortByIndex: function(a, b) {
                return a.getRuntimeIndex() - b.getRuntimeIndex()
            },
            visitChildren: function() {
                var nodes = this.children;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    this.addToZOrder(nodes[i])
                }
                var links = new Dictionary();
                this.getLinksInScope(links);
                links.forEach(function(link) {
                    if (links.get(link) == 3) {
                        this.addToZOrder(link)
                    }
                }, this)
            },
            getLinksInScope: function(links) {
                var nodes = this.children;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    var outgoing = [];
                    node.getAllOutgoingLinks(outgoing);
                    for (var k = 0; k < outgoing.length; k++) {
                        var count = 0;
                        if (links.contains(outgoing[k])) {
                            count = links.get(outgoing[k])
                        }
                        links.set(outgoing[k], count + 1)
                    }
                    var incoming = [];
                    node.getAllIncomingLinks(incoming);
                    for (var k = 0; k < incoming.length; k++) {
                        var count = 0;
                        if (links.contains(incoming[k])) {
                            count = links.get(incoming[k])
                        }
                        links.set(incoming[k], count + 1)
                    }
                    if (mflayer.isInstanceOfType(ContainerNode, node)) {
                        var childLinks = new Dictionary();
                        node.getLinksInScope(childLinks);
                        childLinks.forEach(function(link) {
                            if (links.contains(link)) {
                                links.set(link, links.get(link) + childLinks.get(link))
                            } else {
                                links.set(link, childLinks.get(link))
                            }
                        })
                    }
                }
                links.forEach(function(link) {
                    if (links.get(link) >= 2) {
                        links.set(link, links.get(link) + 1)
                    }
                })
            },
            getIntersectingItems: function(rect, intersectingItems, multiple, ifIntersect) {
                if (this.folded || !this.parent.isItemVisible(this)) {
                    return
                }
                var rcSel = mdiag.Utils.normalizeRect(rect);
                if (ifIntersect) {
                    for (var i = 0, l = this.zOrder.length; i < l; i++) {
                        var item = this.zOrder[i];
                        if (!item.notInteractive() && item.intersects(rect)) {
                            intersectingItems.push(item);
                            if (!multiple) {
                                return
                            }
                            if (mflayer.isInstanceOfType(ContainerNode, item)) {
                                if (item.intersects(rect)) {
                                    item.getIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                                }
                            }
                        }
                    }
                } else {
                    for (var i = 0, l = this.zOrder.length; i < l; i++) {
                        var item = this.zOrder[i];
                        var rcObjRect = item.getRotatedBounds();
                        if (!item.notInteractive() && rcSel.contains(rcObjRect)) {
                            intersectingItems.push(item);
                            if (!multiple) {
                                return
                            }
                            if (mflayer.isInstanceOfType(ContainerNode, item)) {
                                if (item.intersects(rect)) {
                                    item.getIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                                }
                            }
                        }
                    }
                }
            },
            countIntersectingItems: function(rect, intersectingItems, multiple, ifIntersect) {
                if (this.folded || !this.parent.isItemVisible(this)) {
                    return
                }
                var count = 0;
                var rcSel = mdiag.Utils.normalizeRect(rect);
                if (ifIntersect) {
                    for (var i = 0, l = this.zOrder.length; i < l; i++) {
                        var item = this.zOrder[i];
                        if (!item.notInteractive() && item.intersects(rect)) {
                            count += 1;
                            if (mflayer.isInstanceOfType(ContainerNode, item)) {
                                if (item.intersects(rect)) {
                                    count += item.countIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                                }
                            }
                        }
                    }
                } else {
                    for (var i = 0, l = this.zOrder.length; i < l; i++) {
                        var item = this.zOrder[i];
                        var rcObjRect = item.getRotatedBounds();
                        if (!item.notInteractive() && rcSel.contains(rcObjRect)) {
                            count += 1;
                            if (mflayer.isInstanceOfType(ContainerNode, item)) {
                                if (item.intersects(rect)) {
                                    count += item.countIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                                }
                            }
                        }
                    }
                }
            },
            containsPoint: function(point) {
                var bounds = this.getRotatedBounds();
                if (!bounds.containsPoint(point)) {
                    return false
                }
                if (mdiag.Utils.pointInPolygon(point, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(point)) {
                    return true
                }
                return false
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var p = [];
                p.push(this.bounds.topLeft());
                p.push(this.bounds.topRight());
                p.push(this.bounds.bottomRight());
                p.push(this.bounds.bottomLeft());
                mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.bounds), this.rotationAngle);
                return p
            },
            updateCanvasElements: function() {
                var content = this.graphicsContainer.content = [];
                var stroke = this.getEffectiveStroke();
                var thickness = this.getEffectiveStrokeThickness();
                var dashStyle = this.getEffectiveStrokeDashStyle();
                var brush = this.getEffectiveBrush();
                var params = {
                    brush: brush,
                    phase: EffectPhase.BeforeFill
                };
                this.applyEffects(content, params);
                if (params.brush) {
                    brush = params.brush
                }
                this.graphicsContainer.rotationAngle = this.rotationAngle;
                this.graphicsContainer.pivot = this.bounds.center();
                var rect = this.bounds.clone();
                var frame = rect;
                if (this.shape == mdiag.SimpleShape.RoundedRectangle) {
                    var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                    var cornerRadius = mm * 2.5;
                    frame = new Path();
                    frame.addRoundRect(rect, cornerRadius)
                }
                var back = frame.clone();
                back.pen = null;
                back.brush = brush;
                back.shadow = this.createShadow();
                content.push(back);
                if (this.captionBackBrush) {
                    var captionFill = rect.clone();
                    captionFill.height = this.captionHeight;
                    captionFill.brush = this.captionBackBrush;
                    captionFill.pen = null;
                    if (this.shape == mdiag.SimpleShape.RoundedRectangle) {
                        var clipped = new MindFusion.Drawing.Container();
                        clipped.clip = frame;
                        clipped.content.push(captionFill);
                        content.push(clipped)
                    } else {
                        content.push(captionFill)
                    }
                }
                this.applyEffects(content, {
                    phase: EffectPhase.AfterFill
                });
                if (this.captionHeight > 0 && this.captionHeight < rect.height) {
                    var y = rect.y + this.captionHeight;
                    var line = new Line(rect.x, y, rect.right(), y);
                    line.setPen(stroke);
                    line.strokeThickness = thickness;
                    line.strokeDashStyle = dashStyle;
                    if (this.shape == mdiag.SimpleShape.RoundedRectangle && (y < cornerRadius || y > rect.height - cornerRadius)) {
                        line.clipPath = frame
                    }
                    content.push(line)
                }
                rect = rect.clone();
                rect.height = this.captionHeight;
                if (this.folder) {
                    rect.width -= this.captionHeight
                }
                this.text.setBounds(rect, 0);
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.ignoreTransform = this.rotationAngle != 0;
                content.push(this.text);
                frame.pen = stroke;
                frame.strokeThickness = thickness;
                frame.strokeDashStyle = dashStyle;
                frame.brush = null;
                content.push(frame);
                this.addManipulatorVisuals(content);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            setShape: function(value) {
                if (this.shape != value) {
                    this.shape = value;
                    this.invalidate()
                }
            },
            getShape: function() {
                if (this.shape === undefined) {
                    return mdiag.SimpleShape.Rectangle
                }
                return this.shape
            },
            getEditRect: function(point) {
                var rect = this.bounds.clone();
                rect.height = this.captionHeight;
                if (this.rotationAngle == 0) {
                    return rect
                } else {
                    var matrix = this.rotateRect(this.bounds.clone());
                    return matrix.transformRect(rect)
                }
            },
            setCaptionHeight: function(value) {
                if (this.captionHeight !== value) {
                    this.captionHeight = value;
                    this.invalidate()
                }
            },
            getCaptionHeight: function() {
                return this.captionHeight
            },
            setCaptionBackBrush: function(value) {
                if (this.captionBackBrush !== value) {
                    this.captionBackBrush = value;
                    this.invalidate()
                }
            },
            getCaptionBackBrush: function() {
                return this.captionBackBrush
            },
            addNodes: function(nodes) {
                var nodeAdded = false;
                if (nodes) {
                    var addedNodes = [];
                    ArrayList.forEach(nodes, function(node) {
                        if (node.container != this) {
                            this.add(node);
                            if (node.container == this) {
                                nodeAdded = true;
                                addedNodes.push(node)
                            }
                        }
                    }, this);
                    if (nodeAdded) {
                        this.resizeToFitChildren()
                    }
                    ArrayList.forEach(addedNodes, function(node) {
                        this.raiseChildAdded(node)
                    }, this)
                }
                return nodeAdded
            },
            containsRecursively: function(node) {
                return node.container == this || node.container && this.containsRecursively(node.container)
            },
            onDropOver: function(item) {
                if (item.container == this) {
                    return true
                }
                var newNodes = [];
                if (mflayer.isInstanceOfType(mdiag.Selection, item)) {
                    var selection = item;
                    if (this.selected) {
                        return false
                    }
                    ArrayList.forEach(selection.nodes, function(node) {
                        if (!ArrayList.contains(this.children, node)) {
                            newNodes.push(node)
                        }
                    }, this)
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                        var node = item;
                        if (!ArrayList.contains(this.children, node)) {
                            if (node.container == this) {
                                return true
                            }
                            newNodes.push(node)
                        }
                    }
                }
                if (this.allowAddChildren && newNodes.length > 0) {
                    this.parent.onStartInteraction(this);
                    if (this.addNodes(newNodes)) {
                        return true
                    }
                }
                return false
            },
            visitNodes: function(point, visitNode, relatedItem) {
                if (!this.folded && this.parent != null && this.parent.isItemVisible(this)) {
                    for (var i = this.zOrder.length - 1; i >= 0; i--) {
                        var node = this.zOrder[i];
                        if (mflayer.isInstanceOfType(mdiag.DiagramNode, node)) {
                            if (relatedItem == node) {
                                continue
                            }
                            if (node != null && this.parent.isItemInteractive(node) && node.containsPoint(point)) {
                                if (mflayer.isInstanceOfType(mdiag.ContainerNode, node)) {
                                    var handledByChild = node.visitNodes(point, visitNode, relatedItem);
                                    if (handledByChild) {
                                        return true
                                    }
                                }
                                var handled = visitNode(node, relatedItem);
                                if (handled) {
                                    return true
                                }
                            }
                        }
                    }
                }
                return false
            },
            onDragOver: function(item) {
                ContainerNode.containerHit = true;
                if (!this.allowAddChildren) {
                    return false
                }
                var args = new mdiag.NodeEventArgs({
                    node: item,
                    container: this
                });
                this.parent.raiseEvent(mdiag.Events.containerChildAdding, args);
                if (args.getCancel()) {
                    return false
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item) || mflayer.isInstanceOfType(mdiag.Selection, item)) {
                    this.parent.invalidate();
                    return true
                }
            },
            onDragOut: function(item) {
                this.parent.updateContainersZOrder();
                this.parent.invalidate()
            },
            getContentBounds: function(includeLinks) {
                var bounds = null;
                var links = new Dictionary();
                ArrayList.forEach(this.children, function(node) {
                    bounds = bounds ? bounds.union(node.getRotatedBounds()) : node.getRotatedBounds();
                    if (includeLinks) {
                        ArrayList.forEach(node.getAllLinks(), function(link) {
                            if (!links.contains(link)) {
                                links.set(link, 1)
                            } else {
                                links.set(link, links.get(link) + 1)
                            }
                        })
                    }
                });
                if (includeLinks) {
                    links.forEach(function(link, counter) {
                        if (counter == 2) {
                            bounds = bounds.union(link.getBounds())
                        }
                    })
                }
                return bounds
            },
            getFoldedBounds: function() {
                var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                var foldedRect = this.bounds.clone();
                foldedRect.height = this.captionHeight;
                foldedRect.width = 50 * mm;
                return foldedRect
            },
            resizeToFitChildren: function(allowShrink, margin) {
                var rect = this.getContentBounds(true);
                if (!rect) {
                    return
                }
                if (margin === undefined) {
                    margin = this.margin
                }
                rect = rect.inflate(margin);
                rect.y -= this.captionHeight;
                rect.height += this.captionHeight;
                if (!allowShrink) {
                    rect = rect.union(this.bounds)
                }
                this.setBoundsWithRules(rect, mdiag.DiagramMediator.LinkRules);
                if (this.container) {
                    this.container.onChildModified(this, 0)
                }
            },
            onChildModified: function(node, handle) {
                if (handle == 8) {
                    var ctrBounds = this.bounds;
                    var childBounds = node.getRotatedBounds();
                    var singleNode = !node.getSelected() || node.parent == null || node.parent.selection.nodes.length == 1;
                    if (singleNode && !ctrBounds.contains(childBounds) && !ctrBounds.intersectsWith(childBounds)) {
                        if (this.allowRemoveChildren) {
                            this.remove(node, true)
                        }
                    } else {
                        if (!singleNode && node.getSelected()) {
                            var selectionBounds = node.parent.selection.bounds;
                            if (this.allowRemoveChildren && !ctrBounds.contains(selectionBounds) && !selectionBounds.intersectsWith(ctrBounds)) {
                                this.remove(node, true)
                            }
                        }
                    }
                }
                var updateBounds = !node.getSelected() || node.parent == null || node == node.parent.selection.nodes[node.parent.selection.nodes.length - 1];
                if (updateBounds) {
                    this.resizeToFitChildren()
                }
            },
            getFoldable: function() {
                return this.folder ? true : false
            },
            setFoldable: function(value) {
                var foldable = this.getFoldable();
                if (foldable == value) {
                    return
                }
                if (value) {
                    this.folder = new mdiag.Folder(this);
                    this.addManipulator(this.folder)
                } else {
                    this.removeManipulator(this.folder);
                    delete this.folder
                }
                this.invalidate()
            },
            getFolded: function() {
                return this.folded ? true : false
            },
            setFolded: function(value) {
                if (this.getFolded() == value) {
                    return
                }
                if (value) {
                    this.doFold()
                } else {
                    this.doUnfold()
                }
            },
            getFoldIconSize: function() {
                return this.foldIconSize
            },
            setFoldIconSize: function(value) {
                if (this.foldIconSize != value) {
                    this.foldIconSize = value;
                    if (this.folder) {
                        this.folder.updateContent();
                        this.folder.updateLocation()
                    }
                    this.invalidate()
                }
            },
            doFold: function() {
                this.unfoldedSize = this.bounds.getSize();
                this.deselectContainedItems();
                this.folded = true;
                this.setBoundsWithRules(this.getFoldedBounds(), mdiag.DiagramMediator.LinkRules);
                this.updateExternalLinks();
                if (this.folder) {
                    this.folder.updateContent()
                }
            },
            doUnfold: function() {
                this.folded = false;
                var rect = new Rect(this.bounds.x, this.bounds.y, this.unfoldedSize.width, this.unfoldedSize.height);
                this.setBoundsWithRules(rect, mdiag.DiagramMediator.LinkRules);
                this.updateAllLinks();
                if (this.folder) {
                    this.folder.updateContent()
                }
            },
            deselectContainedItems: function() {
                ArrayList.forEach(this.children, function(node) {
                    node.setSelected(false);
                    var links = this.getDescendantLinks();
                    ArrayList.forEach(links, function(link) {
                        link.setSelected(false)
                    }, this);
                    if (node.children) {
                        ArrayList.forEach(node.children, function(child) {
                            if (mflayer.isInstanceOfType(ContainerNode, child)) {
                                child.deselectContainedItems()
                            }
                            child.setSelected(false)
                        }, this)
                    }
                }, this)
            },
            getDescendantNodes: function() {
                var nodes = [];
                ArrayList.forEach(this.children, function(child) {
                    if (mflayer.isInstanceOfType(ContainerNode, child)) {
                        nodes = nodes.concat(child.getDescendantNodes())
                    }
                    nodes.push(child)
                }, this);
                return nodes
            },
            getDescendantLinks: function() {
                var links = [];
                var nodes = this.getDescendantNodes();
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var incoming = [];
                    nodes[i].getAllIncomingLinks(incoming);
                    for (var k = 0, m = incoming.length; k < m; k++) {
                        if (ArrayList.indexOf(nodes, incoming[k].origin) > -1) {
                            links.push(incoming[k])
                        }
                    }
                    var outgoing = [];
                    nodes[i].getAllOutgoingLinks(outgoing);
                    for (var k = 0, m = outgoing.length; k < m; k++) {
                        if (ArrayList.indexOf(nodes, outgoing[k].destination) > -1) {
                            links.push(outgoing[k])
                        }
                    }
                }
                return links
            },
            updateAllLinks: function() {
                ArrayList.forEach(this.children, function(node) {
                    var links = [];
                    ContainerNode.getLinksToContainedNodes(links, node);
                    ArrayList.forEach(links, function(link) {
                        link.updatePosFromOrgAndDest()
                    });
                    if (node.updateAllLinks) {
                        node.updateAllLinks()
                    }
                }, this)
            },
            updateExternalLinks: function() {
                ArrayList.forEach(this.children, function(node) {
                    var links = [];
                    ContainerNode.getLinksToContainedNodes(links, node);
                    ArrayList.forEach(links, function(link) {
                        if (link.getOrigin().container != this || link.getDestination().container != this) {
                            link.updatePosFromOrgAndDest()
                        }
                    }, this);
                    if (node.updateExternalLinks) {
                        node.updateExternalLinks()
                    }
                }, this)
            },
            getAllowAddChildren: function() {
                return this.allowAddChildren
            },
            setAllowAddChildren: function(value) {
                if (this.allowAddChildren !== value) {
                    this.allowAddChildren = value;
                    this.setDiagramDirty()
                }
            },
            getAllowRemoveChildren: function() {
                return this.allowRemoveChildren
            },
            setAllowRemoveChildren: function(value) {
                if (this.allowRemoveChildren !== value) {
                    this.allowRemoveChildren = value;
                    this.setDiagramDirty()
                }
            },
            getUnfoldedSize: function() {
                if (this.unfoldedSize === undefined) {
                    this.unfoldedSize = this.bounds.getSize()
                }
                return this.unfoldedSize
            },
            onRemove: function() {
                mflayer.callBaseMethod(ContainerNode, this, "onRemove", []);
                if (this.children) {
                    ArrayList.forEach(this.children, function(child) {
                        delete child.container
                    })
                }
            },
            raiseChildAdded: function(child) {
                if (!this.parent) {
                    return
                }
                var args = new mdiag.NodeEventArgs({
                    node: child,
                    container: this
                });
                this.parent.raiseEvent(mdiag.Events.containerChildAdded, args);
                return args.getHandled()
            },
            raiseChildRemoved: function(child) {
                if (!this.parent) {
                    return
                }
                var args = new mdiag.NodeEventArgs({
                    node: child,
                    container: this
                });
                this.parent.raiseEvent(mdiag.Events.containerChildRemoved, args);
                return args.getHandled()
            },
            raiseFolded: function() {
                if (!this.parent) {
                    return
                }
                var args = new mdiag.NodeEventArgs({
                    node: this,
                    container: this
                });
                this.parent.raiseEvent(mdiag.Events.containerFolded, args);
                return args.getHandled()
            },
            raiseUnfolded: function() {
                if (!this.parent) {
                    return
                }
                var args = new mdiag.NodeEventArgs({
                    node: this,
                    container: this
                });
                this.parent.raiseEvent(mdiag.Events.containerUnfolded, args);
                return args.getHandled()
            },
            resolveInheritedStyle: function(check, theme) {
                var nodeStyle = theme.styles["std:ContainerNode"];
                if (nodeStyle) {
                    if (check.apply(nodeStyle)) {
                        return nodeStyle
                    }
                }
                return mflayer.callBaseMethod(ContainerNode, this, "resolveInheritedStyle", [check, theme])
            },
            getChildLinks: function() {
                var childLinks = [];
                var links = new Dictionary();
                this.getLinksInScope(links);
                links.forEach(function(link) {
                    if (links.get(link) == 3) {
                        childLinks.push(link)
                    }
                }, this);
                return childLinks
            },
            toGraph: function(simple, keepGroups, hierarchy) {
                return mdiag.LayoutUtils.toGraph(simple, keepGroups, hierarchy, this.children, this.links ? this.links : this.getChildLinks(), this)
            },
            arrange: function(layout) {
                this.links = this.getChildLinks();
                var result = mdiag.LayoutUtils.arrange(layout, this);
                delete this.links;
                this.resizeToFitChildren(true, layout.margins);
                return result
            },
            arrangeAnimated: function(layout, duration, animationType, easingType) {
                this.links = this.getChildLinks();
                animationType = animationType || 0;
                duration = duration || 500;
                easingType = easingType || 0;
                var result = mdiag.LayoutUtils.arrange(layout, this, {
                    animationType: animationType,
                    duration: duration,
                    easingType: easingType
                });
                return result
            },
            arrangeAnimatedComplete: function(layout) {
                delete this.links;
                this.resizeToFitChildren(true, layout.margins)
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(ContainerNode, this, "saveState", []);
                state.captionHeight = this.captionHeight;
                state.captionBackBrush = this.captionBackBrush;
                state.allowAddChildren = this.allowAddChildren;
                state.allowRemoveChildren = this.allowRemoveChildren;
                state.margin = this.margin;
                state.foldIconSize = this.foldIconSize;
                state.foldable = this.getFoldable();
                state.folded = this.folded;
                state.unfoldedSize = this.unfoldedSize || this.bounds.getSize();
                state.children = ArrayList.clone(this.children);
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(ContainerNode, this, "restoreState", [state]);
                this.captionHeight = state.captionHeight;
                this.captionBackBrush = state.captionBackBrush;
                this.allowAddChildren = state.allowAddChildren;
                this.allowRemoveChildren = state.allowRemoveChildren;
                this.margin = state.margin;
                this.unfoldedSize = state.unfoldedSize;
                this.foldIconSize = state.foldIconSize;
                this.setFoldable(state.foldable);
                this.setFolded(state.folded);
                ArrayList.forEach(this.children, function(child) {
                    this.remove(child)
                }, this);
                ArrayList.forEach(state.children, function(child) {
                    this.add(child)
                }, this)
            },
            init: function() {
                if (!mdiag.ContainerNodeBuilder) {
                    mdiag.ContainerNodeBuilder = new MindFusion.Builder(ContainerNode.prototype, null, this)
                } else {
                    mdiag.ContainerNodeBuilder.setInstance(this)
                }
                return mdiag.ContainerNodeBuilder
            }
        };
        ContainerNode.With = function(diagram) {
            if (!mdiag.ContainerNodeBuilder) {
                mdiag.ContainerNodeBuilder = new MindFusion.Builder(ContainerNode.prototype, diagram)
            } else {
                mdiag.ContainerNodeBuilder.setInstance(null)
            }
            return mdiag.ContainerNodeBuilder
        };
        mdiag.ContainerNodeBuilder = null;
        ContainerNode.getLinksToContainedNodes = function(externalLinks, node) {
            node.getAllIncomingLinks(externalLinks);
            node.getAllOutgoingLinks(externalLinks);
            if (node.getLinksToContainedNodes) {
                return
            }
            if (node.attachedNodes) {
                ArrayList.forEach(node.getAttachedNodes(), function(child) {
                    ContainerNode.getLinksToContainedNodes(externalLinks, child)
                })
            }
        };
        ContainerNode.getFoldedContainer = function(node) {
            var container = node.container;
            if (container) {
                if (container.getFolded()) {
                    return container
                }
                return ContainerNode.getFoldedContainer(container)
            }
            return null
        };
        MindFusion.registerClass(ContainerNode, "MindFusion.Diagramming.ContainerNode", mdiag.DiagramNode)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Line = MindFusion.Drawing.Line;
        var Rect = MindFusion.Drawing.Rect;
        var DeleteButton = mdiag.DeleteButton = function(node) {
            mflayer.initializeBase(DeleteButton, this, [node]);
            this.updateContent();
            this.updateLocation()
        };
        DeleteButton.prototype = {
            updateLocation: function() {
                var iconRect = this.getRect();
                this.x = iconRect.x;
                this.y = iconRect.y
            },
            onClick: function(mousePosition) {
                var rect = this.getRotatedRect();
                if (!rect.containsPoint(mousePosition)) {
                    return
                }
                var node = this.node;
                node.parent.deleteItem(node)
            },
            hitTest: function(mousePosition) {
                return this.getRotatedRect().containsPoint(mousePosition)
            },
            getRect: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var rect = node.bounds.clone();
                var size = node.getEffectiveFontSize();
                var captionSize = node.getCaptionHeight ? node.getCaptionHeight() : size + mm * 2;
                return new Rect(size < 5 * mm ? rect.right() - 2.5 * mm - size / 2 : rect.right() - size, rect.y + captionSize / 2 - size / 2, size, size)
            },
            getRotatedRect: function() {
                var rect = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var p = [];
                    p.push(rect.topLeft());
                    p.push(rect.topRight());
                    p.push(rect.bottomRight());
                    p.push(rect.bottomLeft());
                    mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                    var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                    var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                    var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                    return Rect.fromLTRB(minX, minY, maxX, maxY)
                }
                return rect
            },
            updateContent: function() {
                var node = this.node;
                var pen = node.getEffectiveTextColor();
                var strokeThickness = node.getEffectiveStrokeThickness();
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var rect = this.getRect();
                rect.x = rect.y = 0;
                var mainDiagonal = new Line(rect.x + mm, rect.y + mm, rect.right() - mm, rect.bottom() - mm);
                mainDiagonal.pen = pen;
                mainDiagonal.strokeThickness = strokeThickness;
                this.content.push(mainDiagonal);
                var secDiagonal = new Line(rect.right() - mm, rect.y + mm, rect.x + mm, rect.bottom() - mm);
                secDiagonal.pen = pen;
                secDiagonal.strokeThickness = strokeThickness;
                this.content.push(secDiagonal)
            }
        };
        MindFusion.registerClass(DeleteButton, "MindFusion.Diagramming.DeleteButton", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Font = MindFusion.Drawing.Font;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Set = MindFusion.Collections.Set;
        var Vector = MindFusion.Drawing.Vector;
        var Size = MindFusion.Drawing.Size;
        var Text = MindFusion.Drawing.Text;
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var Diagram = mdiag.Diagram = function(element) {
            mflayer.initializeBase(Diagram, this, [element]);
            this.mouseInputDispatcher = new mdiag.MouseInputDispatcher(this);
            this.keyboardInputDispatcher = new mdiag.KeyboardInputDispatcher(this);
            this.factory = new mdiag.Factory(this);
            this.eventHandlers = mflayer.eventHandlerList();
            this.dummy = new mdiag.DummyNode(this);
            this.laneGrid = new MindFusion.Diagramming.Lanes.Grid(this);
            this.lastMouseUp = new Date();
            this.doubleClick = false;
            this.leftButtonDownPos = new Point(0, 0);
            this.leftButtonDownPosDev = new Point(0, 0);
            this.rightButtonDownPos = new Point(0, 0);
            this.rightButtonDownPosDev = new Point(0, 0);
            this.itemTestForDoubleClick = null;
            this.lastCursorPos = new Point(0, 0);
            this.lastClick = new Date();
            this.enabled = true;
            this.items = [];
            this.nodes = [];
            this.links = [];
            this.autoSnapDistance = 20;
            this.selection = new mdiag.Selection(this);
            this.activeItem = null;
            this.modificationStart = mdiag.ModificationStart.SelectedOnly;
            this.autoHandlesItem = null;
            this.allowMultipleResize = false;
            this.shapeLibraryLocation = "";
            this.backBrush = "#FFFFFF";
            this.shapeBrush = "#FFFFFF";
            this.shapePen = "#000000";
            this.linkBrush = "#FFFFFF";
            this.linkPen = "#000000";
            this.linkShape = mdiag.LinkShape.Polyline;
            this.linkSegments = 1;
            this.allowSelfLoops = true;
            this.handleBrush = "#FFFFFF";
            this.adjustmentHandlesSize = 2;
            this.showDisabledHandles = true;
            this.setDefaultShape("Rectangle");
            this.setLinkHeadShape("Arrow");
            this.linkBaseShape = null;
            this.linkHeadShapeSize = 5;
            this.linkBaseShapeSize = 5;
            this.linkTextStyle = mdiag.LinkTextStyle.Center;
            this.delKeyAction = mdiag.DelKeyAction.DeleteSelectedItems;
            this.linkRouter = new mdiag.Router(this);
            this.routeLinks = false;
            this.routeMargin = 8;
            this.showAnchors = mdiag.ShowAnchors.Auto;
            this.autoAnchorsNode = null;
            this.showGrid = false;
            this.alignToGrid = true;
            this.gridColor = "#8c8c96";
            this.gridSizeX = 4;
            this.gridSizeY = 4;
            this.gridStyle = mdiag.GridStyle.Points;
            this.gridOffsetX = 0;
            this.gridOffsetY = 0;
            this.gridPointSize = 1.5;
            this.backgroundImageAlign = MindFusion.Drawing.ImageAlign.TopLeft;
            this.setBehavior(mdiag.Behavior.LinkShapes);
            this.expandOnIncoming = false;
            this.preventDefaultTouch = true;
            this.nodeEffects = [];
            this.linkCrossings = mdiag.LinkCrossings.Straight;
            this.crossingRadius = 1.5;
            this.linkHitDistance = 0;
            this.roundedLinksRadius = 2;
            this.autoResize = mdiag.AutoResize.RightAndDown;
            this.scrollZoneSize = 8;
            this.autoScrollAmount = 0;
            this.autoScroll = true;
            this.autoScrDX = 0;
            this.autoScrDY = 0;
            this.freeFormAttractDistance = 8;
            this.autoCloseDistance = Number.MAX_VALUE;
            this.freeFormTargets = ["Rectangle", "Decision", "Ellipse"];
            this.setMagnifierShape("Circle");
            this.magnifierEnabled = false;
            this.magnifierFactor = 150;
            this.magnifierWidth = 30;
            this.magnifierHeight = 30;
            this.magnifierFrameThickness = 1;
            this.magnifierShading = true;
            this.magnifierFrameColor = "black";
            this.magnifierSecondaryFrameColor = "gray";
            this.shadowsStyle = mdiag.ShadowsStyle.OneLevel;
            this.modifierKeyActions = new mdiag.ModifierKeyActions();
            this.setLeftButtonActions(mdiag.MouseButtonActions.Draw);
            this.setMiddleButtonActions(mdiag.MouseButtonActions.None);
            this.setRightButtonActions(mdiag.MouseButtonActions.Cancel);
            this.undoManager = null;
            this.images = [];
            this.svgs = [];
            this.registerXmlTypes();
            this.setDirty(false)
        };
        Diagram.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(Diagram, this, "initialize");
                var canvasElement = this.get_element();
                this.scrollDelegate = mflayer.createDelegate(this, this.onScroll);
                mflayer.addHandlers(canvasElement.parentNode, {
                    scroll: this.scrollDelegate
                });
                this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                mflayer.addHandlers(window, {
                    resize: this.resizeDelegate
                });
                this.createFocusable();
                this.mouseHandler = new mdiag.MouseEventHandler(this);
                this.mouseHandler.attachHandlers();
                this.touchHandler = new mdiag.TouchEventHandler(this);
                this.touchHandler.attachHandlers();
                this.keyboardHandler = new mdiag.KeyboardEventHandler(this);
                this.keyboardHandler.attachHandlers();
                this.raiseEvent(mdiag.Events.controlLoaded)
            },
            dispose: function() {
                this.clearAll();
                mflayer.clearHandlers(this.get_element());
                if (this.get_element()) {
                    mflayer.removeHandler(this.get_element().parentNode, "scroll", this.scrollDelegate)
                }
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(Diagram, this, "dispose")
            },
            get_focusElement: function() {
                return this.focusDiv || this.get_element()
            },
            createFocusable: function() {
                if (this.focusDiv) {
                    document.body.removeChild(this.focusDiv)
                }
                this.focusDiv = document.createElement("DIV");
                this.focusDiv.id = this.get_element().id + "_focusable";
                this.focusDiv.style.width = "0px";
                this.focusDiv.style.height = "0px";
                this.focusDiv.style.position = "absolute";
                this.focusDiv.tabIndex = 9999;
                document.body.appendChild(this.focusDiv)
            },
            updateFocusable: function(e) {
                if (this.focusDiv) {
                    var pos = mdiag.Utils.getClientPos(e);
                    this.focusDiv.style.left = pos.x + "px";
                    this.focusDiv.style.top = pos.y + "px";
                    this.focusDiv.focus();
                    e.preventDefault()
                }
            },
            registerForSubmit: function(id) {
                var field = document.getElementById(id);
                if (field) {
                    var form = field.form;
                    if (form) {
                        form.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: id
                        })))
                    }
                }
            },
            registerXmlTypes: function() {
                Diagram.registerItemClass(mdiag.DiagramLink, "std:DiagramLink", 2);
                Diagram.registerItemClass(mdiag.ShapeNode, "std:ShapeNode", 1);
                Diagram.registerItemClass(mdiag.TableNode, "std:TableNode", 1);
                Diagram.registerItemClass(mdiag.ContainerNode, "std:ContainerNode", 3);
                Diagram.registerItemClass(mdiag.SvgNode, "std:SvgNode", 2);
                Diagram.registerItemClass(mdiag.FreeFormNode, "std:FreeFormNode", 1);
                Diagram.registerItemClass(mdiag.GlassEffect, "std:GlassEffect", 1);
                Diagram.registerItemClass(mdiag.AeroEffect, "std:AeroEffect", 1);
                Diagram.registerItemClass(mdiag.Lanes.Header, "std:Header", 1)
            },
            getFactory: function() {
                return this.factory
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            },
            removeEventListener: function(eventName, handler) {
                mflayer.removeHandler(this, eventName, handler)
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler != null) {
                    handler(this, args)
                }
            },
            prepareScriptEvent: function(eventName, script) {
                if (!script || script == "") {
                    return
                }
                var fn = new Function("sender", "args", "return " + script + "(sender, args)");
                this.addEventListener(eventName, fn)
            },
            drawForeground: function() {
                if (this.autoHandlesItem != null) {
                    this.autoHandlesItem.drawHandles(this.context)
                }
                var selectedItems = this.selection.items;
                for (var i = 0; i < selectedItems.length; i++) {
                    var item = selectedItems[i];
                    item.drawHandles(this.context)
                }
            },
            resetVirtualScroll: function() {
                var canvas = this.get_element();
                if (this.virtualScroll && !this.scroller) {
                    mflayer.clearHandlers(canvas.parentNode);
                    var bounds = mflayer.getBounds(canvas.parentNode);
                    var w = bounds.width;
                    var h = bounds.height;
                    if (h != 0) {
                        canvas.parentNode._mf_originalHeight = h
                    }
                    canvas.parentNode.style.overflow = "";
                    canvas.style.position = "absolute";
                    canvas.style.zIndex = 1;
                    canvas.width = Math.min(w - 1 - this.getScrollbarSize(1), this.bounds.width * this.scale);
                    canvas.height = Math.min(h - 1 - this.getScrollbarSize(0), this.bounds.height * this.scale);
                    var scroller = document.createElement("div");
                    scroller.style.width = (w - 1) + "px";
                    scroller.style.height = (h - 1) + "px";
                    scroller.style.position = "absolute";
                    scroller.style.overflow = "auto";
                    this.scroller = scroller;
                    var inner = document.createElement("div");
                    inner.style.position = "absolute";
                    this.innerScroller = inner;
                    scroller.appendChild(inner);
                    canvas.parentNode.appendChild(scroller);
                    mflayer.addHandlers(scroller, {
                        scroll: mflayer.createDelegate(this, this.onScroll)
                    })
                } else {
                    if (!this.virtualScroll && this.scroller) {
                        canvas.style.zIndex = "";
                        canvas.style.position = "";
                        mflayer.clearHandlers(this.scroller);
                        canvas.parentNode.style.overflow = "auto";
                        canvas.parentNode.removeChild(this.scroller);
                        delete this.scroller;
                        delete this.innerScroller;
                        mflayer.addHandlers(canvas.parentNode, {
                            scroll: mflayer.createDelegate(this, this.onScroll)
                        })
                    }
                }
                this.updateCanvasSize()
            },
            recalcVirtualScroll: function() {
                if (this.scroller) {
                    var canvas = this.get_element();
                    var bounds = mflayer.getBounds(canvas.parentNode);
                    var w = bounds.width;
                    var h = bounds.height;
                    if (h == 0) {
                        h = canvas.parentNode._mf_originalHeight
                    }
                    if (h == 0) {
                        h = this.bounds.height * this.scale
                    }
                    canvas.width = Math.min(w, this.bounds.width * this.scale);
                    canvas.height = Math.min(h, this.bounds.height * this.scale);
                    this.scroller.style.width = w + "px";
                    this.scroller.style.height = h + "px";
                    this.updateCanvasSize()
                }
            },
            setEnabled: function(value) {
                this.enabled = value
            },
            getEnabled: function() {
                return this.enabled
            },
            setAllowInplaceEdit: function(value) {
                this.allowInplaceEdit = value
            },
            getAllowInplaceEdit: function() {
                return this.allowInplaceEdit
            },
            setDelKeyAction: function(value) {
                this.delKeyAction = value
            },
            getDelKeyAction: function() {
                return this.delKeyAction
            },
            setBackBrush: function(value) {
                if (this.backBrush != value) {
                    this.backBrush = value;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getBackBrush: function() {
                return this.backBrush
            },
            getEffectiveBackBrush: function() {
                if (this.backBrush) {
                    return this.backBrush
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasBrush);
                if (style) {
                    var brush = style.getBackBrush();
                    if (brush) {
                        return brush
                    }
                }
                return "white"
            },
            resolveEffectiveStyle: function(check) {
                if (this.style && check.apply(this.style)) {
                    return this.style
                }
                var theme = this.theme;
                if (theme) {
                    var themeStyle = theme.styles["std:Diagram"];
                    if (themeStyle) {
                        return themeStyle
                    }
                }
                return null
            },
            getNodeEffects: function() {
                if (!this.nodeEffects) {
                    this.nodeEffects = []
                }
                return this.nodeEffects
            },
            getEffectiveNodeEffects: function() {
                if (this.nodeEffects) {
                    return this.nodeEffects
                }
                var style = this.resolveEffectiveStyle(mdiag.Style.prototype.hasNodeEffects);
                if (style) {
                    var effects = style.getNodeEffects();
                    if (effects) {
                        return effects
                    }
                }
                return []
            },
            setDefaultShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.defaultShape !== value) {
                    this.defaultShape = value;
                    this.setDirty(true)
                }
            },
            getDefaultShape: function() {
                return this.defaultShape
            },
            setFreeFormTargets: function(value) {
                this.freeFormTargets = value
            },
            getFreeFormTargets: function() {
                return this.freeFormTargets
            },
            setAutoCloseDistance: function(value) {
                this.autoCloseDistance = value
            },
            getAutoCloseDistance: function() {
                return this.autoCloseDistance
            },
            setFreeFormAttractDistance: function(value) {
                this.freeFormAttractDistance = value
            },
            getFreeFormAttractDistance: function() {
                return this.freeFormAttractDistance
            },
            setShapeBrush: function(value) {
                if (this.shapeBrush !== value) {
                    this.shapeBrush = value;
                    this.setDirty(true)
                }
            },
            getShapeBrush: function() {
                return this.shapeBrush
            },
            setShapePen: function(value) {
                if (this.shapePen !== value) {
                    this.shapePen = value;
                    this.setDirty(true)
                }
            },
            getShapePen: function() {
                return this.shapePen
            },
            setLinkBrush: function(value) {
                if (this.linkBrush !== value) {
                    this.linkBrush = value;
                    this.setDirty(true)
                }
            },
            getLinkBrush: function() {
                return this.linkBrush
            },
            setLinkPen: function(value) {
                if (this.linkPen !== value) {
                    this.linkPen = value;
                    this.setDirty(true)
                }
            },
            getLinkPen: function() {
                return this.linkPen
            },
            setLinkShape: function(value) {
                if (!value) {
                    value = mdiag.LinkShape.Bezier
                }
                if (this.linkShape !== value) {
                    this.linkShape = value;
                    if (this.linkShape == mdiag.LinkShape.Cascading && this.linkSegments == 1) {
                        this.linkSegments = 2
                    }
                    this.setDirty(true)
                }
            },
            getLinkShape: function() {
                return this.linkShape
            },
            setLinkSegments: function(value) {
                if (!value) {
                    value = 1
                }
                if (this.linkSegments == value || value <= 0) {
                    return
                }
                this.linkSegments = value;
                if (this.linkShape == mdiag.LinkShape.Cascading && this.linkSegments == 1) {
                    this.linkSegments = 2
                }
                this.setDirty(true)
            },
            getLinkSegments: function() {
                return this.linkSegments
            },
            setLinkHeadShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.linkHeadShape !== value) {
                    this.linkHeadShape = value;
                    this.setDirty(true)
                }
            },
            getLinkHeadShape: function() {
                return this.linkHeadShape
            },
            setLinkBaseShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.linkBaseShape !== value) {
                    this.linkBaseShape = value;
                    this.setDirty(true)
                }
            },
            getLinkBaseShape: function() {
                return this.linkBaseShape
            },
            setLinkHeadShapeSize: function(value) {
                if (this.linkHeadShapeSize !== value) {
                    this.linkHeadShapeSize = value;
                    this.setDirty(true)
                }
            },
            getLinkHeadShapeSize: function() {
                return this.linkHeadShapeSize
            },
            setLinkBaseShapeSize: function(value) {
                if (this.linkBaseShapeSize !== value) {
                    this.linkBaseShapeSize = value;
                    this.setDirty(true)
                }
            },
            getLinkBaseShapeSize: function() {
                return this.linkBaseShapeSize
            },
            setAllowSelfLoops: function(value) {
                if (this.allowSelfLoops != value) {
                    this.allowSelfLoops = value;
                    this.setDirty(true)
                }
            },
            getAllowSelfLoops: function() {
                return this.allowSelfLoops
            },
            setBackgroundImageAlign: function(value) {
                if (this.backgroundImageAlign != value) {
                    this.backgroundImageAlign = value;
                    this.setDirty(true);
                    this.invalidate()
                }
            },
            getBackgroundImageAlign: function() {
                return this.backgroundImageAlign
            },
            setBackgroundImageUrl: function(value) {
                if (value) {
                    if (this.backgroundImageUrl != value) {
                        this.backgroundImageUrl = value;
                        this.backgroundImage = new Image();
                        mflayer.addHandlers(this.backgroundImage, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.backgroundImage.src = value;
                        this.setDirty(true)
                    }
                } else {
                    this.backgroundImageUrl = value;
                    this.backgroundImage = null;
                    this.setDirty(true)
                }
            },
            getBackgroundImageUrl: function() {
                return this.backgroundImageUrl
            },
            setBackgroundImageContent: function(value) {
                if (this.backgroundImageContent != value) {
                    this.backgroundImageContent = value;
                    if (value) {
                        this.backgroundImage = new Image();
                        this.backgroundImage.width = 100;
                        this.backgroundImage.height = 100;
                        var url = "data:image/png;base64," + this.backgroundImageContent;
                        mflayer.addHandlers(this.backgroundImage, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.backgroundImage.src = url;
                        this.setDirty(true)
                    }
                }
            },
            getBackgroundImageContent: function() {
                return this.backgroundImageContent
            },
            getBackgroundImage: function() {
                return this.backgroundImage
            },
            getBackgroundImageSize: function() {
                if (this.backgroundImage) {
                    return new MindFusion.Drawing.Size(this.backgroundImage.width, this.backgroundImage.height)
                }
                return new MindFusion.Drawing.Size(0, 0)
            },
            loadImage: function() {
                this.backgroundImage.loaded = true;
                this.invalidate()
            },
            saveImage: function(image) {
                var index = ArrayList.indexOf(this.images, image);
                if (index == -1) {
                    ArrayList.add(this.images, image)
                }
                return ArrayList.indexOf(this.images, image)
            },
            saveSVG: function(svgString) {
                var index = ArrayList.indexOf(this.svgs, svgString);
                if (index == -1) {
                    ArrayList.add(this.svgs, svgString)
                }
                return ArrayList.indexOf(this.svgs, svgString)
            },
            raiseInitialize: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.initializeNode, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.initializeLink, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseCreated: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodeCreated, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkCreated, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseCreating: function(item, ist) {
                var point = ist.currentPoint.clone();
                var validated = true;
                var shouldCancel = false;
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item,
                        mousePosition: point
                    });
                    this.raiseEvent(mdiag.Events.nodeCreating, e)
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    e = new mdiag.LinkEventArgs({
                        link: item,
                        mousePosition: point
                    });
                    this.raiseEvent(mdiag.Events.linkCreating, e)
                }
                if (e) {
                    validated = !e.getCancel();
                    shouldCancel = e.shouldCancelDrag()
                }
                if (shouldCancel) {
                    ist.cancelNow();
                    validated = false
                }
                return validated
            },
            raiseModifying: function(item, ist) {
                var point = ist.currentPoint.clone();
                var handle = ist.adjustmentHandle.index;
                var validated = true;
                var shouldCancel = false;
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item,
                        mousePosition: point,
                        adjustmentHandle: handle
                    });
                    this.raiseEvent(mdiag.Events.nodeModifying, e)
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    e = new mdiag.LinkEventArgs({
                        link: item,
                        mousePosition: point,
                        adjustmentHandle: handle
                    });
                    this.raiseEvent(mdiag.Events.linkModifying, e)
                }
                if (mflayer.isInstanceOfType(mdiag.Selection, item)) {
                    e = new mdiag.SelectionEventArgs({
                        mousePosition: point,
                        adjustmentHandle: handle
                    });
                    this.raiseEvent(mdiag.Events.selectionModifying, e)
                }
                if (e) {
                    validated = !e.getCancel();
                    shouldCancel = e.shouldCancelDrag()
                }
                if (shouldCancel) {
                    ist.cancelNow();
                    validated = false
                }
                return validated
            },
            raiseDeleting: function(item) {
                var validated = true;
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item
                    });
                    this.raiseEvent(mdiag.Events.nodeDeleting, e)
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    e = new mdiag.LinkEventArgs({
                        link: item
                    });
                    this.raiseEvent(mdiag.Events.linkDeleting, e)
                }
                if (e) {
                    validated = !e.getCancel()
                }
                return validated
            },
            raiseModified: function(item, mousePosition, adjustmentHandle) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodeModified, new mdiag.NodeEventArgs({
                        node: item,
                        mousePosition: mousePosition,
                        adjustmentHandle: adjustmentHandle
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkModified, new mdiag.LinkEventArgs({
                        link: item,
                        mousePosition: mousePosition,
                        adjustmentHandle: adjustmentHandle
                    }))
                }
            },
            raiseTreeExpanded: function(root) {
                this.raiseEvent(mdiag.Events.treeExpanded, new mdiag.NodeEventArgs({
                    node: root
                }))
            },
            raiseTreeCollapsed: function(root) {
                this.raiseEvent(mdiag.Events.treeCollapsed, new mdiag.NodeEventArgs({
                    node: root
                }))
            },
            raiseSelectionMoved: function() {
                var selectedItems = ArrayList.clone(this.selection.items);
                ArrayList.forEach(selectedItems, function(item) {
                    this.raiseModified(item, new Point(0, 0), -1)
                }, this)
            },
            raiseDeleted: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodeDeleted, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkDeleted, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseClicked: function(item, mousePosition, mouseButton) {
                if (item) {
                    return item.raiseClicked(mousePosition, mouseButton)
                } else {
                    var args = new mdiag.DiagramEventArgs({
                        mousePosition: mousePosition,
                        mouseButton: mouseButton
                    });
                    this.raiseEvent(mdiag.Events.clicked, args);
                    return true
                }
            },
            raiseDoubleClicked: function(item, mousePosition, mouseButton) {
                return item.raiseDoubleClicked(mousePosition, mouseButton)
            },
            raiseSelected: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodeSelected, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkSelected, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseDeselected: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodeDeselected, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkDeselected, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseHitTestAdjustmentHandles: function(item, mousePosition) {
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item,
                        mousePosition: mousePosition
                    })
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                        e = new mdiag.LinkEventArgs({
                            link: item,
                            mousePosition: mousePosition
                        })
                    }
                }
                this.raiseEvent(mdiag.Events.hitTestAdjustmentHandles, e);
                return e.getAdjustmentHandle()
            },
            raiseDrawAdjustmentHandles: function(item, context) {
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item,
                        context: context
                    })
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                        e = new mdiag.LinkEventArgs({
                            link: item,
                            context: context
                        })
                    }
                }
                this.raiseEvent(mdiag.Events.drawAdjustmentHandles, e)
            },
            raiseMouseHover: function(item, mousePosition) {
                var none = mdiag.AdjustmentHandles.None;
                var e;
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    e = new mdiag.NodeEventArgs({
                        node: item,
                        mousePosition: mousePosition,
                        adjustmentHandle: none
                    });
                    this.raiseEvent(mdiag.Events.nodePointed, e)
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                        e = new mdiag.LinkEventArgs({
                            link: item,
                            mousePosition: mousePosition,
                            adjustmentHandle: none
                        });
                        this.raiseEvent(mdiag.Events.linkPointed, e)
                    }
                }
            },
            raiseSerializeTag: function(params) {
                var e = new mdiag.SerializeTagEventArgs(params);
                this.raiseEvent(mdiag.Events.serializeTag, e);
                return e.getHandled()
            },
            raiseDeserializeTag: function(params) {
                var e = new mdiag.SerializeTagEventArgs(params);
                this.raiseEvent(mdiag.Events.deserializeTag, e);
                params.tag = e.getTag();
                return e.getHandled()
            },
            raiseTableColumnResizing: function(table, column, mousePosition, mouseButton, shouldCancel) {
                var cell = table.getCell(column, 0);
                var args = new mdiag.CellValidationEventArgs({
                    cell: cell,
                    mouseButton: mouseButton,
                    mousePosition: mousePosition,
                    column: column,
                    row: -1
                });
                this.raiseEvent(mdiag.Events.tableColumnResizing, args);
                shouldCancel.value = args.shouldCancelDrag();
                return !args.getCancel()
            },
            raiseTableColumnResized: function(table, column, mousePosition, mouseButton) {
                var cell = table.getCell(column, 0);
                var args = new mdiag.CellEventArgs({
                    cell: cell,
                    mouseButton: mouseButton,
                    mousePosition: mousePosition,
                    column: column,
                    row: -1
                });
                this.raiseEvent(mdiag.Events.tableColumnResized, args)
            },
            raiseTableRowResizing: function(table, row, mousePosition, mouseButton, shouldCancel) {
                var cell = table.getCell(0, row);
                var args = new mdiag.CellValidationEventArgs({
                    cell: cell,
                    mouseButton: mouseButton,
                    mousePosition: mousePosition,
                    column: -1,
                    row: row
                });
                this.raiseEvent(mdiag.Events.tableRowResizing, args);
                shouldCancel.value = args.shouldCancelDrag();
                return !args.getCancel()
            },
            raiseTableRowResized: function(table, row, mousePosition, mouseButton) {
                var cell = table.getCell(0, row);
                var args = new mdiag.CellValidationEventArgs({
                    cell: cell,
                    mouseButton: mouseButton,
                    mousePosition: mousePosition,
                    column: -1,
                    row: row
                });
                this.raiseEvent(mdiag.Events.tableRowResized, args)
            },
            raiseHeaderResizing: function(header, horizontal) {
                var args = new mdiag.HeaderResizeEventArgs(header, horizontal);
                this.raiseEvent(mdiag.Events.headerStartResizing, args);
                return !args.getCancel()
            },
            raiseHeaderResized: function(header, horizontal) {
                var args = new mdiag.HeaderResizeEventArgs(header, horizontal);
                this.raiseEvent(mdiag.Events.headerResized, args)
            },
            raisePasted: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.raiseEvent(mdiag.Events.nodePasted, new mdiag.NodeEventArgs({
                        node: item
                    }))
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    this.raiseEvent(mdiag.Events.linkPasted, new mdiag.LinkEventArgs({
                        link: item
                    }))
                }
            },
            raiseAnimatedLayoutCompleted: function(item) {
                var args = new mdiag.NodeEventArgs({
                    node: null
                });
                if (item && mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    args.node = item
                }
                this.raiseEvent(mdiag.Events.animatedLayoutCompleted, args)
            },
            onScroll: function() {
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(mdiag.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    this.mouseInputDispatcher.currentController.cancel()
                }
                if (this.showGrid || this.scroller) {
                    this.repaint()
                }
            },
            checkAutoScroll: function(point) {
                var viewport = this.getViewport();
                if (viewport.width > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, -this.scrollZoneSize, 0)
                }
                if (viewport.height > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, 0, -this.scrollZoneSize)
                }
                var scroll = !viewport.containsPoint(point);
                if (scroll) {
                    var scrollAmount = this.autoScrollAmount > 0 ? this.autoScrollAmount : (4 * GraphicsUnit.getMillimeter(this.measureUnit));
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (point.x < viewport.left()) {
                        this.autoScrDX = -scrollAmount
                    }
                    if (point.y < viewport.top()) {
                        this.autoScrDY = -scrollAmount
                    }
                    if (point.x > viewport.right()) {
                        this.autoScrDX = scrollAmount
                    }
                    if (point.y > viewport.bottom()) {
                        this.autoScrDY = scrollAmount
                    }
                    this.onAutoScroll();
                    if (!this.scrollTimeoutId) {
                        var thisObj = this;
                        this.scrollTimeoutId = setInterval(function() {
                            thisObj.onAutoScroll()
                        }, 100)
                    }
                } else {
                    if (this.scrollTimeoutId) {
                        this.stopAutoScroll();
                        this.invalidate()
                    }
                }
                return scroll
            },
            stopAutoScroll: function() {
                if (this.scrollTimeoutId) {
                    clearInterval(this.scrollTimeoutId);
                    delete this.scrollTimeoutId
                }
            },
            onAutoScroll: function() {
                var rcPage = this.getViewport();
                if (this.scroller) {
                    rcPage.width -= this.getScrollbarSize(0);
                    rcPage.height -= this.getScrollbarSize(1)
                }
                var scrX = this.getScrollX(),
                    scrY = this.getScrollY();
                if (rcPage.width < this.bounds.width) {
                    scrX += this.autoScrDX
                }
                if (rcPage.height < this.bounds.height) {
                    scrY += this.autoScrDY
                }
                this.scrollStayInDoc(scrX, scrY, rcPage, this.bounds);
                var currentController = this.mouseInputDispatcher.currentController;
                if (currentController) {
                    currentController.move(this.pointerPosition);
                    if (this.autoResize != mdiag.AutoResize.None) {
                        this.resizeToFitItem(this.mouseInputDispatcher.currentController.modifiedItem)
                    }
                }
                this.invalidate()
            },
            setAutoHandles: function(ptCurr) {
                var item = this.getItemAt(ptCurr, true, true);
                if (item == null && this.autoHandlesItem != null && mflayer.isInstanceOfType(mdiag.DiagramNode, this.autoHandlesItem)) {
                    var node = this.autoHandlesItem;
                    var relativeDistancePoint = mdiag.Utils.distToRectPoint(ptCurr, node.bounds);
                    var distanceSq = mdiag.Utils.DistanceSq(ptCurr, relativeDistancePoint);
                    var bufferZone = this.adjustmentHandlesSize / 2 + 7 * GraphicsUnit.getMillimeter(this.measureUnit);
                    bufferZone *= bufferZone;
                    if (distanceSq <= bufferZone) {
                        item = this.autoHandlesItem
                    }
                }
                this.setAutoHandlesItem(item)
            },
            onContextMenu: function(e) {
                e.preventDefault()
            },
            canResizeLaneHeader: function(point) {
                var headerBounds = Rect.empty;
                var resizedHeader = null;
                var resizingHeaderWidth = false;
                var grid = this.getLaneGrid();
                var header = grid.getHeaderFromPoint(point, headerBounds, new Point(0, 0));
                if (header != null) {
                    var tolerance = 2 * GraphicsUnit.getMillimeter(this.measureUnit);
                    var bottomSide = headerBounds.headerBounds.clone();
                    bottomSide.y = bottomSide.bottom() - tolerance;
                    bottomSide.height = tolerance;
                    var rightSide = headerBounds.headerBounds.clone();
                    rightSide.x = rightSide.right() - tolerance;
                    rightSide.width = tolerance;
                    var resizedHeader = null;
                    var resizingHeaderWidth = false;
                    if (bottomSide.contains(point)) {
                        resizedHeader = header;
                        resizingHeaderWidth = false
                    } else {
                        if (rightSide.contains(point)) {
                            resizedHeader = header;
                            resizingHeaderWidth = true
                        }
                    }
                    if (resizedHeader != null) {
                        return {
                            header: resizedHeader,
                            resizingHeaderWidth: resizingHeaderWidth,
                            headerBounds: headerBounds.headerBounds
                        }
                    }
                }
                return false
            },
            clearTooltip: function() {
                if (this.tooltipTimeoutId) {
                    clearTimeout(this.tooltipTimeoutId)
                }
                if (this.tooltipDiv) {
                    document.body.removeChild(this.tooltipDiv);
                    this.tooltipDiv = null
                }
            },
            trackMouseMovement: function(point) {
                if (this.modificationStart == mdiag.ModificationStart.AutoHandles) {
                    this.setAutoHandles(point)
                }
                if (this.trackMouseHover()) {
                    this.startHoverTimer(point)
                }
                var diag = this.get_element();
                var cursorHint = this.handleMouseMove(point);
                if (cursorHint == MindFusion.Controls.MouseCursors.DontChange) {
                    cursorHint = this.currentBehavior.setMouseCursor(point)
                }
                if (diag != null && this.stopCursorChange != true && cursorHint != MindFusion.Controls.MouseCursors.DontChange) {
                    diag.style.cursor = cursorHint
                }
                var clientPos = this.docToClient(point);
                var clientBounds = mflayer.getBounds(this._element);
                this.tooltipX = clientPos.x + clientBounds.x;
                this.tooltipY = clientPos.y + clientBounds.y;
                this.tooltipPoint = point;
                var thisObj = this;
                this.tooltipTimeoutId = setTimeout(function() {
                    return thisObj.onTooltip()
                }, this.tooltipDelay);
                if (this.magnifierEnabled) {
                    this.magnifyTimeoutId = setTimeout(function() {
                        return thisObj.invalidate()
                    }, 100)
                }
            },
            handleMouseMove: function(pt) {
                var cursorHint = MindFusion.Controls.MouseCursors.DontChange;
                for (var i = this.items.length - 1; i >= 0; i--) {
                    var item = this.items[i];
                    if (!this.isItemInteractive(item)) {
                        continue
                    }
                    var manipulator = item.hitTestManipulators(pt);
                    if (manipulator != null) {
                        if (manipulator.needsMouseMessages(pt)) {
                            manipulator.onMouseMove(pt)
                        }
                        cursorHint = manipulator.setMouseCursor(pt)
                    }
                }
                if (this.getShowLaneGrid() && this.getLaneGrid().allowResizeHeaders) {
                    var data = this.canResizeLaneHeader(pt);
                    if (data) {
                        if (data.resizingHeaderWidth) {
                            cursorHint = MouseCursors.HorizontalResize
                        } else {
                            cursorHint = MouseCursors.VerticalResize
                        }
                    }
                }
                return cursorHint
            },
            buttonMappedTo: function(button, action) {
                var buttonActions = mdiag.MouseButtonActions.None;
                if (button == 0 && this.enabled) {
                    buttonActions = this.leftButtonActions
                }
                if (button == 1 && this.enabled) {
                    buttonActions = this.middleButtonActions
                }
                if (button == 2 && this.enabled) {
                    buttonActions = this.rightButtonActions
                }
                return (buttonActions & action) != 0
            },
            trackMouseHover: function() {
                return mflayer.getHandler(this, "nodePointed") || mflayer.getHandler(this, "linkPointed")
            },
            startHoverTimer: function(mousePosition) {
                if (this.hoverTimeoutId) {
                    clearTimeout(this.hoverTimeoutId);
                    delete this.hoverTimeoutId
                }
                var thisObj = this;
                this.hoverTimeoutId = setTimeout(function() {
                    return thisObj.onHover(mousePosition)
                }, 800)
            },
            onHover: function(mousePosition) {
                if (this.hoverTimeoutId) {
                    clearTimeout(this.hoverTimeoutId);
                    delete this.hoverTimeoutId
                }
                this.raiseMouseHover(this.getItemAt(mousePosition, false), mousePosition)
            },
            onClick: function(position, button) {
                var activeManipulator = this.hitTestManipulators(position);
                if (activeManipulator != null) {
                    activeManipulator.onClick(position);
                    return
                }
                var clickedItem = this.getItemAt(position, true);
                var item = clickedItem;
                if (item && item.getLocked()) {
                    item = this.getItemAt(position, true, true)
                }
                var ctrlKey = this.modifierKeyActions.getKeys(mdiag.ModifierKeyAction.Select, mdiag.Keyboard.state);
                if (button == 0 || this.buttonMappedTo(button, mdiag.MouseButtonActions.Select)) {
                    if (!(ctrlKey) || !this.selection.allowMultipleSelection) {
                        if (!this.selection.itemInSelection(item)) {
                            this.selection.clearInternal()
                        }
                    }
                }
                if (item != null) {
                    if (button == 0 || this.buttonMappedTo(button, mdiag.MouseButtonActions.Select)) {
                        if (ctrlKey && item.getSelected()) {
                            this.selection.removeItem(item)
                        } else {
                            this.selection.addItem(item)
                        }
                    }
                }
                this.raiseClicked(clickedItem, position, button)
            },
            onTooltip: function() {
                var item = this.getItemAt(this.tooltipPoint, true, false);
                if (item && item.tooltip) {
                    var divId = this.get_element().id + "_tooltip";
                    var div = this.tooltipDiv = document.createElement("div");
                    document.body.appendChild(div);
                    div.setAttribute("id", divId);
                    div.innerHTML = item.tooltip;
                    div.style.left = this.tooltipX + 20 + "px";
                    div.style.top = this.tooltipY + "px";
                    div.style.width = "auto";
                    div.style.position = "absolute";
                    div.style.display = "block";
                    div.style.background = "white";
                    div.style.border = "solid 1px";
                    div.style.zIndex = 2
                }
            },
            onMagnify: function() {
                this.invalidate()
            },
            beginEdit: function(item, point) {
                var thisObj = this;
                setTimeout(function() {
                    if (thisObj.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(mdiag.InplaceEditController, thisObj.mouseInputDispatcher.currentController)) {
                        return
                    }
                    var editObject = item;
                    var editPoint = point || thisObj.clientToDoc(thisObj.lastCursorPos);
                    thisObj.mouseInputDispatcher.currentController = new mdiag.InplaceEditController(editObject);
                    thisObj.mouseInputDispatcher.currentController.start(editPoint)
                }, 1)
            },
            getInplaceEditBounds: function(rect) {
                var bounds = new Rect();
                var canvasRect = mdiag.Utils.getBounds(this.get_element());
                this.inplaceEditBounds = new Rect(canvasRect.x - (this.scroller ? this.scroller.scrollLeft : 0) + this.scale * this.bounds.x + this.scale * rect.x, canvasRect.y - (this.scroller ? this.scroller.scrollTop : 0) + this.scale * this.bounds.y + this.scale * rect.y, this.scale * rect.width, this.scale * rect.height);
                var p = this.docToClient(rect.topLeft());
                bounds.x = canvasRect.x + p.x;
                bounds.y = canvasRect.y + p.y;
                bounds.width = this.inplaceEditBounds.width;
                bounds.height = this.inplaceEditBounds.height;
                return bounds
            },
            setInplaceEditBounds: function(rect) {
                var bounds = this.getInplaceEditBounds(rect);
                this.inplaceTextBox.style.left = bounds.x + "px";
                this.inplaceTextBox.style.top = bounds.y + "px";
                this.inplaceTextBox.style.width = bounds.width + "px";
                this.inplaceTextBox.style.height = bounds.height + "px"
            },
            focusInput: function() {
                if (this.inplaceTextBox) {
                    this.inplaceTextBox.focus()
                }
            },
            endEdit: function(accept) {
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(mdiag.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    var point = this.clientToDoc(this.lastCursorPos);
                    if (accept) {
                        this.mouseInputDispatcher.currentController.commit(point)
                    } else {
                        this.mouseInputDispatcher.currentController.cancel(point)
                    }
                    this.mouseInputDispatcher.currentController = null
                }
            },
            onResize: function() {
                this.recalcVirtualScroll();
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(mdiag.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    var point = this.clientToDoc(this.lastCursorPos);
                    var rect = this.mouseInputDispatcher.currentController.inplaceObject.getEditRect(point);
                    this.mouseInputDispatcher.currentController.setInplaceEditBounds(rect)
                }
            },
            getItems: function() {
                return this.items
            },
            getNodes: function() {
                return this.nodes
            },
            getLinks: function() {
                return this.links
            },
            clearAll: function() {
                this.setAutoHandlesItem(null);
                this.selection.clear();
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var item = this.items[0];
                    ArrayList.remove(this.items, item);
                    this.onItemRemoved(item)
                }
                this.nodes = [];
                this.links = [];
                if (this.undoManager != null) {
                    this.undoManager = new mdiag.UndoManager(this)
                }
            },
            addItem: function(item) {
                if (this.getUndoEnabled()) {
                    this.undoManager.startComposite();
                    this.undoManager.executeCommand(new mdiag.AddItemCommand(this, item));
                    this.undoManager.endComposite()
                } else {
                    this.doAddItem(item)
                }
            },
            doAddItem: function(item) {
                if (ArrayList.contains(this.items, item)) {
                    return
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.nodes.push(item);
                    item.updateAnchorVisibility4()
                } else {
                    if (!ArrayList.contains(this.items, item.origin) && (item.origin == null || !mflayer.isInstanceOfType(mdiag.DummyNode, item.origin))) {
                        return
                    }
                    if (!ArrayList.contains(this.items, item.destination) && (item.destination == null || !mflayer.isInstanceOfType(mdiag.DummyNode, item.destination))) {
                        return
                    }
                    this.links.push(item);
                    item.updateNodeCollections()
                }
                if (item.getZIndex() === undefined) {
                    item.setZIndex(this.items.length)
                }
                ArrayList.add(this.items, item);
                this.onItemAdded(item);
                if (this.autoResize != mdiag.AutoResize.None) {
                    this.resizeToFitItem(item)
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                    if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                        if (item.origin.container != null || item.destination.container != null) {
                            this.invalidateZOrder()
                        }
                    }
                }
                this.raiseEvent(mdiag.Events.itemAdded, new mdiag.ItemEventArgs({
                    item: item
                }));
                this.setDirty(true)
            },
            removeItem: function(item) {
                if (!item) {
                    return
                }
                if (this.getUndoEnabled()) {
                    this.undoManager.startComposite();
                    this.undoManager.executeCommand(new mdiag.RemoveItemCommand(this, item));
                    this.undoManager.endComposite()
                } else {
                    this.doRemoveItem(item, true)
                }
            },
            doRemoveItem: function(item) {
                if (this.autoHandlesItem == item) {
                    this.setAutoHandlesItem(null)
                }
                this.selection.removeItem(item);
                this.removeFromCollection(item);
                this.removeFromZOrder(item);
                if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    this.invalidateZOrder()
                }
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    item.deleteLinks();
                    item.detach();
                    if (item.obstacle) {
                        this.routeLinksAt([item.getBounds()])
                    }
                } else {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                        item.resetCrossings();
                        item.destinationConnection.removeLinkFromNode();
                        item.originConnection.removeLinkFromNode()
                    }
                }
                item.onRemove();
                if (this.autoResize != mdiag.AutoResize.None) {
                    this.sizeDocForItems()
                }
                this.raiseEvent(mdiag.Events.itemRemoved, new mdiag.ItemEventArgs({
                    item: item
                }));
                this.setDirty(true)
            },
            removeFromCollection: function(item) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    ArrayList.remove(this.nodes, item)
                } else {
                    ArrayList.remove(this.links, item)
                }
            },
            removeFromZOrder: function(item) {
                ArrayList.remove(this.items, item);
                this.onItemRemoved(item)
            },
            getLinksFromZ: function(lessThan, z) {
                var linksFromZ = [];
                var zOrder = this.getZOrder();
                if (z > zOrder.length) {
                    z = zOrder.length
                }
                if (lessThan) {
                    for (var i = z - 1; i >= 0; i--) {
                        var item = zOrder[i].item;
                        if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                            linksFromZ.push(item)
                        }
                    }
                } else {
                    for (var i = z + 1; i < zOrder.length; i++) {
                        var item = zOrder[i].item;
                        if (mflayer.isInstanceOfType(mdiag.DiagramLink, item)) {
                            linksFromZ.push(item)
                        }
                    }
                }
                return linksFromZ
            },
            deleteItem: function(item) {
                if (item != null && this.raiseDeleting(item)) {
                    this.removeItem(item)
                }
            },
            deleteSelection: function() {
                this.startCompositeOperation();
                var selectedLinks = this.selection.links;
                for (var i = 0, l = selectedLinks.length; i < l; i++) {
                    if (this.selection.links.indexOf(selectedLinks[0]) > -1) {
                        this.deleteItem(selectedLinks[0])
                    }
                }
                var selectedNodes = this.selection.nodes;
                for (var i = 0, l = selectedNodes.length; i < l; i++) {
                    if (this.selection.nodes.indexOf(selectedNodes[0]) > -1) {
                        this.deleteItem(selectedNodes[0])
                    }
                }
                this.commitCompositeOperation()
            },
            getItemsAt: function(point) {
                return zOrderedItemsAt(this.items, point)
            },
            getNodesAt: function(point) {
                return zOrderedItemsAt(this.nodes, point)
            },
            getLinksAt: function(point) {
                return zOrderedItemsAt(this.links, point)
            },
            getItemAt: function(point, skipInvisible, skipLocked) {
                return topmostItemAt(this.items, point, skipInvisible, skipLocked)
            },
            getNodeAt: function(point, skipInvisible, skipLocked) {
                return topmostItemAt(this.nodes, point, skipInvisible, skipLocked, true)
            },
            getLinkAt: function(point, skipInvisible, skipLocked) {
                return topmostItemAt(this.links, point, skipInvisible, skipLocked)
            },
            getHandleAt: function(point, skipAuto) {
                var selectedItems = this.selection.items;
                for (var i = 0; i < selectedItems.length; i++) {
                    var handle = selectedItems[i].handleAtPoint(point);
                    if (handle != null) {
                        return handle
                    }
                }
                if (skipAuto) {
                    return null
                }
                if (this.autoHandlesItem != null) {
                    var handle = this.autoHandlesItem.handleAtPoint(point);
                    if (handle != null) {
                        return handle
                    }
                }
            },
            getNearestNode: function(point, maxDistance, ignored, onlyInteractive) {
                var nearest = Number.MAX_VALUE;
                var nearestNode = null;
                for (var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i];
                    if (onlyInteractive && node.notInteractive()) {
                        continue
                    }
                    if (node === ignored) {
                        continue
                    }
                    if (mdiag.Utils.checkIntersect(point, node.bounds, maxDistance)) {
                        var dist = mdiag.Utils.minDistToRect(point, node.bounds);
                        if (dist < nearest) {
                            nearestNode = node;
                            nearest = dist
                        }
                    }
                }
                return nearestNode
            },
            getIntersectingItems: function(rect, intersectingItems, multiple, ifIntersect) {
                var rcSel = mdiag.Utils.normalizeRect(rect);
                if (ifIntersect) {
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        var item = this.items[i];
                        if (!item.getTopLevel()) {
                            continue
                        }
                        if (!item.notInteractive() && item.intersects(rect)) {
                            intersectingItems.push(item);
                            if (!multiple) {
                                return
                            }
                            if (mflayer.isInstanceOfType(mdiag.ContainerNode, item)) {
                                item.getIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                            }
                        }
                    }
                } else {
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        var item = this.items[i];
                        if (!item.getTopLevel()) {
                            continue
                        }
                        var rcObjRect = item.getRotatedBounds();
                        if (!item.notInteractive() && rcSel.contains(rcObjRect)) {
                            intersectingItems.push(item);
                            if (!multiple) {
                                return
                            }
                            if (mflayer.isInstanceOfType(mdiag.ContainerNode, item)) {
                                item.getIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                            }
                        }
                    }
                }
            },
            countIntersectingItems: function(rect, intersectingItems, multiple, ifIntersect) {
                var count = 0;
                var rcSel = mdiag.Utils.normalizeRect(rect);
                if (ifIntersect) {
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        var item = this.items[i];
                        if (!item.getTopLevel()) {
                            continue
                        }
                        if (!item.notInteractive() && item.intersects(rect)) {
                            count += 1;
                            if (mflayer.isInstanceOfType(mdiag.ContainerNode, item)) {
                                count += item.countIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                            }
                        }
                    }
                } else {
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        var item = this.items[i];
                        if (!item.getTopLevel()) {
                            continue
                        }
                        var rcObjRect = item.getRotatedBounds();
                        if (!this.items[i].notInteractive() && rcSel.contains(rcObjRect)) {
                            count += 1;
                            if (mflayer.isInstanceOfType(mdiag.ContainerNode, item)) {
                                count += item.countIntersectingItems(rect, intersectingItems, multiple, ifIntersect)
                            }
                        }
                    }
                }
            },
            updateContainersZOrder: function() {
                if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        this.items[i].setTopLevel(true)
                    }
                    for (var i = 0, l = this.nodes.length; i < l; i++) {
                        if (mflayer.isInstanceOfType(MindFusion.Diagramming.ContainerNode, this.nodes[i])) {
                            this.nodes[i].updateZOrder()
                        }
                    }
                }
            },
            isItemVisible: function(item) {
                if (!item.getVisible()) {
                    return false
                }
                if (!item.topLevel) {
                    if (mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramNode, item)) {
                        if (MindFusion.Diagramming.ContainerNode.getFoldedContainer(item) != null) {
                            return false
                        }
                    }
                    if (mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramLink, item)) {
                        var c1 = MindFusion.Diagramming.ContainerNode.getFoldedContainer(item.origin);
                        if (c1 != null) {
                            var c2 = MindFusion.Diagramming.ContainerNode.getFoldedContainer(item.destination);
                            if (c1 == c2) {
                                return false
                            }
                        }
                    }
                }
                return true
            },
            isItemInteractive: function(item) {
                if (item.notInteractive()) {
                    return false
                }
                return true
            },
            getType: function() {
                return this.constructor.__typeName
            },
            preparePostback: function(sender, args) {
                var field = document.getElementById(args.id);
                if (field) {
                    field.value = mdiag.Utils.escapeHtml(this.toJson())
                }
            },
            toJson: function() {
                var parentDiv = this.get_element().parentNode;
                var bounds = mflayer.getBounds(parentDiv);
                var json = {
                    version: 1,
                    id: this.get_element().id,
                    width: bounds.width,
                    height: bounds.height,
                    diagramBounds: this.bounds,
                    enabled: this.enabled,
                    measureUnit: this.measureUnit,
                    allowInplaceEdit: this.allowInplaceEdit,
                    font: this.font,
                    defaultShape: this.defaultShape ? this.defaultShape.id : "RoundRect",
                    backBrush: this.backBrush,
                    shapePen: this.shapePen,
                    shapeBrush: this.shapeBrush,
                    linkShape: this.linkShape,
                    linkPen: this.linkPen,
                    linkSegments: this.linkSegments,
                    linkBrush: this.linkBrush,
                    linkBaseShape: (this.linkBaseShape) ? this.linkBaseShape.id : null,
                    linkHeadShape: (this.linkHeadShape) ? this.linkHeadShape.id : null,
                    linkBaseShapeSize: this.linkBaseShapeSize,
                    linkHeadShapeSize: this.linkHeadShapeSize,
                    linkHitDistance: this.linkHitDistance,
                    scrollLeft: this.get_element().parentNode.scrollLeft,
                    scrollTop: this.get_element().parentNode.scrollTop,
                    routeLinks: this.routeLinks,
                    dynamicLinks: this.dynamicLinks,
                    roundedLinks: this.roundedLinks,
                    roundedLinksRadius: this.roundedLinksRadius,
                    linkCrossings: this.linkCrossings,
                    crossingRadius: this.crossingRadius,
                    zoomFactor: this.zoomFactor,
                    virtualScroll: this.virtualScroll,
                    showAnchors: this.showAnchors,
                    modificationStart: this.modificationStart,
                    delKeyAction: this.delKeyAction,
                    gridStyle: this.gridStyle,
                    gridColor: this.gridColor,
                    gridSizeX: this.gridSizeX,
                    gridSizeY: this.gridSizeY,
                    gridOffsetX: this.gridOffsetX,
                    gridOffsetY: this.gridOffsetY,
                    gridPointSize: this.gridPointSize,
                    showGrid: this.showGrid,
                    alignToGrid: this.alignToGrid,
                    magnifierEnabled: this.magnifierEnabled,
                    magnifierShape: (this.magnifierShape) ? this.magnifierShape.id : null,
                    magnifierFactor: this.magnifierFactor,
                    magnifierWidth: this.magnifierWidth,
                    magnifierHeight: this.magnifierHeight,
                    magnifierFrameThickness: this.magnifierFrameThickness,
                    magnifierShading: this.magnifierShading,
                    magnifierFrameColor: this.magnifierFrameColor,
                    magnifierSecondaryFrameColor: this.magnifierSecondaryFrameColor,
                    undoEnabled: this.getUndoEnabled(),
                    behavior: this.behavior,
                    expandOnIncoming: this.expandOnIncoming,
                    adjustmentHandlesSize: this.adjustmentHandlesSize,
                    showDisabledHandles: this.showDisabledHandles,
                    autoResize: this.autoResize,
                    autoScroll: this.autoScroll,
                    scrollZoneSize: this.scrollZoneSize,
                    autoScrollAmount: this.autoScrollAmount,
                    allowMultipleResize: this.allowMultipleResize,
                    allowUnconnectedLinks: this.allowUnconnectedLinks,
                    linkTextStyle: this.linkTextStyle,
                    tag: this.getTag() || null,
                    style: this.style ? this.style.toJson() : null,
                    theme: this.theme ? this.theme.toJson() : null,
                    backgroundImageUrl: this.backgroundImageUrl,
                    backgroundImageAlign: this.backgroundImageAlign,
                    shadowOffsetX: this.getShadowOffsetX(),
                    shadowOffsetY: this.getShadowOffsetY(),
                    shadowsStyle: this.getShadowsStyle(),
                    items: this.serializeItems(),
                    laneGrid: this.laneGrid.toJson(),
                    showLaneGrid: this.showLaneGrid,
                    images: this.images,
                    svgs: this.svgs,
                    tooltipDelay: this.tooltipDelay,
                    shapeLibraryLocation: this.shapeLibraryLocation,
                    autoCloseDistance: this.autoCloseDistance,
                    freeFormAttractDistance: this.freeFormAttractDistance,
                    freeFormTargets: this.freeFormTargets,
                    allowSelfLoops: this.allowSelfLoops
                };
                var effects = [];
                for (var i = 0, l = this.nodeEffects.length; i < l; i++) {
                    if (this.nodeEffects[i] != null) {
                        effects.push(this.nodeEffects[i].toJson())
                    }
                }
                json.effects = effects;
                if (this.backgroundImageContent) {
                    json.backgroundImageIndex = this.saveImage(this.backgroundImageContent)
                }
                return mflayer.toJson(json)
            },
            serializeItems: function() {
                var result = [];
                this.assignInstanceIds();
                for (var i = 0, l = this.nodes.length; i < l; i++) {
                    var json = this.nodes[i].toJson();
                    result.push(json)
                }
                for (var i = 0, l = this.links.length; i < l; i++) {
                    var json = this.links[i].toJson();
                    result.push(json)
                }
                return result
            },
            assignInstanceIds: function() {
                var instanceId = 0;
                for (var i = 0, l = this.nodes.length; i < l; i++) {
                    this.nodes[i].instanceId = instanceId++
                }
                for (var i = 0, l = this.links.length; i < l; i++) {
                    this.links[i].instanceId = instanceId++
                }
            },
            fromJson: function(json) {
                this.clearAll();
                if (json > "") {
                    var obj = mflayer.fromJson(json);
                    if (obj.shapeLibraryLocation != null && obj.shapeLibraryLocation != "") {
                        this.setShapeLibraryLocation(obj.shapeLibraryLocation)
                    }
                    this.bounds = new MindFusion.Drawing.Rect(obj.diagramBounds.x, obj.diagramBounds.y, obj.diagramBounds.width, obj.diagramBounds.height);
                    this.setEnabled(obj.enabled);
                    this.font = obj.font ? Font.copy(obj.font) : null;
                    this.setDefaultShape(obj.defaultShape);
                    this.setVirtualScroll(obj.virtualScroll);
                    this.setMeasureUnit(obj.measureUnit);
                    this.updateScale();
                    this.setAllowInplaceEdit(obj.allowInplaceEdit);
                    this.setDelKeyAction(obj.delKeyAction);
                    this.setRouteLinks(obj.routeLinks);
                    if (obj.linkRouter == "GridRouter") {
                        this.linkRouter = new mdiag.GridRouter(this)
                    }
                    this.setZoomFactor(obj.zoomFactor);
                    this.setShowAnchors(obj.showAnchors);
                    this.setModificationStart(obj.modificationStart);
                    this.setGridStyle(obj.gridStyle);
                    this.setGridColor(obj.gridColor);
                    this.setGridSizeX(obj.gridSizeX);
                    this.setGridSizeY(obj.gridSizeY);
                    this.setGridOffsetX(obj.gridOffsetX || 0);
                    this.setGridOffsetY(obj.gridOffsetY || 0);
                    if (obj.autoResize !== undefined) {
                        this.setAutoResize(obj.autoResize)
                    }
                    if (obj.autoScroll !== undefined) {
                        this.setAutoScroll(obj.autoScroll)
                    }
                    this.setScrollZoneSize(obj.scrollZoneSize || 8);
                    this.setAutoScrollAmount(obj.autoScrollAmount || 0);
                    if (obj.gridPointSize !== undefined) {
                        this.setGridPointSize(obj.gridPointSize)
                    }
                    this.setShowGrid(obj.showGrid);
                    this.setAlignToGrid(obj.alignToGrid);
                    this.setBackBrush(obj.backBrush);
                    this.setShapePen(obj.shapePen);
                    this.setShapeBrush(obj.shapeBrush);
                    this.setLinkPen(obj.linkPen);
                    this.setLinkBrush(obj.linkBrush);
                    this.setLinkShape(obj.linkShape);
                    this.setLinkSegments(obj.linkSegments);
                    this.setLinkBaseShape(obj.linkBaseShape);
                    this.setLinkHeadShape(obj.linkHeadShape);
                    this.setLinkBaseShapeSize(obj.linkBaseShapeSize);
                    this.setLinkHeadShapeSize(obj.linkHeadShapeSize);
                    this.setLinkHitDistance(obj.linkHitDistance);
                    if (obj.magnifierEnabled !== undefined) {
                        this.setMagnifierEnabled(obj.magnifierEnabled)
                    }
                    if (obj.magnifierShape !== undefined) {
                        this.setMagnifierShape(obj.magnifierShape)
                    }
                    if (obj.magnifierFactor !== undefined) {
                        this.setMagnifierFactor(obj.magnifierFactor)
                    }
                    if (obj.magnifierWidth !== undefined) {
                        this.setMagnifierWidth(obj.magnifierWidth)
                    }
                    if (obj.magnifierHeight !== undefined) {
                        this.setMagnifierHeight(obj.magnifierHeight)
                    }
                    if (obj.magnifierFrameThickness !== undefined) {
                        this.setMagnifierFrameThickness(obj.magnifierFrameThickness)
                    }
                    if (obj.magnifierFrameDashStops !== undefined) {
                        MindFusion.Drawing.Gradient.tm = obj.magnifierFrameDashStops
                    }
                    if (obj.magnifierShading !== undefined) {
                        this.setMagnifierShading(obj.magnifierShading)
                    }
                    if (obj.magnifierFrameColor !== undefined) {
                        this.setMagnifierFrameColor(obj.magnifierFrameColor)
                    }
                    if (obj.magnifierSecondaryFrameColor !== undefined) {
                        this.setMagnifierSecondaryFrameColor(obj.magnifierSecondaryFrameColor)
                    }
                    if (obj.undoEnabled !== undefined) {
                        this.setUndoEnabled(obj.undoEnabled)
                    }
                    if (obj.customNodeType !== undefined) {
                        this.setCustomNodeType(obj.customNodeType)
                    }
                    if (obj.customLinkType !== undefined) {
                        this.setCustomLinkType(obj.customLinkType)
                    }
                    if (obj.behavior !== undefined) {
                        this.setBehavior(obj.behavior)
                    }
                    if (obj.expandOnIncoming !== undefined) {
                        this.expandOnIncoming = obj.expandOnIncoming
                    }
                    if (obj.adjustmentHandlesSize !== undefined) {
                        this.adjustmentHandlesSize = obj.adjustmentHandlesSize
                    }
                    if (obj.showDisabledHandles !== undefined) {
                        this.showDisabledHandles = obj.showDisabledHandles
                    }
                    if (obj.dynamicLinks !== undefined) {
                        this.dynamicLinks = obj.dynamicLinks
                    }
                    if (obj.roundedLinks !== undefined) {
                        this.roundedLinks = obj.roundedLinks
                    }
                    if (obj.roundedLinksRadius !== undefined) {
                        this.roundedLinksRadius = obj.roundedLinksRadius
                    }
                    if (obj.linkCrossings !== undefined) {
                        this.linkCrossings = obj.linkCrossings
                    }
                    if (obj.crossingRadius !== undefined) {
                        this.crossingRadius = obj.crossingRadius
                    }
                    if (obj.allowMultipleResize !== undefined) {
                        this.allowMultipleResize = obj.allowMultipleResize
                    }
                    if (obj.allowUnconnectedLinks !== undefined) {
                        this.allowUnconnectedLinks = obj.allowUnconnectedLinks
                    }
                    if (obj.linkTextStyle !== undefined) {
                        this.linkTextStyle = obj.linkTextStyle
                    }
                    if (obj.autoCloseDistance !== undefined) {
                        this.autoCloseDistance = obj.autoCloseDistance
                    }
                    if (obj.freeFormAttractDistance !== undefined) {
                        this.freeFormAttractDistance = obj.freeFormAttractDistance
                    }
                    if (obj.freeFormTargets !== undefined) {
                        this.freeFormTargets = obj.freeFormTargets
                    }
                    if (obj.tag !== undefined) {
                        this.tag = obj.tag
                    }
                    if (obj.style) {
                        this.style = new mdiag.Style(false);
                        this.style.fromJson(obj.style)
                    }
                    if (obj.theme) {
                        this.theme = new mdiag.Theme();
                        this.theme.fromJson(obj.theme)
                    }
                    this.nodeEffects = [];
                    if (obj.effects) {
                        for (var i = 0, l = obj.effects.length; i < l; i++) {
                            var type = mflayer.parseType(obj.effects[i].typeName);
                            if (type) {
                                var effect = new type(this);
                                effect.fromJson(obj.effects[i]);
                                this.nodeEffects.push(effect)
                            }
                        }
                    }
                    if (obj.images != undefined) {
                        this.images = obj.images
                    }
                    if (obj.svgs != undefined) {
                        this.svgs = obj.svgs
                    }
                    if (obj.backgroundImageAlign !== undefined) {
                        this.backgroundImageAlign = obj.backgroundImageAlign
                    }
                    if (obj.backgroundImageUrl !== undefined) {
                        this.setBackgroundImageUrl(obj.backgroundImageUrl)
                    }
                    if (obj.backgroundImageIndex != undefined) {
                        this.setBackgroundImageContent(this.images[obj.backgroundImageIndex])
                    }
                    if (obj.shadowOffsetX !== undefined) {
                        this.shadowOffsetX = obj.shadowOffsetX
                    }
                    if (obj.shadowOffsetY !== undefined) {
                        this.shadowOffsetY = obj.shadowOffsetY
                    }
                    if (obj.shadowsStyle !== undefined) {
                        this.shadowsStyle = obj.shadowsStyle
                    }
                    if (obj.tooltipDelay !== undefined) {
                        this.tooltipDelay = obj.tooltipDelay
                    }
                    if (obj.allowSelfLoops !== undefined) {
                        this.allowSelfLoops = obj.allowSelfLoops
                    }
                    this.prepareScriptEvent(mdiag.Events.nodeClicked, obj.nodeClickedScript);
                    this.prepareScriptEvent(mdiag.Events.linkClicked, obj.linkClickedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeCreated, obj.nodeCreatedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeCreating, obj.nodeCreatingScript);
                    this.prepareScriptEvent(mdiag.Events.linkCreated, obj.linkCreatedScript);
                    this.prepareScriptEvent(mdiag.Events.linkCreating, obj.linkCreatingScript);
                    this.prepareScriptEvent(mdiag.Events.nodeModified, obj.nodeModifiedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeModifying, obj.nodeModifyingScript);
                    this.prepareScriptEvent(mdiag.Events.linkModified, obj.linkModifiedScript);
                    this.prepareScriptEvent(mdiag.Events.linkModifying, obj.linkModifyingScript);
                    this.prepareScriptEvent(mdiag.Events.nodeDeleted, obj.nodeDeletedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeDeleting, obj.nodeDeletingScript);
                    this.prepareScriptEvent(mdiag.Events.linkDeleted, obj.linkDeletedScript);
                    this.prepareScriptEvent(mdiag.Events.linkDeleting, obj.linkDeletingScript);
                    this.prepareScriptEvent(mdiag.Events.nodeTextEdited, obj.nodeTextEditedScript);
                    this.prepareScriptEvent(mdiag.Events.linkTextEdited, obj.linkTextEditedScript);
                    this.prepareScriptEvent(mdiag.Events.cellTextEdited, obj.cellTextEditedScript);
                    this.prepareScriptEvent(mdiag.Events.repaint, obj.repaintScript);
                    this.prepareScriptEvent(mdiag.Events.sizeChanged, obj.sizeChangedScript);
                    this.prepareScriptEvent(mdiag.Events.selectionModifying, obj.selectionModifyingScript);
                    this.prepareScriptEvent(mdiag.Events.initializeNode, obj.initializeNodeScript);
                    this.prepareScriptEvent(mdiag.Events.initializeLink, obj.initializeLinkScript);
                    this.prepareScriptEvent(mdiag.Events.treeExpanded, obj.treeExpandedScript);
                    this.prepareScriptEvent(mdiag.Events.treeCollapsed, obj.treeCollapsedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeSelected, obj.nodeSelectedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeDeselected, obj.nodeDeselectedScript);
                    this.prepareScriptEvent(mdiag.Events.linkSelected, obj.linkSelectedScript);
                    this.prepareScriptEvent(mdiag.Events.linkDeselected, obj.linkDeselectedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeDoubleClicked, obj.nodeDoubleClickedScript);
                    this.prepareScriptEvent(mdiag.Events.linkDoubleClicked, obj.linkDoubleClickedScript);
                    this.prepareScriptEvent(mdiag.Events.nodePointed, obj.nodePointedScript);
                    this.prepareScriptEvent(mdiag.Events.linkPointed, obj.linkPointedScript);
                    this.prepareScriptEvent(mdiag.Events.controlLoaded, obj.controlLoadedScript);
                    this.prepareScriptEvent(mdiag.Events.containerFolded, obj.containerFoldedScript);
                    this.prepareScriptEvent(mdiag.Events.containerUnfolded, obj.containerUnfoldedScript);
                    this.prepareScriptEvent(mdiag.Events.containerChildAdded, obj.containerChildAddedScript);
                    this.prepareScriptEvent(mdiag.Events.containerChildRemoved, obj.containerChildRemovedScript);
                    this.prepareScriptEvent(mdiag.Events.containerChildAdding, obj.containerChildAddingScript);
                    this.prepareScriptEvent(mdiag.Events.containerChildRemoving, obj.containerChildRemovingScript);
                    this.prepareScriptEvent(mdiag.Events.drawAdjustmentHandles, obj.drawAdjustmentHandlesScript);
                    this.prepareScriptEvent(mdiag.Events.hitTestAdjustmentHandles, obj.hitTestAdjustmentHandlesScript);
                    this.prepareScriptEvent(mdiag.Events.clicked, obj.clickedScript);
                    this.prepareScriptEvent(mdiag.Events.enterInplaceEditMode, obj.enterInplaceEditScript);
                    this.prepareScriptEvent(mdiag.Events.leaveInplaceEditMode, obj.leaveInplaceEditScript);
                    this.prepareScriptEvent(mdiag.Events.createEditControl, obj.createEditControlScript);
                    this.prepareScriptEvent(mdiag.Events.tableColumnResizing, obj.tableColumnResizingScript);
                    this.prepareScriptEvent(mdiag.Events.tableRowResizing, obj.tableRowResizingScript);
                    this.prepareScriptEvent(mdiag.Events.tableColumnResized, obj.tableColumnResizedScript);
                    this.prepareScriptEvent(mdiag.Events.tableRowResized, obj.tableRowResizedScript);
                    this.prepareScriptEvent(mdiag.Events.nodePasted, obj.nodePastedScript);
                    this.prepareScriptEvent(mdiag.Events.linkPasted, obj.linkPastedScript);
                    this.prepareScriptEvent(mdiag.Events.headerStartResizing, obj.headerStartResizingScript);
                    this.prepareScriptEvent(mdiag.Events.headerResized, obj.headerResizedScript);
                    this.prepareScriptEvent(mdiag.Events.itemAdded, obj.itemAddedScript);
                    this.prepareScriptEvent(mdiag.Events.itemRemoved, obj.itemRemovedScript);
                    if (obj.scrollLeft) {
                        this.get_element().parentNode.scrollLeft = obj.scrollLeft
                    }
                    if (obj.scrollTop) {
                        this.get_element().parentNode.scrollTop = obj.scrollTop
                    }
                    var ordered = [];
                    if (obj.items instanceof Object) {
                        for (var i = 0; i < obj.items.length; i++) {
                            if (obj.items[i]) {
                                if (this.isNodeType(obj.items[i])) {
                                    var item = this.loadItem(obj.items[i], ordered);
                                    ordered[obj.items[i].instanceId] = item;
                                    this.addItem(item);
                                    if (obj.items[i].selected) {
                                        this.selection.addItem(item)
                                    }
                                }
                            }
                        }
                        for (var i = 0; i < obj.items.length; i++) {
                            if (obj.items[i]) {
                                if (this.isLinkType(obj.items[i])) {
                                    var item = this.loadItem(obj.items[i], ordered);
                                    ordered[obj.items[i].instanceId] = item;
                                    this.addItem(item);
                                    if (obj.items[i].selected) {
                                        this.selection.addItem(item)
                                    }
                                }
                            }
                        }
                    }
                    if (obj.laneGrid !== undefined) {
                        this.laneGrid.fromJson(obj.laneGrid)
                    }
                    if (obj.showLaneGrid != undefined) {
                        this.showLaneGrid = obj.showLaneGrid
                    }
                }
                for (var i = 0; i < ordered.length; i++) {
                    ordered[i].onLoad(ordered)
                }
                if (this.onLoad) {
                    this.onLoad()
                }
                this.invalidate();
                this.setDirty(false);
                this.raiseEvent(mdiag.Events.controlLoaded)
            },
            isNodeType: function(jsonObj) {
                var type = mflayer.parseType(jsonObj.__type || jsonObj.type);
                if (!type) {
                    return false
                }
                return mflayer.inheritsFrom(type, mdiag.DiagramNode)
            },
            isLinkType: function(jsonObj) {
                var type = mflayer.parseType(jsonObj.__type || jsonObj.type);
                if (!type) {
                    return false
                }
                return type == mdiag.DiagramLink || mflayer.inheritsFrom(type, mdiag.DiagramLink)
            },
            loadItem: function(obj, items) {
                var type = mflayer.parseType(obj.__type || obj.type);
                if (!type) {
                    return null
                }
                if (mflayer.inheritsFrom(type, mdiag.DiagramNode)) {
                    var node = new type(this);
                    node.fromJson(obj);
                    return node
                }
                if (type == mdiag.DiagramLink || mflayer.inheritsFrom(type, mdiag.DiagramLink)) {
                    var origin = items[obj.origin];
                    var destination = items[obj.destination];
                    var link = new type(this, origin, destination);
                    link.fromJson(obj);
                    return link
                }
                return null
            },
            loadFromXml: function(fileUrl, onLoad, onError) {
                var diagram = this;
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                    diagram.fromXmlDocument(xhr.responseXML);
                    if (onLoad) {
                        onLoad(diagram)
                    }
                };
                xhr.onerror = function() {
                    console.log("Error while getting XML.");
                    if (onError) {
                        onError(diagram)
                    }
                };
                xhr.open("GET", fileUrl);
                xhr.responseType = "document";
                xhr.send()
            },
            saveToXml: function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("POST", url, true);
                xhr.setRequestHeader("Content-Type", "text/xml");
                xhr.send(this.saveToString(mdiag.SaveToStringFormat.Xml))
            },
            loadFromString: function(str) {
                if (str.charAt(0) == "{") {
                    this.fromJson(str)
                } else {
                    var parser = new DOMParser();
                    this.fromXmlDocument(parser.parseFromString(str, "application/xml"))
                }
            },
            saveToString: function(format) {
                if (typeof format == "undefined") {
                    format = mdiag.SaveToStringFormat.Json
                }
                if (format == mdiag.SaveToStringFormat.Xml) {
                    var serializer = new XMLSerializer();
                    return serializer.serializeToString(this.toXmlDocument())
                } else {
                    return this.toJson()
                }
            },
            fromXmlDocument: function(document) {
                this.clearAll();
                var doc = document.documentElement;
                var context = new mdiag.XmlPersistContext(this, document);
                context.fileVersion = parseInt(doc.getAttribute("Version"));
                context.readResources(doc);
                this.loadProperties("Properties", doc, context);
                var loadedBounds = this.bounds;
                this.loadEffects("Effects", doc, context);
                var nodes = doc.getElementsByTagName("Nodes")[0];
                var element = nodes.firstElementChild;
                while (element != null) {
                    var node = context.loadItemFromXml(element);
                    this.addItem(node);
                    element = element.nextElementSibling
                }
                var links = doc.getElementsByTagName("Links")[0];
                var element = links.firstElementChild;
                while (element != null) {
                    var link = context.loadItemFromXml(element);
                    this.addItem(link);
                    element = element.nextElementSibling
                }
                var selectionElement = context.selectSingleNode("Selection", doc);
                if (selectionElement) {
                    var selectedItems = selectionElement.getElementsByTagName("Item");
                    for (var i = 0; i < selectedItems.length; i++) {
                        var element = selectedItems[i];
                        var item = context.readItemReference(element);
                        if (item) {
                            this.selection.addItem(item)
                        }
                    }
                    var activeItem = context.selectSingleNode("ActiveItem", selectionElement);
                    if (activeItem) {
                        this.activeItem = context.readItemReference(activeItem)
                    }
                }
                this.setStyle(context.readStyle("Style", doc));
                this.setTheme(context.readTheme("Theme", doc));
                this.loadView("View", doc, context);
                this.setBounds(loadedBounds)
            },
            toXmlDocument: function() {
                this.assignInstanceIds();
                var xmldoc = document.implementation.createDocument("", "", null);
                var diagramElement = xmldoc.createElement("Diagram");
                diagramElement.setAttribute("Version", "17");
                xmldoc.appendChild(diagramElement);
                var context = new mdiag.XmlPersistContext(this, xmldoc);
                var nodesElement = context.addChildElement("Nodes", diagramElement);
                for (var i = 0; i < this.nodes.length; i++) {
                    context.saveItemToXml(this.nodes[i], nodesElement, "Node")
                }
                var linksElement = context.addChildElement("Links", diagramElement);
                for (var i = 0; i < this.links.length; i++) {
                    context.saveItemToXml(this.links[i], linksElement, "Link")
                }
                this.saveProperties("Properties", diagramElement, context);
                this.saveEffects("Effects", diagramElement, context);
                var selectionElement = context.addChildElement("Selection", diagramElement);
                var selectedItems = this.selection.items;
                for (var i = 0; i < selectedItems.length; i++) {
                    context.writeItemReference(selectedItems[i], "Item", selectionElement)
                }
                context.writeItemReference(this.activeItem, "ActiveItem", selectionElement);
                context.writeStyle(this.style, "Style", diagramElement, "std:DiagramStyle");
                context.writeTheme(this.theme, "Theme", diagramElement);
                context.writeResources(diagramElement);
                this.setDirty(false);
                return xmldoc
            },
            loadProperties: function(elementName, parentElement, context) {
                var element = context.selectSingleNode(elementName, parentElement);
                if (!element) {
                    throw new Error("Unable to load diagram properties.")
                }
                this.setMeasureUnit(context.readInt("MeasureUnit", element));
                if (context.fileVersion > 13) {
                    this.setLinkHeadShape(context.readShape("LinkHeadShape", element));
                    this.setLinkBaseShape(context.readShape("LinkBaseShape", element))
                } else {
                    this.setLinkHeadShape(context.readArrowheadV13("LinkHeadShape", element));
                    this.setLinkBaseShape(context.readArrowheadV13("LinkBaseShape", element))
                }
                this.setLinkHeadShapeSize(context.readFloat("LinkHeadShapeSize", element));
                this.setLinkBaseShapeSize(context.readFloat("LinkBaseShapeSize", element));
                this.alignToGrid = context.readBool("AlignToGrid", element);
                this.showGrid = context.readBool("ShowGrid", element);
                this.gridStyle = context.readInt("GridStyle", element);
                this.gridColor = context.readColor("GridColor", element);
                this.gridSizeX = context.readFloat("GridSizeX", element);
                this.gridSizeY = context.readFloat("GridSizeY", element);
                this.gridOffsetX = context.readFloat("GridOffsetX", element);
                this.gridOffsetY = context.readFloat("GridOffsetY", element);
                this.shadowsStyle = context.readInt("ShadowsStyle", element);
                this.shadowOffsetX = context.readFloat("ShadowOffsetX", element);
                this.shadowOffsetY = context.readFloat("ShadowOffsetY", element);
                this.backgroundImageAlign = context.readInt("ImageAlign", element);
                this.setBackgroundImageUrl(context.readImage("BackgroundImageUrl", element));
                this.setBackgroundImageContent(context.readImage("BackgroundImage", element));
                this.setLinkShape(context.readInt("LinkStyle", element));
                this.setLinkSegments(context.readInt("LinkSegments", element));
                this.bounds = context.readRectangleF("Bounds", element);
                this.nodesExpandable = context.readBool("NodesExpandable", element);
                this.tablesScrollable = context.readBool("TablesScrollable", element);
                this.toolTip = context.readString("ToolTip", element);
                this.font = context.readFont("Font", element);
                if (!this.font) {
                    var fontFamily = context.readString("FontFamily", element);
                    var fontSize = context.readFloat("FontSize", element);
                    if (fontFamily != "" && fontSize > 0) {
                        this.font = new Font(fontFamily, fontSize)
                    }
                }
                this.setDefaultShape(context.readShape("DefaultShape", element));
                this.shapePen = context.readPen("ShapePen", element);
                this.linkPen = context.readPen("LinkPen", element);
                this.setShapeBrush(context.readBrush("ShapeBrush", element));
                this.setLinkBrush(context.readBrush("LinkBrush", element));
                this.setBackBrush(context.readBrush("Brush", element));
                this.allowUnconnectedLinks = context.readBool("AllowUnconnectedLinks", element);
                this.routeLinks = context.readBool("RouteLinks", element);
                this.linkTextStyle = context.readInt("LinkTextStyle", element);
                this.linkText = context.readString("LinkText", element);
                this.shapeText = context.readString("ShapeText", element);
                this.linkCrossings = context.readInt("LinkCrossings", element);
                this.autoSnapDistance = context.readFloat("AutoSnapDistance", element, 20);
                this.tag = context.readTag(this, "Tag", element);
                this.roundedLinks = context.readBool("RoundedLinks", element);
                this.roundedLinksRadius = context.readFloat("RoundedLinksRadius", element);
                this.setShowLaneGrid(context.readBool("EnableLanes", element));
                var laneElement = context.selectSingleNode("Lane", element);
                if (laneElement != null) {
                    this.laneGrid.loadFromXml(laneElement, context)
                }
                this.autoResize = context.readInt("AutoResize", element);
                this.allowSelfLoops = context.readBool("AllowSelfLoops", element, true);
                this.expandOnIncoming = context.readBool("ExpandOnIncoming", element);
                this.showAnchors = context.readInt("ShowAnchors", element, mdiag.ShowAnchors.Auto);
                this.adjustmentHandlesSize = context.readFloat("AdjustmentHandlesSize", element, 2);
                this.showDisabledHandles = context.readBool("ShowDisabledHandles", element, true);
                this.dynamicLinks = context.readBool("DynamicLinks", element);
                this.selection.allowMultipleSelection = context.readBool("AllowMultipleSelection", element)
            },
            saveProperties: function(elementName, parentElement, context) {
                var element = context.addChildElement(elementName, parentElement);
                context.writeShape(this.linkHeadShape, "LinkHeadShape", element);
                context.writeShape(this.linkBaseShape, "LinkBaseShape", element);
                context.writeFloat(this.linkHeadShapeSize, "LinkHeadShapeSize", element);
                context.writeFloat(this.linkBaseShapeSize, "LinkBaseShapeSize", element);
                context.writeBool(this.alignToGrid, "AlignToGrid", element);
                context.writeBool(this.showGrid, "ShowGrid", element);
                context.writeInt(this.gridStyle, "GridStyle", element);
                context.writeColor(this.gridColor, "GridColor", element);
                context.writeFloat(this.gridSizeX, "GridSizeX", element);
                context.writeFloat(this.gridSizeY, "GridSizeY", element);
                context.writeFloat(this.gridOffsetX, "GridOffsetX", element);
                context.writeFloat(this.gridOffsetY, "GridOffsetY", element);
                context.writeInt(this.shadowsStyle, "ShadowsStyle", element);
                context.writeFloat(this.getShadowOffsetX(), "ShadowOffsetX", element);
                context.writeFloat(this.getShadowOffsetY(), "ShadowOffsetY", element);
                context.writeInt(this.linkShape, "LinkStyle", element);
                context.writeInt(this.linkSegments, "LinkSegments", element);
                context.writeRectangleF(this.bounds, "Bounds", element);
                context.writeBool(this.nodesExpandable, "NodesExpandable", element);
                context.writeBool(this.tablesScrollable, "TablesScrollable", element);
                context.writeString(this.toolTip, "ToolTip", element);
                context.writeFont(this.font, "Font", element);
                context.writeImage(this.backgroundImageContent, "BackgroundImage", element);
                context.writeInt(this.backgroundImageAlign, "ImageAlign", element);
                context.writeString(this.backgroundImageUrl, "BackgroundImageUrl", element);
                context.writeShape(this.defaultShape, "DefaultShape", element);
                context.writePen(this.shapePen, "ShapePen", element);
                context.writePen(this.linkPen, "LinkPen", element);
                context.writeBrush(this.shapeBrush, "ShapeBrush", element);
                context.writeBrush(this.linkBrush, "LinkBrush", element);
                context.writeBrush(this.backBrush, "Brush", element);
                context.writeBool(this.allowUnconnectedLinks, "AllowUnconnectedLinks", element);
                context.writeBool(this.routeLinks, "RouteLinks", element);
                context.writeInt(this.linkTextStyle, "LinkTextStyle", element);
                context.writeInt(this.measureUnit, "MeasureUnit", element);
                context.writeString(this.linkText, "LinkText", element);
                context.writeString(this.shapeText, "ShapeText", element);
                context.writeInt(this.linkCrossings, "LinkCrossings", element);
                context.writeFloat(this.autoSnapDistance, "AutoSnapDistance", element);
                context.writeTag(this, this.tag, "Tag", element);
                context.writeBool(this.roundedLinks, "RoundedLinks", element);
                context.writeFloat(this.roundedLinksRadius, "RoundedLinksRadius", element);
                context.writeBool(this.showLaneGrid, "EnableLanes", element);
                var laneElement = context.addChildElement("Lane", element);
                this.laneGrid.saveToXml(laneElement, context);
                context.writeInt(this.autoResize, "AutoResize", element);
                context.writeBool(this.allowSelfLoops, "AllowSelfLoops", element);
                context.writeBool(this.expandOnIncoming, "ExpandOnIncoming", element);
                context.writeInt(this.showAnchors, "ShowAnchors", element);
                context.writeFloat(this.adjustmentHandlesSize, "AdjustmentHandlesSize", element);
                context.writeBool(this.showDisabledHandles, "ShowDisabledHandles", element);
                context.writeBool(this.dynamicLinks, "DynamicLinks", element);
                context.writeBool(this.selection.allowMultipleSelection, "AllowMultipleSelection", element)
            },
            loadEffects: function(elementName, parentElement, context) {
                this.nodeEffects = [];
                var elements = parentElement.getElementsByTagName(elementName);
                var element = null;
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i].parentNode != parentElement) {
                        continue
                    }
                    element = elements[i];
                    break
                }
                if (!element) {
                    return
                }
                var effectElements = element.getElementsByTagName("Effect");
                for (var i = 0; i < effectElements.length; i++) {
                    var effectElement = effectElements[i];
                    this.nodeEffects.push(context.readEffect(effectElement))
                }
            },
            saveEffects: function(elementName, parentElement, context) {
                var effectsElement = context.addChildElement(elementName, parentElement);
                for (var i = 0; i < this.nodeEffects.length; i++) {
                    context.writeEffect(this.nodeEffects[i], "Effect", effectsElement)
                }
            },
            loadView: function(elementName, parentElement, context) {
                var element = context.selectSingleNode(elementName, parentElement);
                if (!element) {
                    return
                }
                this.setBehavior(context.readInt("Behavior", element))
            },
            onItemAdded: function(item) {
                item.parent = this;
                item.addCanvasElements()
            },
            onItemRemoved: function(item) {
                item.removeCanvasElements()
            },
            setDirty: function(value) {
                if (Diagram.suppressSetDirty) {
                    return
                }
                if (value === undefined) {
                    value = true
                }
                this.dirty = value
            },
            getDirty: function() {
                return this.dirty
            },
            clearRuntimeData: function(fieldName) {
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var item = this.items[i];
                    item[fieldName] = undefined
                }
            },
            copyToClipboard: function(systemClipboard) {
                if (this.selection.items.length == 0) {
                    return
                }
                var json = this.selection.toJson();
                if (systemClipboard && window.clipboardData) {
                    window.clipboardData.setData("text", json)
                } else {
                    window.mf_clipboard = json
                }
            },
            pasteFromClipboard: function(offsetX, offsetY, systemClipboard, unconnectedLinks) {
                var json;
                if (systemClipboard && window.clipboardData) {
                    json = window.clipboardData.getData("text")
                } else {
                    json = window.mf_clipboard
                }
                if (json) {
                    var dx = offsetX || 0;
                    var dy = offsetY || 0;
                    this.startCompositeOperation();
                    this.selection.clear();
                    var obj = mflayer.fromJson(json);
                    var ordered = [];
                    var items = obj.items;
                    if (items instanceof Object) {
                        for (var i = 0; i < items.length; i++) {
                            if (this.isNodeType(items[i])) {
                                var item = this.loadItem(items[i], ordered);
                                ordered[items[i].instanceId] = item;
                                if (dx != 0 || dy != 0) {
                                    var b = item.getBounds();
                                    item.setBounds(new Rect(b.x + dx, b.y + dy, b.width, b.height))
                                }
                                this.addItem(item);
                                this.selection.addItem(item)
                            }
                        }
                        for (var i = 0; i < items.length; i++) {
                            if (this.isLinkType(items[i])) {
                                if (!unconnectedLinks && (items[i].origin == -1 || items[i].destination == -1)) {
                                    continue
                                }
                                var item = this.loadItem(items[i], ordered);
                                ordered[items[i].instanceId] = item;
                                if (dx != 0 || dy != 0) {
                                    for (var k = 0; k < item.points.length; ++k) {
                                        var p = item.points[k];
                                        item.points[k] = new Point(p.x + dx, p.y + dy)
                                    }
                                }
                                this.addItem(item);
                                this.selection.addItem(item);
                                item.updateFromPoints()
                            }
                        }
                    }
                    for (var i = 0; i < ordered.length; i++) {
                        ordered[i].onLoad(ordered)
                    }
                    this.commitCompositeOperation();
                    for (var i = 0; i < ordered.length; i++) {
                        this.raisePasted(ordered[i])
                    }
                }
            },
            cutToClipboard: function(systemClipboard) {
                this.copyToClipboard(systemClipboard);
                this.deleteSelection()
            },
            setFont: function(value) {
                if (this.font !== value) {
                    this.font = value;
                    this.setDirty(true)
                }
            },
            getFont: function() {
                return this.font
            },
            arrange: function(layout) {
                this.startTotalChange();
                var result = mdiag.LayoutUtils.arrange(layout, this);
                this.commitCompositeOperation();
                return result
            },
            arrangeAnimated: function(layout, duration, animationType, easingType) {
                this.startTotalChange();
                animationType = animationType || 0;
                duration = duration || 500;
                easingType = easingType || 0;
                var result = mdiag.LayoutUtils.arrange(layout, this, {
                    animationType: animationType,
                    duration: duration,
                    easingType: easingType
                });
                this.commitCompositeOperation();
                return result
            },
            toGraph: function(simple, keepGroups, hierarchy) {
                return mdiag.LayoutUtils.toGraph(simple, keepGroups, hierarchy, this.nodes, this.links)
            },
            resizeToFitItems: function(margin) {
                if (margin === undefined) {
                    margin = 10
                }
                var rect = this.getContentBounds();
                this.setBounds(Rect.fromLTRB(rect.left() - margin, rect.top() - margin, rect.right() + margin, rect.bottom() + margin))
            },
            resizeToFitItem: function(item) {
                if (item == null) {
                    this.sizeDocForItems();
                    return
                }
                if (mflayer.isInstanceOfType(mdiag.Selection, item) || !mflayer.isInstanceOfType(mdiag.DiagramItem, item)) {
                    return
                }
                var changed = false;
                var docLeft = this.bounds.left();
                var docTop = this.bounds.top();
                var docRight = this.bounds.right();
                var docBottom = this.bounds.bottom();
                var rcItem = item.getBounds().clone();
                var hinch = 12 * GraphicsUnit.getMillimeter(this.measureUnit);
                if (this.autoResize == mdiag.AutoResize.AllDirections) {
                    if (rcItem.left() < docLeft + hinch) {
                        docLeft = rcItem.left() - hinch;
                        changed = true
                    }
                    if (rcItem.top() < docTop + hinch) {
                        docTop = rcItem.top() - hinch;
                        changed = true
                    }
                }
                if (rcItem.right() > docRight - hinch) {
                    docRight = rcItem.right() + hinch;
                    changed = true
                }
                if (rcItem.bottom() > docBottom - hinch) {
                    docBottom = rcItem.bottom() + hinch;
                    changed = true
                }
                if (changed) {
                    this.setBounds(Rect.fromLTRB(docLeft, docTop, docRight, docBottom))
                }
            },
            sizeDocForItems: function() {
                var rcNewSize = this.bounds.clone();
                var rcCurrent = this.bounds.clone();
                ArrayList.forEach(this.items, function(item) {
                    if (rcNewSize == Rect.empty) {
                        rcNewSize = item.getBounds().clone()
                    } else {
                        rcNewSize = rcNewSize.union(item.getBounds())
                    }
                });
                if (rcNewSize != rcCurrent) {
                    this.setBounds(Rect.fromLTRB(this.bounds.left(), this.bounds.top(), rcNewSize.right(), rcNewSize.bottom()))
                }
            },
            getContentBounds: function() {
                var rect = Rect.empty;
                ArrayList.forEach(this.items, function(item) {
                    if (rect == Rect.empty) {
                        rect = item.getBounds().clone()
                    } else {
                        rect = rect.union(item.getBounds())
                    }
                });
                return rect
            },
            scrollTo: function(x, y) {
                var ox = this.getScrollX();
                var oy = this.getScrollY();
                var scrollOffset = this.docToClientOverflow(new Point(x, y));
                if (this.scroller) {
                    this.scroller.scrollLeft = scrollOffset.x;
                    this.scroller.scrollTop = scrollOffset.y
                } else {
                    this.get_element().parentNode.scrollLeft = scrollOffset.x;
                    this.get_element().parentNode.scrollTop = scrollOffset.y
                }
                if (this.pointerPosition) {
                    this.pointerPosition.x += this.getScrollX() - ox;
                    this.pointerPosition.y += this.getScrollY() - oy
                }
            },
            scrollStayInDoc: function(scrX, scrY, rcPage, diagBounds) {
                if (!diagBounds) {
                    diagBounds = this.bounds
                }
                if (scrX < diagBounds.left()) {
                    scrX = diagBounds.left()
                }
                if (scrX > diagBounds.right() - rcPage.width) {
                    scrX = Math.max(diagBounds.right() - rcPage.width, diagBounds.left())
                }
                if (scrY < diagBounds.top()) {
                    scrY = diagBounds.top()
                }
                if (scrY > diagBounds.bottom() - rcPage.height) {
                    scrY = Math.max(diagBounds.bottom() - rcPage.height, diagBounds.top())
                }
                this.scrollTo(scrX, scrY)
            },
            getScrollX: function() {
                if (this.scroller) {
                    var scrollOffset = new Point(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var scrollOffset = new Point(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(scrollOffset).x
            },
            setScrollX: function(value) {
                var scrollOffset = this.docToClientOverflow(new Point(value, 0));
                if (this.scroller) {
                    this.scroller.scrollLeft = scrollOffset.x
                } else {
                    this.get_element().parentNode.scrollLeft = scrollOffset.x
                }
            },
            getScrollY: function() {
                if (this.scroller) {
                    var scrollOffset = new Point(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var scrollOffset = new Point(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(scrollOffset).y
            },
            setScrollY: function(value) {
                var scrollOffset = this.docToClientOverflow(new Point(0, value));
                if (this.scroller) {
                    this.scroller.scrollTop = scrollOffset.y
                } else {
                    this.get_element().parentNode.scrollTop = scrollOffset.y
                }
            },
            getScrollPosition: function() {
                if (this.scroller) {
                    var scrollOffset = new Point(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var scrollOffset = new Point(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(scrollOffset)
            },
            getViewport: function() {
                var scrollDiv = this.scroller ? this.scroller : this.get_element().parentNode;
                var point1 = new Point(scrollDiv.scrollLeft, scrollDiv.scrollTop);
                point1 = this.clientToDocOverflow(point1);
                var point2 = new Point(scrollDiv.scrollLeft + scrollDiv.offsetWidth, scrollDiv.scrollTop + scrollDiv.offsetHeight);
                point2 = this.clientToDocOverflow(point2);
                return Rect.fromPoints(point1, point2)
            },
            setZoomFactorPivot: function(zoomFactor, pivotPoint) {
                var pivot = this.docToClientOverflow(pivotPoint);
                var scroll = this.docToClientOverflow(this.getScrollPosition());
                var offset = mdiag.Utils.subtract(pivot, scroll);
                this.setZoomFactor(zoomFactor);
                offset = this.clientToDocOverflow(offset);
                this.scrollTo(pivotPoint.x - offset.x, pivotPoint.y - offset.y)
            },
            zoomToRect: function(rect) {
                this.setZoomFactor(100);
                var viewport = this.getViewport();
                var scale = Math.min(viewport.width / rect.width, viewport.height / rect.height);
                this.setZoomFactor(100 * scale);
                var center = rect.center();
                viewport = this.getViewport();
                this.scrollTo(Math.max(this.bounds.x, center.x - viewport.width / 2), Math.max(this.bounds.y, center.y - viewport.height / 2))
            },
            zoomToFit: function() {
                this.zoomToRect(this.getContentBounds())
            },
            setZoomLevel: function(value) {
                this.setZoomFactor(value)
            },
            setScroll: function(x, y) {
                this.scrollTo(x, y)
            },
            getDynamicLinks: function() {
                return this.dynamicLinks
            },
            setDynamicLinks: function(value) {
                this.dynamicLinks = value
            },
            getRouteLinks: function() {
                return this.routeLinks
            },
            setRouteLinks: function(value) {
                this.routeLinks = value
            },
            routeLinksAt: function(rects) {
                var linksToRoute = [];
                for (var i = 0; i < this.links.length; i++) {
                    var link = this.links[i];
                    if (!link.autoRoute) {
                        continue
                    }
                    for (var r = 0; r < rects.length; r++) {
                        var rect = rects[r];
                        var dist = this.routeMargin;
                        var routeRect = mdiag.Utils.inflate(rect, dist, dist);
                        if (routeRect.intersectsWith(link.getBounds())) {
                            linksToRoute.push(link);
                            break
                        }
                    }
                }
                this.linkRouter.routeLinks(linksToRoute);
                linksToRoute.forEach(function(link) {
                    link.finalizeRoute()
                })
            },
            getActiveItem: function() {
                return this.activeItem
            },
            getAutoHandlesItem: function() {
                return this.autoHandlesItem
            },
            setAutoHandlesItem: function(value) {
                if (value != this.autoHandlesItem) {
                    this.autoHandlesItem = value;
                    this.invalidate()
                }
            },
            getModificationStart: function() {
                return this.modificationStart
            },
            setModificationStart: function(value) {
                if (this.modificationStart != value) {
                    this.modificationStart = value;
                    this.autoHandlesItem = null
                }
            },
            getLinkRouter: function() {
                return this.linkRouter
            },
            setLinkRouter: function(value) {
                this.linkRouter = value
            },
            getRouteMargin: function() {
                return this.routeMargin
            },
            setRouteMargin: function(value) {
                this.routeMargin = value
            },
            routeAllLinks: function() {
                this.startTotalChange();
                this.linkRouter.routeLinks(this.links);
                this.links.forEach(function(link) {
                    link.finalizeRoute()
                });
                this.commitCompositeOperation()
            },
            getSelection: function() {
                return this.selection
            },
            getAllowMultipleResize: function() {
                return this.allowMultipleResize
            },
            setAllowMultipleResize: function(value) {
                this.allowMultipleResize = value
            },
            getAllowUnconnectedLinks: function() {
                return this.allowUnconnectedLinks
            },
            setAllowUnconnectedLinks: function(value) {
                this.allowUnconnectedLinks = value
            },
            getLinkTextStyle: function() {
                return this.linkTextStyle
            },
            setLinkTextStyle: function(value) {
                if (this.linkTextStyle == value) {
                    return
                }
                this.linkTextStyle = value;
                this.setDirty(true)
            },
            getAdjustmentHandlesSize: function() {
                return this.adjustmentHandlesSize
            },
            setAdjustmentHandlesSize: function(value) {
                if (this.adjustmentHandlesSize == value) {
                    return
                }
                this.adjustmentHandlesSize = value;
                this.repaint()
            },
            getShowDisabledHandles: function() {
                return this.showDisabledHandles
            },
            setShowDisabledHandles: function(value) {
                if (this.showDisabledHandles == value) {
                    return
                }
                this.showDisabledHandles = value;
                this.repaint();
                this.setDirty(true)
            },
            getShowAnchors: function() {
                return this.showAnchors
            },
            setShowAnchors: function(value) {
                if (this.showAnchors == value) {
                    return
                }
                this.showAnchors = value;
                this.updateAnchorVisibility();
                this.setDirty(true)
            },
            updateAnchorVisibility: function() {
                for (var i = 0; i < this.nodes.length; i++) {
                    this.nodes[i].updateAnchorVisibility()
                }
            },
            getAutoAnchorsNode: function() {
                return this.autoAnchorsNode
            },
            setAutoAnchorsNode: function(node) {
                if (node != this.autoAnchorsNode) {
                    if (this.autoAnchorsNode != null) {
                        this.autoAnchorsNode.updateAnchorVisibility(node)
                    }
                    this.autoAnchorsNode = node;
                    if (this.autoAnchorsNode != null) {
                        this.autoAnchorsNode.updateAnchorVisibility4()
                    }
                }
            },
            getBehavior: function() {
                return this.behavior
            },
            setBehavior: function(value) {
                if (this.behavior == value) {
                    return
                }
                this.behavior = value;
                this.setDirty(true);
                var Behavior = mdiag.Behavior;
                switch (this.behavior) {
                    case Behavior.Modify:
                        this.currentBehavior = new mdiag.ModifyBehavior(this);
                        break;
                    case Behavior.DoNothing:
                        this.currentBehavior = new mdiag.DoNothingBehavior(this);
                        break;
                    case Behavior.LinkShapes:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.ShapeNode(this.diagram)
                        });
                        break;
                    case Behavior.DrawLinks:
                        this.currentBehavior = new mdiag.DrawLinksBehavior(this);
                        break;
                    case Behavior.DrawShapes:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.ShapeNode(this.diagram)
                        });
                        break;
                    case Behavior.LinkTables:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.TableNode(this.diagram)
                        });
                        break;
                    case Behavior.DrawTables:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.TableNode(this.diagram)
                        });
                        break;
                    case Behavior.LinkContainers:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.ContainerNode(this.diagram)
                        });
                        break;
                    case Behavior.DrawContainers:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.ContainerNode(this.diagram)
                        });
                        break;
                    case Behavior.LinkSvgNodes:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.SvgNode(this.diagram)
                        });
                        break;
                    case Behavior.DrawSvgNodes:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.SvgNode(this.diagram)
                        });
                        break;
                    case Behavior.Pan:
                        this.currentBehavior = new mdiag.PanBehavior(this);
                        break;
                    case Behavior.SelectOnly:
                        this.currentBehavior = new mdiag.SelectOnlyBehavior(this);
                        break;
                    case Behavior.Custom:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            var type = mflayer.parseType(this.diagram.customNodeType);
                            if (!type) {
                                return new mdiag.ShapeNode(this.diagram)
                            }
                            return new type(this.diagram)
                        }, function(diagram, origin, destination) {
                            var type = mflayer.parseType(this.diagram.customLinkType);
                            if (!type) {
                                return new mdiag.DiagramLink(this.diagram, origin, destination)
                            }
                            return new type(this.diagram, origin, destination)
                        });
                        break;
                    case Behavior.LinkFreeForms:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.FreeFormNode(this.diagram)
                        });
                        break;
                    case Behavior.DrawFreeForms:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.FreeFormNode(this.diagram)
                        });
                        break;
                    case Behavior.LinkFreeShapes:
                        this.currentBehavior = new mdiag.LinkNodesBehavior(this, function(diagram) {
                            return new mdiag.FreeFormNode(this.diagram)
                        });
                        this.currentBehavior.convertToShape = true;
                        break;
                    case Behavior.DrawFreeShapes:
                        this.currentBehavior = new mdiag.DrawNodesBehavior(this, function(diagram) {
                            return new mdiag.FreeFormNode(this.diagram)
                        });
                        this.currentBehavior.convertToShape = true;
                        break;
                    case Behavior.Magnify:
                        this.currentBehavior = new mdiag.MagnifyBehavior(this);
                        break
                }
            },
            record: function() {
                var startTimeStamp = new Date().getTime();
                var eventDispatcher = this.mouseInputDispatcher;
                var recordingDispatcher = new mdiag.RecordingMouseDispatcher(this, startTimeStamp);
                recordingDispatcher.eventDispatcher = eventDispatcher;
                this.mouseInputDispatcher = recordingDispatcher;
                this.mouseHandler.inputDispatcher = recordingDispatcher;
                var eventDispatcher = this.keyboardInputDispatcher;
                var recordingDispatcher = new mdiag.RecordingKeyboardDispatcher(this, startTimeStamp);
                recordingDispatcher.eventDispatcher = eventDispatcher;
                this.keyboardInputDispatcher = recordingDispatcher;
                this.keyboardHandler.inputDispatcher = recordingDispatcher
            },
            stopRecording: function() {
                var recordingDispatcher = this.mouseInputDispatcher;
                var mouseData = recordingDispatcher.data;
                this.mouseInputDispatcher = recordingDispatcher.eventDispatcher;
                this.mouseHandler.inputDispatcher = this.mouseInputDispatcher;
                var recordingDispatcher = this.keyboardInputDispatcher;
                var keyboardData = recordingDispatcher.data;
                this.keyboardInputDispatcher = recordingDispatcher.eventDispatcher;
                this.keyboardHandler.inputDispatcher = this.keyboardInputDispatcher;
                var data = mouseData.concat(keyboardData);

                function compare(a, b) {
                    if (a.time < b.time) {
                        return -1
                    }
                    if (a.time > b.time) {
                        return 1
                    }
                    return 0
                }
                data.sort(compare);
                return data
            },
            replay: function(recording, timer, savedState, timerInterval) {
                if (!recording) {
                    throw new Error("Recording is null.")
                }
                if (savedState) {
                    this.fromJson(savedState);
                    this.repaint()
                }
                this.enabled = false;
                var i = -1;
                if (timer) {
                    var thisObj = this;
                    if (timerInterval) {
                        var replayIntervalId = setInterval(function() {
                            ++i;
                            if (i == recording.length - 1) {
                                this.enabled = true;
                                clearInterval(replayIntervalId);
                                delete replayIntervalId
                            }
                            return thisObj.onReplay(recording[i])
                        }, timerInterval)
                    } else {
                        this.onReplay(recording[0]);
                        this.onReplayTimeout(this, recording, 1)
                    }
                } else {
                    while (i < recording.length - 1) {
                        ++i;
                        this.onReplay(recording[i])
                    }
                    this.enabled = true
                }
            },
            onReplayTimeout: function(thisObj, recordings, index) {
                if (index >= recordings.length) {
                    return
                }
                var delay = recordings[index].time - recordings[index - 1].time;
                var id = setTimeout(function() {
                    thisObj.onReplay(recordings[index]);
                    clearTimeout(id);
                    id = null;
                    if (++index < recordings.length) {
                        thisObj.onReplayTimeout(thisObj, recordings, index)
                    } else {
                        thisObj.enabled = true
                    }
                }, delay)
            },
            onReplay: function(recording) {
                if (recording.func.toLowerCase().indexOf("key") > -1) {
                    this.keyboardInputDispatcher[recording.func](recording.targetId, recording.key, true, recording.value)
                } else {
                    this.mouseInputDispatcher[recording.func](recording.position, recording.button)
                }
                this.updateContainersZOrder()
            },
            getShowGrid: function() {
                return this.showGrid
            },
            setShowGrid: function(value) {
                if (this.showGrid == value) {
                    return
                }
                this.showGrid = value;
                this.repaint();
                this.setDirty(true)
            },
            getAlignToGrid: function() {
                return this.alignToGrid
            },
            setAlignToGrid: function(value) {
                if (this.alignToGrid !== value) {
                    this.alignToGrid = value;
                    this.setDirty(true)
                }
            },
            getGridColor: function() {
                return this.gridColor
            },
            setGridColor: function(value) {
                if (this.gridColor == value) {
                    return
                }
                this.gridColor = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridSizeX: function() {
                return this.gridSizeX
            },
            setGridSizeX: function(value) {
                if (this.gridSizeX == value) {
                    return
                }
                this.gridSizeX = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridSizeY: function() {
                return this.gridSizeY
            },
            setGridSizeY: function(value) {
                if (this.gridSizeY == value) {
                    return
                }
                this.gridSizeY = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridOffsetX: function() {
                return this.gridOffsetX
            },
            setGridOffsetX: function(value) {
                if (this.gridOffsetX == value) {
                    return
                }
                this.gridOffsetX = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridOffsetY: function() {
                return this.gridOffsetY
            },
            setGridOffsetY: function(value) {
                if (this.gridOffsetY == value) {
                    return
                }
                this.gridOffsetY = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridStyle: function() {
                return this.gridStyle
            },
            setGridStyle: function(value) {
                if (this.gridStyle == value) {
                    return
                }
                this.gridStyle = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            getGridPointSize: function() {
                return this.gridPointSize
            },
            setGridPointSize: function(value) {
                if (this.gridPointSize == value) {
                    return
                }
                this.gridPointSize = value;
                this.setDirty(true);
                if (this.showGrid) {
                    this.repaint()
                }
            },
            alignMove: function(item, rect) {
                return this.alignPointToGrid(rect.topLeft())
            },
            alignPointToGrid: function(point) {
                if (this.alignToGrid) {
                    var xOffset = this.gridSizeX / 2;
                    if (mdiag.Utils.isNumber(this.gridOffsetX)) {
                        xOffset = this.gridOffsetX - this.gridSizeX * Math.floor(this.gridOffsetX / this.gridSizeX)
                    }
                    var yOffset = this.gridSizeY / 2;
                    if (mdiag.Utils.isNumber(this.gridOffsetY)) {
                        yOffset = this.gridOffsetY - this.gridSizeY * Math.floor(this.gridOffsetY / this.gridSizeY)
                    }
                    return new Point(xOffset + this.gridSizeX * Math.round((point.x - xOffset) / this.gridSizeX), yOffset + this.gridSizeY * Math.round((point.y - yOffset) / this.gridSizeY))
                }
                return point
            },
            alignResize: function(item, point, handle) {
                return this.alignPointToGrid(point)
            },
            getShowLaneGrid: function() {
                return this.showLaneGrid
            },
            setShowLaneGrid: function(value) {
                if (this.showLaneGrid == value) {
                    return
                }
                this.showLaneGrid = value;
                this.repaint();
                this.setDirty(true)
            },
            hitTestManipulators: function(mousePosition) {
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var item = this.items[i];
                    var manipulator = item.hitTestManipulators(mousePosition);
                    if (manipulator !== null) {
                        return manipulator
                    }
                }
                return null
            },
            setExpandOnIncoming: function(value) {
                if (this.expandOnIncoming !== value) {
                    this.expandOnIncoming = value;
                    this.setDirty(true)
                }
            },
            getExpandOnIncoming: function() {
                return this.expandOnIncoming
            },
            setNodesExpandable: function(value) {
                if (this.nodesExpandable !== value) {
                    this.nodesExpandable = value;
                    this.setDirty(true)
                }
            },
            getNodesExpandable: function() {
                return this.nodesExpandable
            },
            onItemDragging: function(item, point) {
                if (mdiag.ContainerNode.usingContainerNodes) {
                    mdiag.ContainerNode.containerHit = false;
                    var allowed = this.visitNodes(point, this.onDragOverNode, item);
                    if (mdiag.ContainerNode.containerHit) {
                        return allowed
                    }
                    var container = item.container;
                    if (container) {
                        var ctrBounds = container.bounds;
                        var childBounds = item.getRotatedBounds();
                        if (!ctrBounds.contains(childBounds) && !ctrBounds.intersectsWith(childBounds)) {
                            if (!container.allowRemoveChildren) {
                                return false
                            }
                            var args = new mdiag.NodeEventArgs({
                                node: item,
                                container: container
                            });
                            this.raiseEvent(mdiag.Events.containerChildRemoving, args);
                            if (args.getCancel()) {
                                return false
                            }
                        }
                    }
                }
                return true
            },
            onDragOverNode: function(node, relatedItem) {
                if (node == relatedItem) {
                    return false
                }
                return node.onDragOver(relatedItem)
            },
            onItemDropped: function(item, point) {
                this.visitNodes(point, this.onDropOverNode, item)
            },
            onDropOverNode: function(node, relatedItem) {
                if (node == relatedItem) {
                    return false
                }
                return node.onDropOver(relatedItem)
            },
            visitNodes: function(point, nodeOp, relatedItem) {
                for (var i = this.items.length - 1; i >= 0; i--) {
                    var node = this.items[i];
                    if (relatedItem == node) {
                        continue
                    }
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, node) && node.getTopLevel() && !node.notInteractive() && node.containsPoint(point)) {
                        if (mflayer.isInstanceOfType(mdiag.ContainerNode, node)) {
                            var handledByChild = node.visitNodes(point, nodeOp, relatedItem);
                            if (handledByChild) {
                                return true
                            }
                        }
                        var handled = nodeOp(node, relatedItem);
                        if (handled) {
                            return true
                        }
                    }
                }
                return false
            },
            setStyle: function(value) {
                if (this.style !== value) {
                    this.style = value;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getStyle: function() {
                return this.style
            },
            setTheme: function(value) {
                if (this.theme != value) {
                    this.theme = value;
                    ArrayList.forEach(this.items, function(item) {
                        item.invalidate()
                    });
                    this.setDirty(true)
                }
            },
            getTheme: function() {
                return this.theme
            },
            setTag: function(value) {
                if (this.tag != value) {
                    this.tag = value;
                    this.setDirty(true)
                }
            },
            getTag: function() {
                return this.tag
            },
            setCustomNodeType: function(value) {
                this.customNodeType = value
            },
            getCustomNodeType: function() {
                return this.customNodeType
            },
            setCustomLinkType: function(value) {
                this.customLinkType = value
            },
            getCustomLinkType: function() {
                return this.customLinkType
            },
            setVirtualScroll: function(value) {
                if (this.virtualScroll != value) {
                    this.virtualScroll = value;
                    this.resetVirtualScroll()
                }
            },
            getVirtualScroll: function() {
                return this.virtualScroll
            },
            setTooltipDelay: function(value) {
                if (this.tooltipDelay !== value) {
                    this.tooltipDelay = value;
                    this.setDirty()
                }
            },
            getTooltipDelay: function() {
                return this.tooltipDelay != undefined ? this.tooltipDelay : 1000
            },
            getLinkHitDistance: function() {
                return this.linkHitDistance
            },
            setLinkHitDistance: function(value) {
                if (this.linkHitDistance !== value) {
                    this.linkHitDistance = value || 0;
                    this.setDirty(true)
                }
            },
            getLinkCrossings: function() {
                return this.linkCrossings
            },
            setLinkCrossings: function(value) {
                if (this.linkCrossings == value) {
                    return
                }
                this.linkCrossings = value;
                this.clearRuntimeData("_mf_linkCrossings");
                for (var i = 0; i < this.links.length; i++) {
                    var link = this.links[i];
                    link.invalidate()
                }
                this.invalidate();
                this.setDirty(true)
            },
            getCrossingRadius: function() {
                return this.crossingRadius
            },
            setCrossingRadius: function(value) {
                if (this.crossingRadius == value) {
                    return
                }
                this.crossingRadius = value;
                this.clearRuntimeData("_mf_linkCrossings");
                this.invalidate();
                this.setDirty(true)
            },
            getRoundedLinks: function() {
                return this.roundedLinks
            },
            setRoundedLinks: function(value) {
                if (this.roundedLinks !== value) {
                    this.roundedLinks = value;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getRoundedLinksRadius: function() {
                return this.roundedLinksRadius
            },
            setRoundedLinksRadius: function(value) {
                if (this.roundedLinksRadius !== value) {
                    this.roundedLinksRadius = value;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getAutoResize: function() {
                return this.autoResize
            },
            setAutoResize: function(value) {
                this.autoResize = value
            },
            getAutoScroll: function() {
                return this.autoScroll
            },
            setAutoScroll: function(value) {
                if (this.autoScroll != value) {
                    this.autoScroll = value;
                    this.stopAutoScroll()
                }
            },
            getScrollZoneSize: function() {
                return this.scrollZoneSize
            },
            setScrollZoneSize: function(value) {
                if (this.scrollZoneSize != value) {
                    this.scrollZoneSize = value
                }
            },
            getAutoScrollAmount: function() {
                return this.autoScrollAmount
            },
            setAutoScrollAmount: function(value) {
                if (this.autoScrollAmount != value) {
                    this.autoScrollAmount = value
                }
            },
            getMagnifierEnabled: function() {
                return this.magnifierEnabled
            },
            setMagnifierEnabled: function(value) {
                if (this.magnifierEnabled != value) {
                    this.magnifierEnabled = value;
                    this.invalidate()
                }
            },
            getMagnifierFactor: function() {
                return this.magnifierFactor
            },
            setMagnifierFactor: function(value) {
                if (this.magnifierFactor != value) {
                    this.magnifierFactor = value
                }
            },
            getMagnifierWidth: function() {
                return this.magnifierWidth
            },
            setMagnifierWidth: function(value) {
                if (this.magnifierWidth != value) {
                    this.magnifierWidth = value
                }
            },
            getMagnifierHeight: function() {
                return this.magnifierHeight
            },
            setMagnifierHeight: function(value) {
                if (this.magnifierHeight != value) {
                    this.magnifierHeight = value
                }
            },
            getMagnifierFrameThickness: function() {
                return this.magnifierFrameThickness
            },
            setMagnifierFrameThickness: function(value) {
                if (this.magnifierFrameThickness != value) {
                    this.magnifierFrameThickness = value
                }
            },
            getMagnifierShading: function() {
                return this.magnifierShading
            },
            setMagnifierShading: function(value) {
                if (this.magnifierEnabled != value) {
                    this.magnifierShading = value
                }
            },
            getMagnifierShape: function() {
                return this.magnifierShape
            },
            setMagnifierShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.magnifierShape != value) {
                    this.magnifierShape = value;
                    if (this.magnifierRenderer) {
                        this.magnifierRenderer.setShape(this.magnifierShape)
                    }
                }
            },
            getMagnifierFrameColor: function() {
                return this.magnifierFrameColor
            },
            setMagnifierFrameColor: function(value) {
                if (this.magnifierFrameColor == value) {
                    return
                }
                this.magnifierFrameColor = value;
                if (this.magnifierEnabled) {
                    this.repaint()
                }
            },
            getMagnifierSecondaryFrameColor: function() {
                return this.magnifierSecondaryFrameColor
            },
            setMagnifierSecondaryFrameColor: function(value) {
                if (this.magnifierSecondaryFrameColor == value) {
                    return
                }
                this.magnifierSecondaryFrameColor = value;
                if (this.magnifierSecondaryFrameColor) {
                    this.repaint()
                }
            },
            getModifierKeyActions: function() {
                return this.modifierKeyActions
            },
            getLeftButtonActions: function() {
                return this.leftButtonActions
            },
            setLeftButtonActions: function(value) {
                if (this.leftButtonActions != value) {
                    this.leftButtonActions = value
                }
            },
            getMiddleButtonActions: function() {
                return this.middleButtonActions
            },
            setMiddleButtonActions: function(value) {
                if (this.middleButtonActions != value) {
                    this.middleButtonActions = value
                }
            },
            getRightButtonActions: function() {
                return this.rightButtonActions
            },
            setRightButtonActions: function(value) {
                if (this.rightButtonActions != value) {
                    this.rightButtonActions = value;
                    if (value && value != mdiag.MouseButtonActions.None) {
                        this.get_element().oncontextmenu = this.onContextMenu
                    } else {
                        this.get_element().oncontextmenu = null
                    }
                }
            },
            getUndoEnabled: function() {
                return this.undoManager != null
            },
            setUndoEnabled: function(value) {
                if (this.getUndoEnabled() != value) {
                    this.undoManager = value ? new mdiag.UndoManager(this) : null;
                    this.updateCanUndo()
                }
            },
            setShadowOffsetX: function(value) {
                if (this.shadowOffsetX !== value) {
                    this.shadowOffsetX = value;
                    this.invalidate()
                }
            },
            getShadowOffsetX: function() {
                if (this.shadowOffsetX === undefined) {
                    return 4
                }
                return this.shadowOffsetX
            },
            setShadowOffsetY: function(value) {
                if (this.shadowOffsetY !== value) {
                    this.shadowOffsetY = value;
                    this.invalidate()
                }
            },
            getShadowOffsetY: function() {
                if (this.shadowOffsetY === undefined) {
                    return 4
                }
                return this.shadowOffsetY
            },
            setShadowsStyle: function(value) {
                if (this.shadowsStyle !== value) {
                    this.shadowsStyle = value;
                    this.invalidate()
                }
            },
            getShadowsStyle: function() {
                if (this.shadowsStyle === undefined) {
                    return mdiag.ShadowsStyle.None
                }
                return this.shadowsStyle
            },
            setShapeLibraryLocation: function(value) {
                if (this.shapeLibraryLocation != value) {
                    this.shapeLibraryLocation = value;
                    if (this.shapeLibraryLocation != null && this.shapeLibraryLocation != "") {
                        try {
                            mdiag.Shape.loadFromLibPending = true;
                            new mdiag.ShapeLibrary().loadFromXml(this.shapeLibraryLocation, mflayer.createDelegate(this, this.onShapeLibraryLoad), mflayer.createDelegate(this, this.onShapeLibraryError))
                        } catch (err) {
                            mdiag.Shape.loadFromLibPending = false;
                            throw err
                        }
                    } else {
                        mdiag.Shape.loadFromLibPending = false
                    }
                }
            },
            getShapeLibraryLocation: function() {
                return this.shapeLibraryLocation
            },
            onShapeLibraryLoad: function() {
                mdiag.Shape.loadFromLibPending = false;
                this.invalidateDefaultShapes();
                this.invalidate()
            },
            onShapeLibraryLoaded: function(success) {
                mdiag.Shape.loadFromLibPending = false;
                ArrayList.forEach(this.items, function(item) {
                    if (item.onShapeLoaded) {
                        item.onShapeLoaded()
                    }
                })
            },
            onShapeLibraryError: function() {
                mdiag.Shape.loadFromLibPending = false;
                this.invalidateDefaultShapes();
                this.invalidate()
            },
            invalidateDefaultShapes: function() {
                if (this.magnifierShape && this.magnifierShape.isDummy()) {
                    this.magnifierShape = mdiag.Shape.fromId(this.magnifierShape.id);
                    if (this.magnifierRenderer) {
                        this.magnifierRenderer.setShape(this.magnifierShape)
                    }
                }
                if (this.defaultShape && this.defaultShape.isDummy()) {
                    this.defaultShape = mdiag.Shape.fromId(this.defaultShape.id)
                }
                if (this.linkHeadShape && this.linkHeadShape.isDummy()) {
                    this.linkHeadShape = mdiag.Shape.fromId(this.linkHeadShape.id)
                }
                if (this.linkBaseShape && this.linkBaseShape.isDummy()) {
                    this.linkBaseShape = mdiag.Shape.fromId(this.linkBaseShape.id)
                }
            },
            invalidateLabelLayout: function() {
                if (!this.labelsAutoArrange) {
                    return
                }
                this.invalidate();
                this.labelLayoutInvalid = true
            },
            updateLabelLayout: function(rect) {
                if (!this.labelLayoutInvalid) {
                    return
                }
                if (!rect) {
                    rect = this.bounds
                }
                this.doArrangeLinkLabels(rect);
                this.labelLayoutInvalid = false
            },
            arrangeLinkLabels: function() {
                if (!this.labelsAutoArrange) {
                    return
                }
                var layoutArea = this.getContentBounds();
                layoutArea = layoutArea.union(this.bounds);
                this.labelLayoutInvalid = true;
                this.updateLabelLayout(layoutArea);
                this.invalidate()
            },
            doArrangeLinkLabels: function(rect) {
                var obstacles = [];
                var labels = [];
                for (var i = 0, l = this.nodes.length; i < l; i++) {
                    if (rect.intersectsWith(this.nodes[i].bounds)) {
                        obstacles.push(this.nodes[i].bounds)
                    }
                }
                for (var i = 0, l = this.links.length; i < l; i++) {
                    if (this.links[i].labels != undefined) {
                        for (var k = 0, m = this.links[i].labels.length; k < m; k++) {
                            if (this.links[i].labels[k].autoArrange) {
                                if (rect.intersectsWith(this.links[i].labels[k].getLayoutRect())) {
                                    labels.push(this.links[i].labels[k])
                                }
                            } else {
                                this.links[i].labels[k].invalidateLayout()
                            }
                        }
                    }
                }
                for (var i = 0, l = labels.length; i < l; i++) {
                    var pt = this.arrangeLinkLabel(labels[i], obstacles);
                    var labelRect = labels[i].updateRect(pt);
                    labels[i].link.invalidate();
                    obstacles.push(labelRect)
                }
            },
            arrangeLinkLabel: function(label, obstacles) {
                label.invalidateLayout();
                var rect = label.getLayoutRect();
                var bounds = this.bounds.clone();
                bounds = bounds.inflate(-rect.width / 2, -rect.height / 2);
                var bestEval = Number.MAX_VALUE;
                var step = 4 * GraphicsUnit.getMillimeter(this.measureUnit);
                var bestPoint = new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
                var pivotPoint = bestPoint.clone();
                var link = label.link;
                var points = link.getPolyLine(30);
                for (var i = 0, l = points.length - 1; i < l; i++) {
                    var start = points[i];
                    var end = points[i + 1];
                    var segmentDir = new Vector(end.x - start.x, end.y - start.y);
                    var pointsToTry = Math.floor(segmentDir.length() / step);
                    segmentDir = Vector.multiplyScalar(segmentDir, (step / segmentDir.length()));
                    var vpoints = this.pointsAlongVector(start, segmentDir, end, pointsToTry);
                    for (var k = 0, m = vpoints.length; k < m; k++) {
                        var point = vpoints[k];
                        var lv = new Vector(segmentDir.y, -segmentDir.x);
                        var rv = new Vector(-segmentDir.y, segmentDir.x);
                        lv = Vector.multiplyScalar(Vector.divideScalar(lv, lv.length()), this.maxDiagonalDistance(rect, lv.negate()) + 1);
                        rv = Vector.multiplyScalar(Vector.divideScalar(rv, rv.length()), this.maxDiagonalDistance(rect, rv.negate()) + 1);
                        var lp = point.clone().addVector(lv);
                        var rp = point.clone().addVector(rv);
                        var le = this.evalPos(label, obstacles, lp, lp.distance(pivotPoint) + ((lp.y > rp.y) ? 1 : 0));
                        var re = this.evalPos(label, obstacles, rp, rp.distance(pivotPoint) + ((rp.y > lp.y) ? 1 : 0));
                        var lrect = new Rect(lp.x - rect.width / 2, lp.y - rect.height / 2, rect.width, rect.height);
                        var rrect = new Rect(rp.x - rect.width / 2, rp.y - rect.height / 2, rect.width, rect.height);
                        if (link.intersects(lrect)) {
                            le += 50
                        }
                        if (link.intersects(rrect)) {
                            re += 50
                        }
                        if (le < bestEval && bounds.containsPoint(lp)) {
                            bestPoint = lp;
                            bestEval = le
                        }
                        if (re < bestEval && bounds.containsPoint(rp)) {
                            bestPoint = rp;
                            bestEval = re
                        }
                    }
                }
                return bestPoint
            },
            drawMagnifier: function(pointerPosition) {
                if (pointerPosition || mflayer.isInstanceOfType(mdiag.MagnifyBehavior, this.currentBehavior) || this.magnifierEnabled) {
                    var p = pointerPosition;
                    if (!p) {
                        p = this.pointerPosition
                    }
                    if (p == undefined) {
                        return
                    }
                    var c = this.docToClient(p);
                    var w = Math.round(this.magnifierWidth / (this.magnifierFactor / 100)) * this.scale;
                    var h = Math.round(this.magnifierHeight / (this.magnifierFactor / 100)) * this.scale;
                    var src = new Rect(Math.round(c.x - w / 2), Math.round(c.y - h / 2), w, h);
                    w = this.magnifierWidth * (1 / (this.zoomFactor / 100));
                    h = this.magnifierHeight * (1 / (this.zoomFactor / 100));
                    var dest = new Rect(Math.round(p.x - w / 2), Math.round(p.y - h / 2), w, h);
                    if (!this.magnifierRenderer) {
                        this.magnifierRenderer = new mdiag.ShapeRenderer(this.magnifierShape)
                    }
                    this.magnifierRenderer.updateData(dest, 0);
                    this.magnifierRenderer.outlineBrush = "transparent";
                    this.magnifierRenderer.outlinePen = "transparent";
                    this.magnifierRenderer.drawOutline(this.context);
                    this.context.clip();
                    this.context.drawImage(this.get_element(), Math.max(src.x, 0), Math.max(src.y, 0), Math.max(src.width, 1), Math.max(src.height, 1), Math.max(dest.x, 0), Math.max(dest.y, 0), Math.max(dest.width, 1), Math.max(dest.height, 1));
                    if (this.magnifierShading) {
                        var brush = {
                            type: "RadialGradientBrush",
                            colorStops: [{
                                position: 0,
                                color: "rgba(0,0,0,0)"
                            }, {
                                position: 0.8,
                                color: "rgba(0,0,0,0.1)"
                            }, {
                                position: 0.9,
                                color: "rgba(0,0,0,0.2)"
                            }]
                        };
                        this.magnifierRenderer.outlineBrush = brush;
                        this.magnifierRenderer.drawOutline(this.context)
                    }
                    if (this.magnifierFrameThickness > 0) {
                        var scale = this.scale / (this.zoomFactor / 100);
                        this.magnifierRenderer.outlineBrush = "transparent";
                        this.magnifierRenderer.outlinePen = this.magnifierSecondaryFrameColor;
                        this.magnifierRenderer.strokeThickness = (this.magnifierFrameThickness + 1) * scale;
                        this.magnifierRenderer.drawOutline(this.context);
                        this.magnifierRenderer.outlinePen = this.magnifierFrameColor;
                        this.magnifierRenderer.strokeThickness = this.magnifierFrameThickness * scale;
                        this.magnifierRenderer.drawOutline(this.context)
                    }
                }
            },
            pointsAlongVector: function(start, vector, end, points) {
                var result = [];
                for (var i = 0; i <= points; ++i) {
                    start = MindFusion.Drawing.Point.addVector(start, vector);
                    result.push(start)
                }
                if (result.length == 0 || !result[result.length - 1].equals(end)) {
                    result.push(end.clone())
                }
                return result
            },
            evalPos: function(label, obstacles, point, segmentPenalty) {
                var rect = label.getLayoutRect();
                rect.setLocation(point);
                rect.offset(-rect.width / 2, -rect.height / 2);
                var worstCase = 0;
                for (var i = 0, l = obstacles.length; i < l; i++) {
                    if (rect.intersectsWith(obstacles[i])) {
                        var intersection = rect.intersect(obstacles[i]);
                        var area = intersection.width * intersection.height;
                        worstCase = Math.max(worstCase, area)
                    }
                }
                return worstCase + segmentPenalty
            },
            maxDiagonalDistance: function(rect, vector) {
                var center = new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
                var d1 = Vector.fromPoints(center, new Point(rect.x, rect.y));
                var d2 = Vector.fromPoints(center, new Point(rect.x + rect.width, rect.y));
                var d3 = Vector.fromPoints(center, new Point(rect.x + rect.width, rect.y + rect.height));
                var d4 = Vector.fromPoints(center, new Point(rect.x, rect.y + rect.height));
                var dots = [];
                dots.push((d1.x * vector.x + d1.y * vector.y) / vector.length());
                dots.push((d2.x * vector.x + d2.y * vector.y) / vector.length());
                dots.push((d3.x * vector.x + d3.y * vector.y) / vector.length());
                dots.push((d4.x * vector.x + d4.y * vector.y) / vector.length());
                dots.sort();
                return dots[3]
            },
            updateCanUndo: function() {
                this.canUndo = this.getUndoEnabled() && this.undoManager.canUndo();
                this.canRedo = this.getUndoEnabled() && this.undoManager.canRedo()
            },
            undo: function() {
                if (this.undoManager != null) {
                    this.undoManager.undo();
                    this.invalidate()
                }
            },
            redo: function() {
                if (this.undoManager != null) {
                    this.undoManager.redo();
                    this.invalidate()
                }
            },
            startCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.startComposite()
                }
            },
            commitCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.endComposite(true)
                }
            },
            cancelCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.endComposite(false)
                }
            },
            onStartInteraction: function(affectedItems) {
                if (this.undoManager != null) {
                    if (Array.isArray(affectedItems)) {
                        for (var i = 0; i < affectedItems.length; i++) {
                            var item = affectedItems[i];
                            var command = new mdiag.ChangeItemCommand(this, item);
                            this.undoManager.executeCommand(command)
                        }
                    } else {
                        if (mflayer.isInstanceOfType(Set, affectedItems)) {
                            affectedItems.forEach(function(item) {
                                var command = new mdiag.ChangeItemCommand(this, item);
                                this.undoManager.executeCommand(command)
                            }, this)
                        } else {
                            if (mflayer.isInstanceOfType(mdiag.DiagramItem, affectedItems)) {
                                var command = new mdiag.ChangeItemCommand(this, affectedItems);
                                this.undoManager.executeCommand(command)
                            }
                        }
                    }
                }
            },
            executeCommand: function(command) {
                if (this.undoManager != null) {
                    this.undoManager.executeCommand(command)
                }
            },
            startItemChange: function(item) {
                return this.undoManager == null ? null : new mdiag.ChangeItemCommand(this, item)
            },
            endItemChange: function(command) {
                if (this.undoManager != null && command != null) {
                    this.undoManager.executeCommand(command)
                }
            },
            startTotalChange: function() {
                if (this.undoManager != null) {
                    this.undoManager.startComposite();
                    for (var i = 0, l = this.items.length; i < l; i++) {
                        var command = new mdiag.ChangeItemCommand(this, this.items[i]);
                        this.undoManager.executeCommand(command)
                    }
                }
            },
            getLaneGrid: function() {
                return this.laneGrid
            }
        };

        function filterByPosition(items, point) {
            return items.filter(function(item) {
                return item.containsPoint(point)
            })
        }

        function zOrderedItemsAt(items, point) {
            var filteredItems = filterByPosition(items, point);
            filteredItems.sort(compareZ);
            return filteredItems
        }

        function topmostItemAt(items, point, skipInvisible, skipLocked, onlyNodes) {
            var sortedItems = zOrderedItemsAt(items, point);
            for (var i = sortedItems.length - 1; i >= 0; i--) {
                var item = sortedItems[i];
                if (skipInvisible && !item.getVisible()) {
                    continue
                }
                if (skipLocked && item.getLocked()) {
                    continue
                }
                if (item.getTopLevel()) {
                    var topItem = item.hitTest(point, 0, onlyNodes, skipLocked);
                    if (topItem != null) {
                        return topItem
                    }
                }
            }
            return null
        }

        function compareZ(e1, e2) {
            var i1 = e1.getZIndex();
            if (i1 === undefined) {
                i1 = Number.MAX_VALUE
            }
            var i2 = e2.getZIndex();
            if (i2 === undefined) {
                i2 = Number.MAX_VALUE
            }
            if (i1 < i2) {
                return -1
            }
            if (i1 > i2) {
                return 1
            }
            return 0
        }
        Diagram.ns = "MindFusion.Diagramming";
        MindFusion.registerClass(Diagram, "MindFusion.Diagramming.Diagram", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Diagram.registerItemClass = function(itemClass, classId, classVersion) {
        MindFusion.Diagramming.Diagram.xmlClassMap[classId] = itemClass;
        itemClass.xmlInfo = {
            classId: classId,
            classVersion: classVersion
        }
    };
    MindFusion.Diagramming.Diagram.xmlClassMap = new MindFusion.Collections.Dictionary();
    MindFusion.Diagramming.Diagram.create = function(element) {
        return mflayer.createControl(MindFusion.Diagramming.Diagram, null, null, null, element)
    };
    MindFusion.Diagramming.Diagram.find = function(id, parent) {
        return mflayer.findControl(id, parent)
    };
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var Path = MindFusion.Drawing.Path;
        var Point = MindFusion.Drawing.Point;
        var Size = MindFusion.Drawing.Size;
        var DashStyle = MindFusion.Drawing.DashStyle;
        var ArrayList = MindFusion.Collections.ArrayList;
        var Alignment = MindFusion.Diagramming.Alignment;
        var DiagramLink = mdiag.DiagramLink = function(parent, origin, destination) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(DiagramLink, this, [parent]);
            this.shape = mdiag.LinkShape.Polyline;
            this.points = [];
            this.points.push(new Point(0, 0));
            this.points.push(new Point(20, 20));
            this.angles = [];
            this.baseShapeSize = 5;
            this.headShapeSize = 5;
            this.validateParams(arguments);
            this.headShapeObj = {};
            this.baseShapeObj = {};
            this.setHeadShape(mdiag.Shapes.Triangle());
            this.text = "";
            this.textAlignment = Alignment.Center;
            this.textStyle = mdiag.LinkTextStyle.Center;
            this.textSize = new Size(0, 0);
            if (parent) {
                if (parent.linkShape !== undefined) {
                    this.setShape(parent.linkShape)
                }
                if (parent.linkSegments !== undefined) {
                    this.setSegmentCount(parent.linkSegments)
                }
                this.baseShapeSize = parent.linkBaseShapeSize;
                this.headShapeSize = parent.linkHeadShapeSize;
                if (parent.linkBaseShape) {
                    this.setBaseShape(parent.linkBaseShape)
                }
                if (parent.linkHeadShape) {
                    this.setHeadShape(parent.linkHeadShape)
                }
                if (parent.dynamicLinks != undefined) {
                    this.dynamic = parent.dynamicLinks
                }
                if (parent.linkTextStyle != undefined) {
                    this.textStyle = parent.linkTextStyle
                }
            }
            this.baseShapeBounds = new MindFusion.Drawing.Rect(this.points[0].x - this.baseShapeSize / 2, this.points[0].y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize);
            this.headShapeBounds = new MindFusion.Drawing.Rect(this.points[this.points.length - 1].x - this.headShapeSize / 2, this.points[this.points.length - 1].y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize);
            if (parent && DiagramLink.useStyles === false) {
                this.setPen(parent.linkPen);
                this.setBaseBrush(parent.linkBrush);
                this.setHeadBrush(parent.linkBrush)
            }
            this.textRenderer = new MindFusion.Diagramming.LinkTextRenderer(this);
            this.textRenderer.textStyle = this.textStyle;
            this.textRenderer.textAlignment = mdiag.Alignment.Center;
            this.updateText();
            if (parent) {
                this.autoRoute = parent.routeLinks
            }
            mdiag.Diagram.suppressSetDirty = false
        };
        DiagramLink.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(DiagramLink, this, "clone", []);
                copy.points = ArrayList.clone(this.points);
                copy.shape = this.shape;
                copy.autoRoute = this.autoRoute;
                copy.dynamic = this.dynamic;
                copy.cascadeStartHorizontal = this.cascadeStartHorizontal;
                copy.textRenderer = this.textRenderer.clone();
                copy.text = this.text;
                copy.textStyle = this.textStyle;
                copy.baseShapeSize = this.baseShapeSize;
                copy.headShapeSize = this.headShapeSize;
                copy.setBaseShape(this.baseShape);
                copy.setHeadShape(this.headShape);
                copy.setBaseBrush(this.baseBrush);
                copy.setHeadBrush(this.headBrush);
                copy.headStroke = this.getHeadStroke();
                copy.headStrokeThickness = this.getHeadStrokeThickness();
                copy.headStrokeDashStyle = this.getHeadStrokeDashStyle();
                copy.updateFromPoints();
                copy.updateText();
                if (this.labels != undefined) {
                    copy.labels = [];
                    for (var i = 0, l = this.labels.length; i < l; i++) {
                        var label = this.labels[i].clone();
                        label.link = copy;
                        copy.labels.push(label)
                    }
                }
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(DiagramLink, this, "toJson", []);
                json.origin = (this.origin) ? this.origin.instanceId : -1;
                json.destination = (this.destination) ? this.destination.instanceId : -1;
                json.originConnection = this.originConnection.relativePosition;
                json.destinationConnection = this.destinationConnection.relativePosition;
                json.originIndex = this.getOriginIndex();
                json.destinationIndex = this.getDestinationIndex();
                json.controlPoints = this.points;
                json.shape = this.shape;
                json.baseShape = (this.baseShape) ? this.baseShape.id : null;
                json.headShape = (this.headShape) ? this.headShape.id : null;
                json.baseShapeSize = this.baseShapeSize;
                json.headShapeSize = this.headShapeSize;
                json.baseBrush = this.getBaseBrush() || null;
                json.headBrush = this.getHeadBrush() || null;
                json.headStroke = this.getHeadStroke();
                json.headStrokeThickness = this.getHeadStrokeThickness();
                json.headStrokeDashStyle = this.getHeadStrokeDashStyle();
                json.dynamic = this.dynamic;
                json.cascadeStartHorizontal = this.cascadeStartHorizontal;
                json.textStyle = this.textStyle;
                json.autoRoute = this.autoRoute;
                if (this.originConnection.anchorPointDetails) {
                    json.originAnchor = this.originConnection.anchorPointDetails.index
                }
                if (this.destinationConnection.anchorPointDetails) {
                    json.destinationAnchor = this.destinationConnection.anchorPointDetails.index
                }
                if (this.labels != undefined) {
                    var labels = [];
                    for (var i = 0, l = this.labels.length; i < l; i++) {
                        labels.push(this.labels[i].toJson())
                    }
                    json.labels = labels
                }
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(DiagramLink, this, "fromJson", [json]);
                if (json.shape !== undefined) {
                    this.setShape(json.shape)
                }
                if (json.textStyle !== undefined) {
                    this.setTextStyle(json.textStyle)
                }
                this.setBaseShape(json.baseShape ? mdiag.Shape.fromId(json.baseShape) : null);
                if (json.baseBrush) {
                    this.setBaseBrush(json.baseBrush)
                }
                if (json.baseShapeSize) {
                    this.setBaseShapeSize(json.baseShapeSize)
                }
                this.setHeadShape(json.headShape ? mdiag.Shape.fromId(json.headShape) : null);
                if (json.headBrush) {
                    this.setHeadBrush(json.headBrush)
                }
                if (json.headShapeSize) {
                    this.setHeadShapeSize(json.headShapeSize)
                }
                if (json.headStroke) {
                    this.setHeadStroke(json.headStroke)
                }
                if (json.headStrokeThickness) {
                    this.setHeadStrokeThickness(json.headStrokeThickness)
                }
                if (json.headStrokeDashStyle) {
                    this.setHeadStrokeDashStyle(json.headStrokeDashStyle)
                }
                if (json.originIndex !== undefined) {
                    this.originConnection.setRow(json.originIndex, false)
                }
                if (json.destinationIndex !== undefined) {
                    this.destinationConnection.setRow(json.destinationIndex, false)
                }
                var originPoint = new MindFusion.Drawing.Point(json.originConnection.x, json.originConnection.y);
                var destinationPoint = new MindFusion.Drawing.Point(json.destinationConnection.x, json.destinationConnection.y);
                if (!originPoint.empty()) {
                    this.originConnection.relativePosition = originPoint
                }
                if (!destinationPoint.empty()) {
                    this.destinationConnection.relativePosition = destinationPoint
                }
                this.setPoints(json.controlPoints, true);
                if (json.originAnchor !== undefined) {
                    this.originConnection.anchorPointDetails.index = json.originAnchor
                }
                if (json.destinationAnchor !== undefined) {
                    this.destinationConnection.anchorPointDetails.index = json.destinationAnchor
                }
                if (json.labels) {
                    this.labels = [];
                    for (var i = 0, l = json.labels.length; i < l; i++) {
                        var label = new mdiag.LinkLabel(this);
                        label.fromJson(json.labels[i]);
                        this.labels.push(label)
                    }
                }
                this.dynamic = json.dynamic;
                this.cascadeStartHorizontal = json.cascadeStartHorizontal;
                if (json.autoRoute != undefined) {
                    this.autoRoute = json.autoRoute
                }
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(DiagramLink, this, "loadFromXml", [xmlElement, context]);
                var linkShape = context.fileVersion < 16 ? context.readInt("Style", xmlElement, this.shape) : context.readInt("Shape", xmlElement, this.shape);
                this.setShape(linkShape);
                this.setControlPoints(context.readPoints("Points", xmlElement));
                if (this.originConnection.setRow) {
                    this.originConnection.setRow(context.readInt("OriginRow", xmlElement), true)
                }
                if (this.destinationConnection.setRow) {
                    this.destinationConnection.setRow(context.readInt("DestinationRow", xmlElement), true)
                }
                this.originConnection.anchorPointDetails.index = context.readInt("OriginAnchor", xmlElement);
                this.originConnection.anchorPointDetails.point = this.getStartPoint();
                this.destinationConnection.anchorPointDetails.index = context.readInt("DestinationAnchor", xmlElement);
                this.destinationConnection.anchorPointDetails.point = this.getEndPoint();
                this.dynamic = context.readBool("Dynamic", xmlElement);
                this.autoRoute = context.readBool("AutoRoute", xmlElement);
                this.cascadeStartHorizontal = context.readBool("CascadeStartHorizontal", xmlElement);
                this.setTextStyle(context.readInt("TextStyle", xmlElement));
                if (context.classVersion > 1) {
                    this.setBaseShape(context.readShape("BaseShape", xmlElement));
                    this.setHeadShape(context.readShape("HeadShape", xmlElement))
                } else {
                    this.setBaseShape(context.readArrowheadV13("BaseShape", xmlElement));
                    this.setHeadShape(context.readArrowheadV13("HeadShape", xmlElement))
                }
                this.setHeadShapeSize(context.readFloat("HeadShapeSize", xmlElement));
                this.setBaseShapeSize(context.readFloat("BaseShapeSize", xmlElement));
                this.headBrush = context.readBrush("HeadBrush", xmlElement);
                this.baseBrush = context.readBrush("BaseBrush", xmlElement);
                var legacyPen = context.readPen("HeadPen", xmlElement);
                if (legacyPen) {
                    this.headStroke = legacyPen.brush;
                    this.headStrokeThickness = legacyPen.width;
                    this.headStrokeDashStyle = legacyPen.dashStyle
                } else {
                    this.headStroke = context.readBrush("HeadStroke", xmlElement);
                    this.headStrokeThickness = context.readFloat("HeadStrokeThickness", xmlElement);
                    this.headStrokeDashStyle = MindFusion.Drawing.DashStyle[context.readString("HeadStrokeDashStyle", xmlElement)];
                    if (this.headStrokeDashStyle === undefined) {
                        this.headStrokeDashStyle = context.readInt("HeadStrokeDashStyle", xmlElement)
                    }
                }
                var labelsElement = context.selectNode(xmlElement, "Labels");
                if (labelsElement) {
                    this.labels = [];
                    var labelElements = labelsElement.getElementsByTagName("Label");
                    for (var i = 0; i < labelElements.length; ++i) {
                        var labelElement = labelElements[i];
                        var label = new mdiag.LinkLabel(this);
                        label.loadFromXml(labelElement, context);
                        labels.push(label)
                    }
                }
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(DiagramLink, this, "saveToXml", [xmlElement, context]);
                context.writeItemReference(mflayer.isInstanceOfType(mdiag.DummyNode, this.originConnection.node) ? null : this.originConnection.node, "Origin", xmlElement);
                context.writePointF(this.originConnection.relativePosition, "OriginRelative", xmlElement);
                context.writeInt(this.getOriginAnchor(), "OriginAnchor", xmlElement);
                context.writeItemReference(mflayer.isInstanceOfType(mdiag.DummyNode, this.destinationConnection.node) ? null : this.destinationConnection.node, "Destination", xmlElement);
                context.writePointF(this.destinationConnection.relativePosition, "DestinationRelative", xmlElement);
                context.writeInt(this.getDestinationAnchor(), "DestinationAnchor", xmlElement);
                if (this.originConnection.setRow) {
                    context.writeInt(this.originConnection.row, "OriginRow", xmlElement)
                }
                if (this.destinationConnection.setRow) {
                    context.writeInt(this.destinationConnection.row, "DestinationRow", xmlElement)
                }
                context.writeInt(this.getShape(), "Shape", xmlElement);
                context.writeInt(this.getSegmentCount(), "SegmentCount", xmlElement);
                context.writePointCollection(this.points, "Points", xmlElement);
                context.writeBool(this.dynamic, "Dynamic", xmlElement);
                context.writeBool(this.autoRoute, "AutoRoute", xmlElement);
                context.writeBool(true, "AutoSnapToNode", xmlElement);
                context.writeBool(this.cascadeStartHorizontal, "CascadeStartHorizontal", xmlElement);
                context.writeInt(this.getTextStyle(), "TextStyle", xmlElement);
                context.writeShape(this.getBaseShape(), "BaseShape", xmlElement);
                context.writeShape(this.getHeadShape(), "HeadShape", xmlElement);
                context.writeFloat(this.getHeadShapeSize(), "HeadShapeSize", xmlElement);
                context.writeFloat(this.getBaseShapeSize(), "BaseShapeSize", xmlElement);
                context.writeBrush(this.headBrush, "HeadBrush", xmlElement);
                context.writeBrush(this.baseBrush, "BaseBrush", xmlElement);
                if (this.headStroke !== undefined) {
                    context.writeBrush(this.headStroke, "HeadStroke", xmlElement)
                }
                if (this.headStrokeThickness !== undefined) {
                    context.writeFloat(this.headStrokeThickness, "HeadStrokeThickness", xmlElement)
                }
                if (this.headStrokeDashStyle !== undefined) {
                    context.writeInt(this.headStrokeDashStyle, "HeadStrokeDashStyle", xmlElement)
                }
                if (this.labels) {
                    var labelsElement = context.addChildElement("Labels", xmlElement);
                    labels.forEach(function(label) {
                        var labelElement = context.addChildElement("Label", labelsElement);
                        label.saveToXml(labelElement, context)
                    })
                }
            },
            invalidate: function() {
                mflayer.callBaseMethod(DiagramLink, this, "invalidate");
                if (this.labels) {
                    for (var i = 0, l = this.labels.length; i < l; i++) {
                        this.labels[i].invalidate()
                    }
                }
            },
            setShape: function(value) {
                if (this.shape != value) {
                    var segmentCount = this.getSegmentCount();
                    this.shape = value;
                    if (this.isReflexive() && this.shape == mdiag.LinkShape.Cascading) {
                        this.setSegmentCount(3)
                    } else {
                        if (this.shape == mdiag.LinkShape.Cascading && segmentCount == 1) {
                            this.setSegmentCount(2)
                        } else {
                            this.setSegmentCount(segmentCount)
                        }
                    }
                    if (this.isReflexive()) {
                        this.shapeImpl().resetSelfLoopPoints(this, true)
                    }
                    if (!this.shapeImpl().pointsValid(this)) {
                        this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                    }
                    this.resetCrossings();
                    this.invalidate()
                }
            },
            getShape: function() {
                return this.shape
            },
            shapeImpl: function() {
                return Shapes[this.shape]
            },
            setControlPoints: function(value) {
                this.points = value;
                this.updateFromPoints();
                this.setDiagramDirty()
            },
            getControlPoints: function() {
                return this.points
            },
            setTextStyle: function(value) {
                if (this.textStyle != value) {
                    this.textStyle = value;
                    this.updateText();
                    this.invalidate();
                    this.setDiagramDirty()
                }
            },
            getTextStyle: function() {
                return this.textStyle
            },
            setTextAlignment: function(value) {
                if (this.textAlignment != value) {
                    this.textAlignment = value;
                    this.updateText();
                    this.invalidate();
                    this.setDiagramDirty()
                }
            },
            getTextAlignment: function() {
                return this.textAlignment
            },
            getTextToEdit: function() {
                return this.text
            },
            setText: function(value) {
                if (value != undefined && value !== this.text) {
                    this.text = value + "";
                    this.invalidate()
                }
            },
            getText: function() {
                return this.text
            },
            raiseClicked: function(mousePosition, mouseButton) {
                var args = new mdiag.LinkEventArgs({
                    link: this,
                    mousePosition: mousePosition,
                    mouseButton: mouseButton
                });
                this.parent.raiseEvent(mdiag.Events.linkClicked, args);
                return args.getHandled()
            },
            raiseDoubleClicked: function(mousePosition, mouseButton) {
                var args = new mdiag.LinkEventArgs({
                    link: this,
                    mousePosition: mousePosition,
                    mouseButton: mouseButton
                });
                this.parent.raiseEvent(mdiag.Events.linkDoubleClicked, args);
                return args.getHandled()
            },
            updateIntersections: function() {
                this.points[0] = this.originConnection.getInitialPoint();
                this.points[this.points.length - 1] = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[0] = this.originConnection.getIntersection(this.points[0], this.points[1]);
                    this.points[this.points.length - 1] = this.destinationConnection.getIntersection(this.points[this.points.length - 1], this.points[this.points.length - 2])
                }
                this.originConnection.saveEndRelative();
                this.destinationConnection.saveEndRelative()
            },
            updateOriginIntersection: function() {
                this.points[0] = this.originConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[0] = this.originConnection.getIntersection(this.points[0], this.points[1])
                }
                this.originConnection.saveEndRelative();
                this.updateFromPoints();
                if (this.autoRoute) {
                    this.route({
                        updateFromPoints: false
                    })
                }
            },
            updateDestinationIntersection: function() {
                this.points[this.points.length - 1] = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[this.points.length - 1] = this.destinationConnection.getIntersection(this.points[this.points.length - 1], this.points[this.points.length - 2])
                }
                this.destinationConnection.saveEndRelative();
                this.updateFromPoints();
                if (this.autoRoute) {
                    this.route({
                        updateFromPoints: false
                    })
                }
            },
            doRoute: function() {
                for (var i = 0, l = this.points.length - 1; i < l; i++) {
                    var p1 = this.points[i];
                    var p2 = this.points[i + 1];
                    this.bounds = this.getBounds();
                    this.angles.push(Point.angleBetween(p1, p2));
                    var ap1 = Point.addVector(p1, {
                        x: this.baseShapeSize / 2,
                        y: this.baseShapeSize / 2
                    });
                    var ap2 = Point.addVector(p2, {
                        x: this.baseShapeSize / 2,
                        y: this.baseShapeSize / 2
                    });
                    if (i === 0) {
                        this.baseShapeBounds = new MindFusion.Drawing.Rect(p1.x - this.baseShapeSize / 2, p1.y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize)
                    }
                    if (i === this.points.length - 2) {
                        this.headShapeBounds = new MindFusion.Drawing.Rect(p2.x - this.headShapeSize / 2, p2.y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize)
                    }
                }
            },
            startDrag: function(ist) {
                mflayer.callBaseMethod(DiagramLink, this, "startDrag", [ist]);
                if (ist.action === mdiag.Action.Create && this.originConnection != null) {
                    this.originConnection.chooseBestAnchorPoint(ist.startPoint);
                    this.points[0] = this.originConnection.anchorPointDetails.point;
                    this.updateFromPoints()
                }
            },
            updateDrag: function(ist) {
                var handle = ist.adjustmentHandle.index;
                var originalPoints = ist.originalStates.get(this).controlPoints;
                var originalPoint = new Point(originalPoints[handle].x, originalPoints[handle].y);
                var point = originalPoint.addVector(ist.delta());
                var draggingEndPoint = (handle === 0 || handle === this.points.length - 1);
                if (draggingEndPoint) {
                    this.updateTargetConnection(point, handle > 0)
                }
                var useTargetPoint = draggingEndPoint && this.targetConnection != null && !mflayer.isInstanceOfType(mdiag.DummyNode, this.targetConnection.node);
                this.points[handle] = point = useTargetPoint ? this.targetConnection.anchorPointDetails.point : point;
                if (ist.action === mdiag.Action.Create) {
                    this.arrangePoints();
                    if (!this.shapeImpl().pointsValid(this)) {
                        this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                    }
                } else {
                    this.shapeImpl().updateRelatedPoints(this, point, ist)
                }
                if (this.dynamic && this.shape != mdiag.LinkShape.Cascading && this.points.length > 2 && (handle == 1 || handle == this.points.length - 2)) {
                    this.updatePosFromOrgAndDest()
                }
                this.updateFromPoints(true, originalPoints)
            },
            endDrag: function(ist) {
                var routed = false;
                var handle = ist.adjustmentHandle.index;
                var currentPoint = ist.currentPoint;
                if (handle === 0 || handle === this.points.length - 1) {
                    if (handle === 0) {
                        this.setupOriginConnection(this.targetConnection)
                    } else {
                        if (handle === this.points.length - 1) {
                            this.setupDestConnection(this.targetConnection)
                        }
                    }
                    this.originConnection.saveEndRelative();
                    this.destinationConnection.saveEndRelative();
                    this.origin = this.originConnection.node;
                    this.destination = this.destinationConnection.node;
                    if (ist.action === mdiag.Action.Create) {
                        if (this.origin == this.destination && !mflayer.isInstanceOfType(mdiag.DummyNode, this.origin)) {
                            this.setLoopShape()
                        } else {
                            this.arrangePoints();
                            if (!this.shapeImpl().pointsValid(this)) {
                                this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                            }
                        }
                    }
                    if (this.autoRoute) {
                        this.route({
                            updateFromPoints: false
                        })
                    }
                }
                this.updateFromPoints()
            },
            allowDrag: function(ist) {
                var selHandle = ist.adjustmentHandle.index;
                if (selHandle !== 0 && selHandle !== (this.points.length - 1)) {
                    return true
                }
                if (this.targetConnection == null) {
                    return this.parent.allowUnconnectedLinks
                }
                if (!this.targetConnection.node.allowIncomingLinks && selHandle === this.points.length - 1) {
                    return false
                }
                if (!this.parent.allowSelfLoops) {
                    if (selHandle == 0 && this.destination == this.targetConnection.node) {
                        return false
                    }
                    if (selHandle == this.points.length - 1 && this.origin == this.targetConnection.node) {
                        return false
                    }
                }
                return true
            },
            saveLocationState: function() {
                return {
                    controlPoints: ArrayList.clone(this.points)
                }
            },
            restoreLocationState: function(ist) {
                var state = ist.originalStates.get(this);
                if (state != null) {
                    var canceledPoints = this.points;
                    this.points = state.controlPoints;
                    this.updateFromPoints(true, canceledPoints)
                }
            },
            updateTargetConnection: function(point, incoming) {
                var target = this.parent.getNodeAt(point, true, true);
                if (target == null) {
                    target = this.parent.getNearestNode(point, this.parent.autoSnapDistance, (incoming) ? this.origin : this.destination, true)
                }
                if (target != null) {
                    if (incoming && !target.allowIncomingLinks || !incoming && !target.allowOutgoingLinks) {
                        target = null
                    }
                }
                if (target == null && this.parent.allowUnconnectedLinks) {
                    target = this.getDummyNode()
                }
                if (target) {
                    if (this.targetConnection == null || (this.targetConnection != null && this.targetConnection.linkChanges(target, point))) {
                        this.targetConnection = target.createConnectionPoint(this, point, incoming)
                    }
                    if (this.targetConnection != null) {
                        this.targetConnection.chooseBestAnchorPoint(point)
                    }
                    return
                }
                this.targetConnection = null
            },
            getEditRect: function(point) {
                var textBoxSize = new MindFusion.Drawing.Size(100, 25 / this.parent.scale);
                return new MindFusion.Drawing.Rect(point.x - textBoxSize.width / 2, point.y - textBoxSize.height / 2, textBoxSize.width, textBoxSize.height)
            },
            setOrigin: function(origin, details) {
                var external = details ? false : true;
                if (this.originConnection != null) {
                    this.originConnection.removeLinkFromNode();
                    this.originConnection = null
                }
                this.origin = origin;
                if (this.origin != null) {
                    if (!details) {
                        details = origin.getAnchor(this.getEndPoint(), this, false)
                    }
                    this.originConnection = this.origin.createConnectionPoint(this, details.point, false, true);
                    this.originConnection.anchorPointDetails = details;
                    this.points[0] = details.point
                }
                if (external) {
                    this.originConnection.addLinkToNode();
                    if (this.getOriginAnchor() == -1) {
                        this.updateIntersections()
                    }
                    this.shapeImpl().updateFromEndPoints(this, true);
                    this.invalidate()
                }
            },
            getOrigin: function() {
                return this.origin
            },
            setOriginAnchor: function(index) {
                var details = this.origin.getAnchorFromIndex(index);
                if (!details) {
                    return
                }
                this.originConnection.anchorPointDetails = details;
                this.points[0] = details.point;
                this.shapeImpl().updateFromEndPoints(this, true);
                this.invalidate()
            },
            getOriginAnchor: function() {
                if (!this.originConnection.anchorPointDetails) {
                    return -1
                } else {
                    return this.originConnection.anchorPointDetails.index
                }
            },
            setDestination: function(destination, details) {
                var external = details ? false : true;
                if (this.destinationConnection != null) {
                    this.destinationConnection.removeLinkFromNode();
                    this.destinationConnection = null
                }
                this.destination = destination;
                if (this.destination != null) {
                    if (!details) {
                        details = destination.getAnchor(this.getStartPoint(), this, true)
                    }
                    this.destinationConnection = this.destination.createConnectionPoint(this, details.point, true, true);
                    this.destinationConnection.anchorPointDetails = details;
                    this.points[this.points.length - 1] = details.point;
                    this.destinationConnection.saveEndRelative()
                }
                if (external) {
                    this.destinationConnection.addLinkToNode();
                    if (this.getDestinationAnchor() == -1) {
                        this.updateIntersections()
                    }
                    this.shapeImpl().updateFromEndPoints(this, true);
                    this.invalidate()
                }
            },
            getDestination: function() {
                return this.destination
            },
            setDestinationAnchor: function(index) {
                var details = this.destination.getAnchorFromIndex(index, true);
                if (!details) {
                    return
                }
                this.destinationConnection.anchorPointDetails = details;
                this.points[this.points.length - 1] = details.point;
                this.shapeImpl().updateFromEndPoints(this, true);
                this.invalidate()
            },
            getDestinationAnchor: function() {
                if (!this.destinationConnection.anchorPointDetails) {
                    return -1
                } else {
                    return this.destinationConnection.anchorPointDetails.index
                }
            },
            isConnected: function() {
                if (this.origin == null || mflayer.isInstanceOfType(mdiag.DummyNode, this.origin)) {
                    return false
                }
                if (this.destination == null || mflayer.isInstanceOfType(mdiag.DummyNode, this.destination)) {
                    return false
                }
                return true
            },
            isReflexive: function() {
                return this.originConnection != null && this.destinationConnection != null && this.originConnection.sameNode(this.destinationConnection)
            },
            resetLink: function() {
                this.shape = mdiag.LinkShape.Polyline;
                this.points.length = 2;
                this.updateIntersections();
                this.updateFromPoints()
            },
            copyPoints: function(points, dx, dy, updateIntersections, skipRoute) {
                if (!points) {
                    this.resetLink();
                    return
                }
                this.points = [];
                for (var i = 0, l = points.length; i < l; i++) {
                    var p = points[i];
                    this.points.push(new Point(p.x + dx, p.y + dy))
                }
                if (updateIntersections) {
                    this.updateIntersections();
                    this.updateFromPoints()
                }
                if (!skipRoute) {
                    this.shapeImpl().updateFromRoute(this)
                }
            },
            updatePosFromOrgAndDest: function() {
                if (this.dynamic && this.origin != this.destination) {
                    this.putEndPointsAtNodeBorders(mdiag.Action.Modify, false);
                    if (mdiag.ContainerNode.usingContainerNodes) {
                        var originContainer = mdiag.ContainerNode.getFoldedContainer(this.getOrigin());
                        if (originContainer != null) {
                            this.points[0] = this.originConnection.getLocation();
                            if (this.shape == mdiag.LinkShape.Cascading) {
                                CascadingShape.alignFirstCascadingSegment(this)
                            }
                        }
                        var destContainer = mdiag.ContainerNode.getFoldedContainer(this.getDestination());
                        if (destContainer != null) {
                            this.points[this.points.length - 1] = this.destinationConnection.getLocation();
                            if (this.shape == mdiag.LinkShape.Cascading) {
                                CascadingShape.AlignLastCascadingSegment(this)
                            }
                        }
                    }
                } else {
                    this.points[0] = this.originConnection.getLocation();
                    this.points[this.points.length - 1] = this.destinationConnection.getLocation()
                }
                this.shapeImpl().updateFromEndPoints(this, false)
            },
            updateFromPoints: function() {
                var updateConnections = true;
                if (arguments.length > 0) {
                    updateConnections = arguments[0]
                }
                var oldPoints = null;
                if (arguments.length > 1) {
                    oldPoints = arguments[1]
                }
                this.angles = [];
                this.doRoute();
                if (updateConnections) {
                    if (this.originConnection != null) {
                        this.originConnection.saveEndRelative()
                    }
                    if (this.destinationConnection != null) {
                        this.destinationConnection.saveEndRelative()
                    }
                }
                if (this.baseShape) {
                    if (!this.baseShapeRenderer) {
                        this.baseShapeRenderer = new mdiag.ShapeRenderer(this.baseShape)
                    }
                    this.baseShapeRenderer.updateData(this.baseShapeBounds, this.angles[0] + 90)
                }
                if (this.headShape) {
                    if (!this.headShapeRenderer) {
                        this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                    }
                    this.headShapeRenderer.updateData(this.headShapeBounds, this.angles[this.angles.length - 1] + 90)
                }
                var parent = this.getParent();
                if (parent && parent.getLinkCrossings() != mdiag.LinkCrossings.Straight) {
                    if (oldPoints) {
                        var invalidRect = this.getPointsBounds(oldPoints);
                        invalidRect = invalidRect.union(this.getBounds());
                        this.resetCrossings(invalidRect)
                    } else {
                        this.resetCrossings()
                    }
                }
                this.invalidate()
            },
            updateNodeCollections: function() {
                if (this.originConnection != null) {
                    this.originConnection.addLinkToNode()
                }
                if (this.destinationConnection != null) {
                    this.destinationConnection.addLinkToNode()
                }
            },
            setupOriginConnection: function(connection) {
                var oldConnection = this.originConnection;
                this.originConnection = connection;
                if (oldConnection != null) {
                    oldConnection.removeLinkFromNode()
                }
                this.originConnection.addLinkToNode()
            },
            setupDestConnection: function(connection) {
                var oldConnection = this.destinationConnection;
                this.destinationConnection = connection;
                if (oldConnection != null) {
                    oldConnection.removeLinkFromNode()
                }
                this.destinationConnection.addLinkToNode()
            },
            handleAtPoint: function(point) {
                if (!this.parent) {
                    return null
                }
                var size = this.getEffectiveHandlesSize();
                var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                var handles = this.points;
                var rect = new Rect(0, 0, size, size);
                if (this.parent) {
                    rect = rect.inflate(this.parent.touchThreshold)
                }
                for (var i = 0; i < handles.length; ++i) {
                    rect.setCenter(handles[i]);
                    if (rect.containsPoint(point)) {
                        return {
                            item: this,
                            index: i
                        }
                    }
                }
            },
            validateParams: function(params) {
                if (params.length === 0) {
                    return
                }
                this.parent = params[0];
                if (params[1] && mflayer.isInstanceOfType(mdiag.DiagramNode, params[1])) {
                    this.origin = params[1];
                    this.setOrigin(this.origin, this.origin.getAnchor(this.origin.getCenter(), this, false))
                } else {
                    var point = params[1] && mflayer.isInstanceOfType(Point, params[1]) ? params[1] : this.points[0];
                    this.originConnection = new mdiag.DummyConnectionPoint(this, false, point);
                    this.origin = this.getDummyNode()
                }
                if (params[2] && mflayer.isInstanceOfType(mdiag.DiagramNode, params[2])) {
                    this.destination = params[2];
                    this.setDestination(this.destination, this.destination.getAnchor(this.destination.getCenter(), this, true))
                } else {
                    var point = params[2] && mflayer.isInstanceOfType(Point, params[2]) ? params[2] : this.points[this.points.length - 1];
                    this.destinationConnection = new mdiag.DummyConnectionPoint(this, true, point);
                    this.destination = this.getDummyNode()
                }
                this.updateIntersections();
                this.updateFromPoints();
                this.putEndPointsAtNodeBorders(mdiag.Action.Modify, false)
            },
            setStartPoint: function(value) {
                this.points[0] = value
            },
            getStartPoint: function() {
                return this.points[0].clone()
            },
            setEndPoint: function(value) {
                this.points[this.points.length - 1] = value
            },
            getEndPoint: function() {
                return this.points[this.points.length - 1].clone()
            },
            getHandlePosition: function(handle) {
                return this.points[handle]
            },
            getBaseType: function() {
                return this.constructor.__baseType.__typeName
            },
            getDummyNode: function() {
                if (this.parent) {
                    return this.parent.dummy
                }
                return new mdiag.DummyNode()
            },
            containsPoint: function(point) {
                var rect = this.getBounds();
                var lineHitTest = -1;
                if (this.parent.linkHitDistance != 0) {
                    lineHitTest = this.parent.linkHitDistance
                } else {
                    lineHitTest = mdiag.Utils.getLineHitTest(this.parent.measureUnit)
                }
                var inflate = lineHitTest / 2;
                var maxDist = lineHitTest * 2 / 3;
                if (this.labelFromPoint(point) != null) {
                    return true
                }
                rect = mdiag.Utils.inflate(rect, inflate, inflate);
                if (!rect.containsPoint(point)) {
                    return false
                }
                if (this.shapeImpl().containsPoint(this, point, maxDist)) {
                    return true
                }
                if (this.selected && this.handleAtPoint(point)) {
                    return true
                }
                return false
            },
            getBounds: function() {
                return this.getPointsBounds(this.points)
            },
            getPointsBounds: function(points) {
                var p1 = points[0];
                var p2 = points[points.length - 1];
                var l = Math.min(p1.x, p2.x);
                var r = Math.max(p1.x, p2.x);
                var t = Math.min(p1.y, p2.y);
                var b = Math.max(p1.y, p2.y);
                for (var i = 1; i < points.length - 1; ++i) {
                    l = Math.min(l, points[i].x);
                    t = Math.min(t, points[i].y);
                    r = Math.max(r, points[i].x);
                    b = Math.max(b, points[i].y)
                }
                return new MindFusion.Drawing.Rect(l, t, r - l, b - t)
            },
            updateText: function() {
                if (!this.parent) {
                    return
                }
                var mgeo = MindFusion.Geometry;
                this.textRenderer.clearLayout();
                this.textSize = this.parent.measureString(this.text, this.getEffectiveFont());
                var segmentCount = this.getSegmentCount();
                if (this.textStyle == mdiag.LinkTextStyle.Rotate) {
                    var pt = Math.floor(this.points.length / 2 - 1);
                    var jump = 1;
                    var ptBest = pt;
                    var r = 0,
                        a = 0,
                        rBest = 0;
                    if (this.shape != mdiag.LinkShape.Bezier) {
                        if (this.shape == mdiag.LinkShape.Cascading || (this.shape == mdiag.LinkShape.Polyline && segmentCount % 2 == 1)) {
                            do {
                                var ar = mgeo.cartesianToPolar(this.points[pt], this.points[pt + 1]);
                                a = ar.a;
                                r = ar.r;
                                if (r > rBest) {
                                    rBest = r;
                                    ptBest = pt
                                }
                                pt = pt + jump;
                                jump = -mdiag.Utils.sign(jump) * (Math.abs(jump) + 1);
                                if (pt < 0 || pt >= this.points.length - 1) {
                                    break
                                }
                            } while (this.textSize.width > r);
                            pt = ptBest;
                            x = (this.points[pt].x + this.points[pt + 1].x) / 2;
                            y = (this.points[pt].y + this.points[pt + 1].y) / 2
                        } else {
                            pt = pt + 1;
                            x = this.points[pt].x;
                            y = this.points[pt].y
                        }
                    } else {
                        if (segmentCount % 2 == 1) {
                            pt = Math.floor((pt + 1) / 4);
                            var ptMid = mdiag.Utils.getBezierPt(this.points, pt, 0.5);
                            x = ptMid.x;
                            y = ptMid.y
                        } else {
                            pt = Math.floor((pt + 1) / 4);
                            var ptMid = this.points[(pt + 1) * 3];
                            x = ptMid.x;
                            y = ptMid.y
                        }
                    }
                    if (this.shape != mdiag.LinkShape.Bezier) {
                        if (this.shape == mdiag.LinkShape.Cascading || (this.shape == mdiag.LinkShape.Polyline && segmentCount % 2 == 1)) {
                            var pt1 = this.points[pt];
                            var pt2 = this.points[pt + 1];
                            var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                            a = ar.a;
                            r = ar.r
                        } else {
                            var r1 = 0,
                                a1 = 0;
                            var ar = mgeo.cartesianToPolarDegrees(this.points[pt - 1], this.points[pt]);
                            a = ar.a;
                            r = ar.r;
                            var ar = mgeo.cartesianToPolarDegrees(this.points[pt], this.points[pt + 1]);
                            a1 = ar.a;
                            r2 = ar.r;
                            a = (a + a1) / 2
                        }
                    } else {
                        if (segmentCount % 2 == 1) {
                            var pt1 = mdiag.Utils.getBezierPt(this.points, pt, 0.45);
                            var pt2 = mdiag.Utils.getBezierPt(this.points, pt, 0.55);
                            var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                            a = ar.a;
                            r = ar.r
                        } else {
                            var pt1 = mdiag.Utils.getBezierPt(this.points, pt, 0.95);
                            var pt2 = mdiag.Utils.getBezierPt(this.points, pt + 1, 0.05);
                            var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                            a = ar.a;
                            r = ar.r
                        }
                    }
                    a = 180 - a;
                    if (a > 90 && a < 270) {
                        a -= 180
                    }
                    this.textRenderer.strings.push(this.text);
                    this.textRenderer.angles.push(a);
                    this.textRenderer.rectangles.push(new Rect(x, y, this.textSize.width, this.textSize.height))
                } else {
                    if (this.textStyle == mdiag.LinkTextStyle.Center) {
                        if (this.points.length % 2 == 1) {
                            x = this.points[Math.floor(this.points.length / 2)].x;
                            y = this.points[Math.floor(this.points.length / 2)].y
                        } else {
                            x = this.points[this.points.length / 2 - 1].x + this.points[this.points.length / 2].x;
                            y = this.points[this.points.length / 2 - 1].y + this.points[this.points.length / 2].y;
                            x /= 2;
                            y /= 2
                        }
                        this.textRenderer.strings.push(this.text);
                        this.textRenderer.angles.push(0);
                        this.textRenderer.rectangles.push(new Rect(x, y, this.textSize.width, this.textSize.height))
                    } else {
                        if (this.textStyle == mdiag.LinkTextStyle.OverLongestSegment) {
                            var textAlignment = Alignment.Center;
                            var lineAlignment = Alignment.Center;
                            var longest = this.getLongestSegment();
                            var nearPoint = this.getNearPoint(longest).clone();
                            var farPoint = this.getFarPoint(longest).clone();
                            var dx = Math.abs(nearPoint.x - farPoint.x);
                            var dy = Math.abs(nearPoint.y - farPoint.y);
                            if (dx > dy * 1.3 && this.textAlignment != Alignment.Center) {
                                if (nearPoint.x < farPoint.x && this.textAlignment == Alignment.Near) {
                                    textAlignment = Alignment.Near;
                                    nearPoint.y -= this.textSize.height / 2;
                                    nearPoint.x += this.headShapeSize;
                                    this.textRenderer.rectangles.push(new Rect(nearPoint.x, nearPoint.y, this.textSize.width, this.textSize.height))
                                } else {
                                    if (nearPoint.x > farPoint.x && this.textAlignment == Alignment.Far) {
                                        textAlignment = Alignment.Near;
                                        farPoint.y -= this.textSize.height / 2;
                                        farPoint.x += this.headShapeSize;
                                        this.textRenderer.rectangles.push(new Rect(farPoint.x, farPoint.y, this.textSize.width, this.textSize.height))
                                    } else {
                                        if (nearPoint.x < farPoint.x && this.textAlignment == Alignment.Far) {
                                            textAlignment = Alignment.Far;
                                            farPoint.x -= this.headShapeSize;
                                            this.textRenderer.rectangles.push(new Rect(farPoint.x - this.textSize.width, farPoint.y - this.textSize.height / 2, this.textSize.width, this.textSize.height))
                                        } else {
                                            textAlignment = Alignment.Far;
                                            nearPoint.x -= this.headShapeSize;
                                            this.textRenderer.rectangles.push(new Rect(nearPoint.x - this.textSize.width, nearPoint.y - this.textSize.height / 2, this.textSize.width, this.textSize.height))
                                        }
                                    }
                                }
                            } else {
                                var center = this.getSegmentCenter(longest);
                                this.textRenderer.rectangles.push(new Rect(center.x, center.y, this.textSize.width, this.textSize.height))
                            }
                            this.textRenderer.strings.push(this.text);
                            this.textRenderer.angles.push(0);
                            this.textRenderer.textAlignment = textAlignment;
                            this.textRenderer.lineAlignment = lineAlignment
                        } else {
                            if (this.textStyle == mdiag.LinkTextStyle.Follow) {
                                this.textRenderer.textAlignment = Alignment.Near;
                                this.textRenderer.lineAlignment = Alignment.Near;
                                var poly = ArrayList.clone(this.points);
                                var start = 0;
                                if (this.shape == mdiag.LinkShape.Bezier) {
                                    var content = [];
                                    this.shapeImpl().createElements(this, content);
                                    var approximation = mdiag.Utils.getApproximatingContext();
                                    for (var i = 0; i < content.length; i++) {
                                        content[i].addToContext(approximation)
                                    }
                                    poly = approximation.transformAndGetPoints();
                                    start = 1
                                }
                                if (poly[0].x > poly[poly.length - 1].x) {
                                    for (var i = 0; i < poly.length / 2; i++) {
                                        var t = poly[i];
                                        poly[i] = poly[poly.length - i - 1];
                                        poly[poly.length - i - 1] = t
                                    }
                                }
                                var textHeight = this.textSize.height;
                                var startPoint = poly[0];
                                for (var i = start; i < poly.length - 1; i++) {
                                    var p = poly[i];
                                    var t = poly[i + 1];
                                    var ar = mgeo.cartesianToPolarDegrees(t, p);
                                    var a = ar.a;
                                    var r = ar.r;
                                    var angle = 0;
                                    var a2 = 0;
                                    var r2 = 0;
                                    if (i < poly.length - 2) {
                                        var p2 = poly[i + 1];
                                        var t2 = poly[i + 2];
                                        var ar = mgeo.cartesianToPolarDegrees(p2, t2);
                                        a2 = ar.a;
                                        r2 = ar.r;
                                        if (a2 < a) {
                                            a2 += 360
                                        }
                                        angle = a2 - a
                                    }
                                    var rr = 0;
                                    var aa = 0;
                                    var ar = mgeo.cartesianToPolarDegrees(startPoint, t);
                                    aa = ar.a;
                                    rr = ar.r;
                                    var d1 = startPoint;
                                    var d2 = t;
                                    var d3 = new Point(0, 0);
                                    var d4 = new Point(0, 0);
                                    var width;
                                    if (angle < 180) {
                                        d4 = mgeo.polarToCartesianDegrees(d1, {
                                            a: a - 90,
                                            r: textHeight
                                        });
                                        d3 = mgeo.polarToCartesianDegrees(d2, {
                                            a: a - 90,
                                            r: textHeight
                                        });
                                        width = rr;
                                        startPoint = t
                                    } else {
                                        d4 = mgeo.polarToCartesianDegrees(d1, {
                                            a: a - 90,
                                            r: textHeight
                                        });
                                        var alpha2 = (360 - angle) / 2;
                                        var xx = textHeight / Math.sin(mdiag.Utils.radians(alpha2));
                                        var xxProj = Math.sqrt(Math.pow(xx, 2) - Math.pow(textHeight, 2));
                                        if (xxProj > rr) {
                                            xxProj = rr;
                                            xx = Math.sqrt(Math.pow(xxProj, 2) + Math.pow(textHeight, 2))
                                        }
                                        d3 = mgeo.polarToCartesianDegrees(d2, {
                                            a: a - alpha2,
                                            r: xx
                                        });
                                        d2 = mgeo.polarToCartesianDegrees(d2, {
                                            a: a,
                                            r: xxProj
                                        });
                                        width = rr - xxProj;
                                        if (xxProj > r2) {
                                            xxProj = r2
                                        }
                                        startPoint = mgeo.polarToCartesianDegrees(t, {
                                            a: a2,
                                            r: xxProj
                                        })
                                    }
                                    this.textRenderer.rectangles.push(new Rect(d4.x, d4.y, width, textHeight));
                                    this.textRenderer.angles.push(180 - a)
                                }
                                var tempText = this.text;
                                for (var i = 0; i < this.textRenderer.rectangles.length; i++) {
                                    var textRect = this.textRenderer.rectangles[i];
                                    var chars = this.fit(tempText, textRect.width, this.getEffectiveFont());
                                    if (chars == 0) {
                                        this.textRenderer.strings.push("");
                                        continue
                                    }
                                    var part = tempText.substring(0, chars);
                                    tempText = tempText.substring(chars);
                                    this.textRenderer.strings.push(part)
                                }
                            } else {
                                if (this.textStyle == mdiag.LinkTextStyle.MiddleSegment) {
                                    if (this.points.length % 2 == 1) {
                                        var centerPoint = Math.floor(this.points.length / 2);
                                        var cp = this.points[centerPoint];
                                        var pp = this.points[centerPoint - 1];
                                        var np = this.points[centerPoint + 1];
                                        if (mgeo.distance(cp, pp) > mgeo.distance(cp, np)) {
                                            x = (pp.x + cp.x) / 2;
                                            y = (pp.y + cp.y) / 2
                                        } else {
                                            x = (np.x + cp.x) / 2;
                                            y = (np.y + cp.y) / 2
                                        }
                                    } else {
                                        x = this.points[this.points.length / 2 - 1].x + this.points[this.points.length / 2].x;
                                        y = this.points[this.points.length / 2 - 1].y + this.points[this.points.length / 2].y;
                                        x /= 2;
                                        y /= 2
                                    }
                                    this.textRenderer.strings.push(this.text);
                                    this.textRenderer.angles.push(0);
                                    this.textRenderer.rectangles.push(new Rect(x, y, this.textSize.width, this.textSize.height))
                                } else {
                                    if (this.textStyle == mdiag.LinkTextStyle.MiddleSegmentRotated) {
                                        var pt = Math.floor(this.points.length / 2 - 1);
                                        var jump = 1;
                                        var ptBest = pt;
                                        var r = 0,
                                            a = 0,
                                            rBest = 0;
                                        if (this.shape != mdiag.LinkShape.Bezier) {
                                            do {
                                                var ar = mgeo.cartesianToPolarDegrees(this.points[pt], this.points[pt + 1]);
                                                a = ar.a;
                                                r = ar.r;
                                                if (r > rBest) {
                                                    rBest = r;
                                                    ptBest = pt
                                                }
                                                pt = pt + jump;
                                                jump = -mdiag.Utils.sign(jump) * (Math.abs(jump) + 1);
                                                if (pt < 0 || pt >= this.points.length - 1) {
                                                    break
                                                }
                                            } while (this.textSize.width > r);
                                            pt = ptBest;
                                            x = (this.points[pt].x + this.points[pt + 1].x) / 2;
                                            y = (this.points[pt].y + this.points[pt + 1].y) / 2
                                        } else {
                                            if (segmentCount % 2 == 1) {
                                                pt = Math.floor((pt + 1) / 4);
                                                var ptMid = mdiag.Utils.getBezierPt(this.points, pt, 0.5);
                                                x = ptMid.x;
                                                y = ptMid.y
                                            } else {
                                                pt = Math.floor((pt + 1) / 4);
                                                var ptMid = this.points[(pt + 1) * 3];
                                                x = ptMid.x;
                                                y = ptMid.y
                                            }
                                        }
                                        if (this.shape != mdiag.LinkShape.Bezier) {
                                            var pt1 = this.points[pt];
                                            var pt2 = this.points[pt + 1];
                                            var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                                            a = ar.a;
                                            r = ar.r
                                        } else {
                                            if (segmentCount % 2 == 1) {
                                                var pt1 = mdiag.Utils.getBezierPt(this.points, pt, 0.45);
                                                var pt2 = mdiag.Utils.getBezierPt(this.points, pt, 0.55);
                                                var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                                                a = ar.a;
                                                r = ar.r
                                            } else {
                                                var pt1 = mdiag.Utils.getBezierPt(this.points, pt, 0.95);
                                                var pt2 = mdiag.Utils.getBezierPt(this.points, pt + 1, 0.05);
                                                var ar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                                                a = ar.a;
                                                r = ar.r
                                            }
                                        }
                                        a = 180 - a;
                                        if (a > 90 && a < 270) {
                                            a -= 180
                                        }
                                        this.textRenderer.strings.push(this.text);
                                        this.textRenderer.angles.push(a);
                                        this.textRenderer.rectangles.push(new Rect(x, y, this.textSize.width, this.textSize.height))
                                    }
                                }
                            }
                        }
                    }
                }
            },
            intersects: function(rect) {
                var arrowRect = this.getBounds();
                if (!arrowRect.intersectsWith(rect)) {
                    return false
                }
                if (rect.contains(arrowRect)) {
                    return true
                }
                for (var i = 0, l = this.points.length; i < l; i++) {
                    if (rect.containsPoint(this.points[i])) {
                        return true
                    }
                }
                var rectPoints = [];
                rectPoints.push(new Point(rect.x, rect.y));
                rectPoints.push(new Point(rect.right(), rect.y));
                rectPoints.push(new Point(rect.right(), rect.bottom()));
                rectPoints.push(new Point(rect.x, rect.bottom()));
                for (var i = 0, n = this.points.length - 1; i < n; ++i) {
                    for (var j = 0; j < 4; ++j) {
                        var a1 = this.points[i];
                        var a2 = this.points[i + 1];
                        var r1 = rectPoints[j];
                        var r2 = rectPoints[(j + 1) % 4];
                        if (mdiag.Utils.intersect(a1, a2, r1, r2)) {
                            return true
                        }
                    }
                }
                return false
            },
            getRotatedBounds: function() {
                return this.getBounds()
            },
            onShapeLoaded: function() {
                this.graphicsContainer.invalidParent = this
            },
            updateCanvasElements: function() {
                var content = this.graphicsContainer.content = [];
                if (this.baseShape && this.baseShape.isDummy() && !mdiag.Shape.loadFromLibPending) {
                    this.baseShape = mdiag.Shape.fromId(this.baseShape.id);
                    if (this.baseShapeRenderer) {
                        this.baseShapeRenderer.setShape(this.baseShape)
                    }
                }
                if (this.headShape && this.headShape.isDummy() && !mdiag.Shape.loadFromLibPending) {
                    this.headShape = mdiag.Shape.fromId(this.headShape.id);
                    if (this.headShapeRenderer) {
                        this.headShapeRenderer.setShape(this.headShape)
                    }
                }
                var thickness = this.getEffectiveStrokeThickness();
                var dashStyle = this.getEffectiveStrokeDashStyle();
                var stroke = this.getEffectiveStroke();
                this.shapeImpl().createElements(this, content);
                if (this.baseShape) {
                    if (!this.baseShapeRenderer) {
                        this.baseShapeRenderer = new mdiag.ShapeRenderer(this.baseShape)
                    }
                    this.baseShapeRenderer.updateArrowHeadData(this.baseShapeBounds, this.points[0].clone(), this.nextToFirstDifferent(this.points));
                    this.baseShapeRenderer.strokeThickness = this.getEffectiveHeadStrokeThickness();
                    this.baseShapeRenderer.outlineBrush = this.getEffectiveHeadBrush();
                    this.baseShapeRenderer.outlinePen = this.getEffectiveHeadStroke();
                    this.baseShapeRenderer.decorationPen = this.getEffectiveHeadStroke();
                    this.baseShapeRenderer.strokeDashStyle = this.getEffectiveHeadStrokeDashStyle();
                    content.push(this.baseShapeRenderer)
                }
                if (this.headShape) {
                    if (!this.headShapeRenderer) {
                        this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                    }
                    this.headShapeRenderer.updateArrowHeadData(this.headShapeBounds, this.points[this.points.length - 1].clone(), this.nextToLastDifferent(this.points));
                    this.headShapeRenderer.strokeThickness = this.getEffectiveHeadStrokeThickness();
                    this.headShapeRenderer.outlineBrush = this.getEffectiveHeadBrush();
                    this.headShapeRenderer.outlinePen = this.getEffectiveHeadStroke();
                    this.headShapeRenderer.decorationPen = this.getEffectiveHeadStroke();
                    this.headShapeRenderer.strokeDashStyle = this.getEffectiveHeadStrokeDashStyle();
                    content.push(this.headShapeRenderer)
                }
                this.textRenderer.font = this.getEffectiveFont();
                this.textRenderer.pen = this.getEffectiveTextColor();
                this.textRenderer.stroke = this.getEffectiveTextStroke();
                this.textRenderer.strokeThickness = this.getEffectiveStrokeThickness();
                this.updateText();
                content.push(this.textRenderer);
                if (this.labels) {
                    for (var i = 0, l = this.labels.length; i < l; i++) {
                        var label = this.labels[i];
                        label.text.font = label.font != undefined ? label.font : this.getEffectiveFont();
                        label.text.pen = label.textColor != undefined ? label.textColor : this.getEffectiveTextColor();
                        label.text.stroke = label.textColor != undefined ? label.textColor : this.getEffectiveTextStroke();
                        label.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                        label.getLayoutRect()
                    }
                    this.parent.updateLabelLayout();
                    var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                    for (var i = 0, l = this.labels.length; i < l; i++) {
                        var label = this.labels[i];
                        if (label.brush) {
                            var rect = label.cachedLayoutRect.inflate(mm);
                            rect.brush = rect.pen = label.brush;
                            content.push(rect)
                        }
                        content.push(label.text)
                    }
                }
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            drawHandles: function(context) {
                var diagram = this.parent;
                context.fillStyle = mdiag.Utils.getBrush(context, diagram.handleBrush, diagram.getBounds());
                context.strokeStyle = "black";
                if (context.setLineDash) {
                    context.setLineDash([])
                }
                context.lineWidth = 1 / context._mf_scale;
                var size = this.getEffectiveHandlesSize();
                var hsize = size / 2;
                for (var i = 0; i < this.points.length; i++) {
                    var point = this.points[i];
                    if (i % 3 > 0 || this.shape != mdiag.LinkShape.Bezier) {
                        context.fillRect(point.x - hsize, point.y - hsize, size, size);
                        context.strokeRect(point.x - hsize, point.y - hsize, size, size)
                    } else {
                        mdiag.HandleUtils.drawCircle(context, point, hsize)
                    }
                }
            },
            setBaseShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.baseShape != value) {
                    this.baseShape = value;
                    if (this.baseShapeRenderer) {
                        if (this.baseShape) {
                            this.baseShapeRenderer.setShape(this.baseShape);
                            this.baseShapeRenderer.outlineBrush = this.getEffectiveBaseBrush();
                            this.baseShapeRenderer.outlinePen = this.getEffectiveHeadStroke()
                        } else {
                            this.baseShapeRenderer = null;
                            delete this.baseShapeRenderer
                        }
                    }
                    this.invalidate()
                }
            },
            getBaseShape: function() {
                return this.baseShape
            },
            setBaseShapeSize: function(value) {
                if (value != this.baseShapeSize) {
                    this.baseShapeSize = value;
                    var p = this.points[0];
                    this.baseShapeBounds = new MindFusion.Drawing.Rect(p.x - this.baseShapeSize / 2, p.y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize);
                    this.invalidate()
                }
            },
            getBaseShapeSize: function() {
                return this.baseShapeSize
            },
            setHeadShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.headShape != value) {
                    this.headShape = value;
                    if (this.headShapeRenderer) {
                        if (this.headShape) {
                            this.headShapeRenderer.setShape(this.headShape);
                            this.headShapeRenderer.outlineBrush = this.getEffectiveHeadBrush();
                            this.headShapeRenderer.outlinePen = this.getEffectiveHeadStroke()
                        } else {
                            this.headShapeRenderer = null;
                            delete this.headShapeRenderer
                        }
                    }
                    this.invalidate()
                }
            },
            getHeadShape: function() {
                return this.headShape
            },
            setHeadShapeSize: function(value) {
                if (value != this.headShapeSize) {
                    this.headShapeSize = value;
                    var p = this.points[this.points.length - 1];
                    this.headShapeBounds = new MindFusion.Drawing.Rect(p.x - this.headShapeSize / 2, p.y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize);
                    this.invalidate()
                }
            },
            getHeadShapeSize: function() {
                return this.headShapeSize
            },
            setBaseBrush: function(value) {
                if (this.baseBrush != value) {
                    this.baseBrush = value;
                    if (this.baseShape) {
                        if (!this.baseShapeRenderer) {
                            this.baseShapeRenderer = new mdiag.ShapeRenderer(this.baseShape)
                        }
                        this.baseShapeRenderer.outlineBrush = value;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getBaseBrush: function() {
                return this.baseBrush
            },
            getEffectiveBaseBrush: function() {
                if (this.baseBrush) {
                    return this.baseBrush
                }
                return this.getEffectiveBrush()
            },
            setHeadBrush: function(value) {
                if (this.headBrush != value) {
                    this.headBrush = value;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.outlineBrush = value;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadBrush: function() {
                return this.headBrush
            },
            getEffectiveHeadBrush: function() {
                if (this.headBrush) {
                    return this.headBrush
                }
                return this.getEffectiveBrush()
            },
            setHeadStroke: function(value) {
                if (this.headStroke != value) {
                    this.headStroke = value;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.outlinePen = value;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStroke: function() {
                return this.headStroke
            },
            getEffectiveHeadStroke: function() {
                if (this.headStroke) {
                    return this.headStroke
                }
                return this.getEffectiveStroke()
            },
            setHeadStrokeThickness: function(value) {
                if (this.headStrokeThickness != value) {
                    this.headStrokeThickness = value;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.strokeThickness = value;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStrokeThickness: function() {
                return this.headStrokeThickness
            },
            getEffectiveHeadStrokeThickness: function() {
                if (this.headStrokeThickness) {
                    return this.headStrokeThickness
                }
                return this.getEffectiveStrokeThickness()
            },
            setHeadStrokeDashStyle: function(value) {
                if (this.headStrokeDashStyle != value) {
                    this.headStrokeDashStyle = value;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new mdiag.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.strokeDashStyle = value;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStrokeDashStyle: function() {
                return this.headStrokeDashStyle
            },
            getEffectiveHeadStrokeDashStyle: function() {
                if (this.headStrokeDashStyle) {
                    return this.headStrokeDashStyle
                }
                return this.getEffectiveStrokeDashStyle()
            },
            setPoints: function(value, skipRoute) {
                this.copyPoints(value, 0, 0, false, skipRoute);
                this.updateFromPoints(false)
            },
            setLoopShape: function() {
                var topCenter = this.origin.bounds.topMiddle();
                var r = GraphicsUnit.getMillimeter(this.parent.measureUnit) * 8;
                this.shape = mdiag.LinkShape.Bezier;
                this.points = [topCenter, topCenter.newWithOffset(-r, -1.5 * r), topCenter.newWithOffset(+r, -1.5 * r), topCenter.clone()];
                this.updateFromPoints()
            },
            route: function(args) {
                if (this.parent.linkRouter) {
                    this.parent.linkRouter.route(this);
                    this.finalizeRoute(args)
                }
            },
            finalizeRoute: function(args) {
                if (!(args && args.updateFromPoints === false)) {
                    this.updateFromPoints()
                }
            },
            getAutoRoute: function() {
                return this.autoRoute
            },
            setAutoRoute: function(value) {
                this.autoRoute = value;
                if (value) {
                    this.route()
                }
            },
            getDynamic: function() {
                return this.dynamic
            },
            setDynamic: function(value) {
                if (this.dynamic !== value) {
                    this.dynamic = value;
                    this.setDiagramDirty()
                }
            },
            putEndPointsAtNodeBorders: function(action, routing) {
                var start = this.originConnection.getInitialPoint();
                var end = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    start = this.originConnection.getIntersection(start, action == mdiag.Action.Create || routing ? end : this.points[1]);
                    end = this.destinationConnection.getIntersection(end, action == mdiag.Action.Create || routing ? start : this.points[this.points.length - 2])
                }
                this.originConnection.alignEndPointToBorder(start);
                this.destinationConnection.alignEndPointToBorder(end);
                this.points[0] = this.originConnection.anchorPointDetails.point;
                this.points[this.points.length - 1] = this.destinationConnection.anchorPointDetails.point;
                this.originConnection.saveEndRelative(false);
                this.destinationConnection.saveEndRelative(false)
            },
            nextToLastDifferent: function(pts) {
                var last = pts[pts.length - 1];
                for (var i = pts.length - 2; i >= 0; --i) {
                    if (!mdiag.Utils.pointEqualEpsilon(pts[i], last)) {
                        return pts[i].clone()
                    }
                }
                return last.clone()
            },
            nextToFirstDifferent: function(pts) {
                var first = pts[0];
                for (var i = 1, n = pts.length; i < n; ++i) {
                    if (!mdiag.Utils.pointEqualEpsilon(pts[i], first)) {
                        return pts[i].clone()
                    }
                }
                return first.clone()
            },
            collapse: function(collapsedSet) {
                if (this.parent.expandOnIncoming) {
                    if (this.origin) {
                        this.origin.collapse(collapsedSet)
                    }
                } else {
                    if (this.destination) {
                        this.destination.collapse(collapsedSet)
                    }
                }
                collapsedSet.add(this);
                this.setVisible(false);
                if (this.selected && this.parent) {
                    this.parent.selection.removeItem(this)
                }
            },
            setOriginIndex: function(value) {
                this.originConnection.setRow(value, true)
            },
            getOriginIndex: function() {
                return this.originConnection.row
            },
            setDestinationIndex: function(value) {
                this.destinationConnection.setRow(value, true)
            },
            getDestinationIndex: function() {
                return this.destinationConnection.row
            },
            fixRowConnections: function() {
                var oi = this.getOriginIndex();
                var di = this.getDestinationIndex();
                if (oi !== undefined && oi > -1) {
                    this.updateOriginIntersection();
                    if (this.points.length > 2) {
                        this.cascadeStartHorizontal = true;
                        CascadingShape.alignFirstCascadingSegment(this)
                    }
                }
                if (di !== undefined && di > -1) {
                    this.updateDestinationIntersection();
                    if (this.points.length > 2) {
                        CascadingShape.alignLastCascadingSegment(this)
                    }
                }
            },
            resolveInheritedStyle: function(check, theme) {
                var linkStyle = theme.styles["std:DiagramLink"];
                if (linkStyle) {
                    if (check.apply(linkStyle)) {
                        return linkStyle
                    }
                }
                return mflayer.callBaseMethod(DiagramLink, this, "resolveInheritedStyle", [check, theme])
            },
            getSegmentCount: function() {
                if (this.shape == mdiag.LinkShape.Bezier) {
                    return (this.points.length - 1) / 3
                } else {
                    return this.points.length - 1
                }
            },
            setSegmentCount: function(value) {
                var start = this.getStartPoint();
                var end = this.getEndPoint();
                if (this.shape == mdiag.LinkShape.Bezier) {
                    this.points.length = value * 3 + 1
                } else {
                    this.points.length = value + 1
                }
                this.points[0] = start;
                this.points[this.points.length - 1] = end;
                this.arrangePoints()
            },
            arrangePoints: function() {
                var start = this.getStartPoint();
                var end = this.getEndPoint();
                var dx = (end.x - start.x) / (this.points.length - 1);
                var dy = (end.y - start.y) / (this.points.length - 1);
                for (var i = 0; i < this.points.length; i++) {
                    this.points[i] = new Point(start.x + dx * i, start.y + dy * i)
                }
                if (this.shape == mdiag.LinkShape.Cascading) {
                    var value = this.getSegmentCount();
                    var hdiv = Math.floor(value / 2);
                    var vdiv = Math.floor(value / 2);
                    this.cascadeStartHorizontal = Math.abs(dx) > Math.abs(dy);
                    if (this.cascadeStartHorizontal && value % 2 != 0) {
                        hdiv++
                    }
                    if (!this.cascadeStartHorizontal && value % 2 != 0) {
                        vdiv++
                    }
                    var hlen = (end.x - start.x) / hdiv;
                    var vlen = (end.y - start.y) / vdiv;
                    var horzSegment = this.cascadeStartHorizontal;
                    for (var i = 1; i < this.points.length; i++) {
                        if (horzSegment) {
                            this.points[i].x = this.points[i - 1].x + hlen;
                            this.points[i].y = this.points[i - 1].y
                        } else {
                            this.points[i].x = this.points[i - 1].x;
                            this.points[i].y = this.points[i - 1].y + vlen
                        }
                        horzSegment = !horzSegment
                    }
                }
                this.updateFromPoints()
            },
            getPolyLine: function(quality) {
                if (this.shape == mdiag.LinkShape.Bezier) {
                    var approximation = [];
                    for (var i = 0; i < this.getSegmentCount(); ++i) {
                        var p = mdiag.Utils.approximateBezier(this.points, quality, i * 3);
                        approximation = approximation.concat(p)
                    }
                    return approximation
                }
                return this.points
            },
            segmentToPolyline: function(segmNum) {
                var polyline = [];
                if (this.shape != mdiag.LinkShape.Bezier) {
                    polyline.push(this.points[segmNum]);
                    polyline.push(this.points[segmNum + 1])
                } else {
                    polyline = mdiag.Utils.approximateBezier(this.points.slice(0), 30, segmNum * 3)
                }
                return polyline
            },
            getTopLevel: function() {
                if (!mdiag.ContainerNode.usingContainerNodes) {
                    return true
                }
                if (this.origin != null && this.origin.getTopLevel()) {
                    return true
                }
                if (this.destination != null && this.destination.getTopLevel()) {
                    return true
                }
                return mflayer.callBaseMethod(DiagramLink, this, "getTopLevel", [])
            },
            addLabel: function(text) {
                var label = new mdiag.LinkLabel(this, text);
                if (this.labels == undefined) {
                    this.labels = []
                }
                this.labels.push(label);
                this.invalidate();
                return label
            },
            removeLabel: function(label) {
                if (label != undefined && this.labels != undefined) {
                    ArrayList.remove(this.labels, label)
                }
                this.invalidate()
            },
            labelFromPoint: function(point) {
                if (this.labels == undefined) {
                    return null
                }
                for (var i = 0, l = this.labels.length; i < l; i++) {
                    if (this.labels[i].getLayoutRect().containsPoint(point)) {
                        return this.labels[i]
                    }
                }
                return null
            },
            getObjectToEdit: function(point) {
                var label = this.labelFromPoint(point);
                if (label != null) {
                    return label
                }
                return this
            },
            createEditArgs: function(oldText, newText) {
                return new mdiag.LinkEventArgs({
                    link: this,
                    oldText: oldText,
                    newText: newText
                })
            },
            crossedLinksToInvalidate: function(down) {
                var parent = this.getParent();
                var zOrder = parent.getZOrder();
                var z = undefined;
                for (var i = 0; i < zOrder.length; i++) {
                    var item = zOrder[i].item;
                    if (item == this) {
                        z = i;
                        break
                    }
                }
                if (z === undefined) {
                    z = zOrder.length
                }
                return parent.getLinkCrossings() == mdiag.LinkCrossings.Arcs ? parent.getLinksFromZ(down, z) : parent.getLinksFromZ(!down, z)
            },
            resetCrossings: function(invalidRect) {
                var parent = this.getParent();
                if (parent == null || parent.getLinkCrossings() == mdiag.LinkCrossings.Straight) {
                    return
                }
                if (!invalidRect) {
                    invalidRect = this.getBounds()
                }
                this._mf_linkCrossings = undefined;
                var links;
                if (parent.cachedZOrder == null) {
                    links = parent.links
                } else {
                    links = this.crossedLinksToInvalidate(false)
                }
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    var rcTest = link.getBounds();
                    if (rcTest.intersectsWith(invalidRect)) {
                        link._mf_linkCrossings = undefined
                    }
                }
            },
            getCrossings: function() {
                var getEllipseIntr = MindFusion.Geometry.getEllipseIntr;
                var parent = this.getParent();
                var mm = GraphicsUnit.getMillimeter(parent.measureUnit);
                var crad = parent.getCrossingRadius();
                var rcLink = this.getBounds();
                var intersections = [];
                var ac = this._mf_linkCrossings;
                if (ac == null) {
                    this._mf_linkCrossings = ac = [];
                    var links = this.crossedLinksToInvalidate(true);
                    var segmentCount = this.getSegmentCount();
                    for (var sgt = 0; sgt < segmentCount; ++sgt) {
                        var pt1 = this.points[sgt];
                        var pt2 = this.points[sgt + 1];
                        if (!pt1.equals(pt2)) {
                            for (var i = 0; i < links.length; ++i) {
                                var link = links[i];
                                if (!link.getVisible() || link.getShape() == mdiag.LinkShape.Bezier) {
                                    continue
                                }
                                var rcTest = link.getBounds();
                                if (!rcTest.intersectsWith(rcLink)) {
                                    continue
                                }
                                var lsc = link.getSegmentCount();
                                for (var test = 0; test < lsc; ++test) {
                                    var testPt1 = link.points[test];
                                    var testPt2 = link.points[test + 1];
                                    if (testPt1.equals(testPt2)) {
                                        continue
                                    }
                                    var intersection = mdiag.Utils.getSegmentIntersection(pt1, pt2, testPt1, testPt2);
                                    if (intersection && pt1.distance(intersection) > crad && pt2.distance(intersection) > crad && testPt1.distance(intersection) > crad && testPt2.distance(intersection) > crad) {
                                        var crossing = {
                                            location: intersection,
                                            radius: crad
                                        };
                                        intersections.push(crossing)
                                    }
                                }
                            }
                            intersections.sort(closerDistance(pt1))
                        }
                        var closer = closerDistance(pt1);
                        var rintr = ac[sgt];
                        if (!rintr) {
                            rintr = ac[sgt] = []
                        }
                        rintr.push({
                            location: pt1,
                            radius: 0
                        });
                        for (var ptc = 0; ptc < intersections.length; ++ptc) {
                            var cp = intersections[ptc];
                            var pt = cp.location;
                            crad = cp.radius;
                            var rc = Rect.fromLTRB(pt.x - crad, pt.y - crad, pt.x + crad, pt.y + crad);
                            var ptRes1 = getEllipseIntr(rc, pt1, pt);
                            var ptRes2 = getEllipseIntr(rc, pt2, pt);
                            var cp1 = {
                                location: ptRes1,
                                radius: crad
                            };
                            var cp2 = {
                                location: ptRes2,
                                radius: crad
                            };
                            if (closer(cp1, cp2) < 0) {
                                rintr.push(cp1);
                                rintr.push(cp2)
                            } else {
                                rintr.push(cp2);
                                rintr.push(cp1)
                            }
                        }
                        rintr.push({
                            location: pt2,
                            radius: 0
                        });
                        for (var i = 1; i < rintr.length - 2;) {
                            var c1 = rintr[i];
                            var c2 = rintr[i + 1];
                            if (closer(c1, c2) > 0 || c1.location.distance(c2.location) < mm / 2) {
                                ArrayList.removeAt(rintr, i);
                                ArrayList.removeAt(rintr, i)
                            } else {
                                i++
                            }
                        }
                        intersections.length = 0
                    }
                }
                return ac
            },
            getLongestSegment: function() {
                var longest = 0;
                var maxLength = 0;
                var segmentCount = this.getSegmentCount();
                for (var i = 0; i < segmentCount; ++i) {
                    var length = this.getSegmentLength(i);
                    if (length > maxLength) {
                        maxLength = length;
                        longest = i
                    }
                }
                return longest
            },
            getSegmentLength: function(index) {
                var mgeo = MindFusion.Geometry;
                switch (this.shape) {
                    case mdiag.LinkShape.Polyline:
                    case mdiag.LinkShape.Cascading:
                        return mgeo.distance(this.points[index], this.points[index + 1]);
                    case mdiag.LinkShape.Bezier:
                        var counter = index * 3;
                        var segmentPoints = [];
                        segmentPoints.push(this.points[counter++]);
                        segmentPoints.push(this.points[counter++]);
                        segmentPoints.push(this.points[counter++]);
                        segmentPoints.push(this.points[counter]);
                        var bezierApprox = mdiag.Utils.approximateBezier(segmentPoints, 0, 30);
                        var total = 0;
                        for (var s = 0; s < bezierApprox.Count - 1; ++s) {
                            var pt1 = bezierApprox[s];
                            var pt2 = bezierApprox[s + 1];
                            var dx = pt1.x - pt2.x;
                            var dy = pt1.y - pt2.y;
                            total += Math.sqrt(dx * dx + dy * dy)
                        }
                        return total
                }
                return 0
            },
            getSegmentCenter: function(index) {
                switch (this.shape) {
                    case mdiag.LinkShape.Bezier:
                        var startIdx = index * 3;
                        var x0 = this.points[0 + startIdx].x;
                        var y0 = this.points[0 + startIdx].y;
                        var x1 = this.points[1 + startIdx].x;
                        var y1 = this.points[1 + startIdx].y;
                        var x2 = this.points[2 + startIdx].x;
                        var y2 = this.points[2 + startIdx].y;
                        var x3 = this.points[3 + startIdx].x;
                        var y3 = this.points[3 + startIdx].y;
                        var t = 0.5;
                        var q0 = (1 - t) * (1 - t) * (1 - t);
                        var q1 = 3 * t * (1 - t) * (1 - t);
                        var q2 = 3 * t * t * (1 - t);
                        var q3 = t * t * t;
                        var xt = q0 * x0 + q1 * x1 + q2 * x2 + q3 * x3;
                        var yt = q0 * y0 + q1 * y1 + q2 * y2 + q3 * y3;
                        return new Point(xt, yt);
                    default:
                        var pt1 = this.points[index];
                        var pt2 = this.points[index + 1];
                        return new Point((pt1.x + pt2.x) / 2, (pt1.y + pt2.y) / 2)
                }
            },
            getNearPoint: function(index) {
                if (this.shape == mdiag.LinkShape.Bezier) {
                    return this.points[index * 3]
                }
                return this.points[index]
            },
            getFarPoint: function(index) {
                if (this.shape == mdiag.LinkShape.Bezier) {
                    return this.points[index * 3 + 3]
                }
                return this.points[index + 1]
            },
            fit: function(text, width, font) {
                if (text.length == 0) {
                    return 0
                }
                var chars = 0;
                var ctext = text[chars];
                var rect = new Rect(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
                var totalWidth = 0;
                while (true) {
                    totalWidth += this.parent.measureString(ctext, font, rect).width;
                    if (totalWidth > width) {
                        return Math.max(0, chars)
                    }
                    chars++;
                    if (chars < text.length) {
                        ctext = text[chars]
                    } else {
                        return chars
                    }
                }
            },
            updateAnimation: function(animation, animationDelta) {
                this.setHeadShapeSize(animation.getFromValue() + (animation.getToValue() - animation.getFromValue()) * animationDelta)
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(DiagramLink, this, "saveState", []);
                state.originConnection = this.originConnection.clone(this, this.origin);
                state.destinationConnection = this.destinationConnection.clone(this, this.destination);
                state.points = ArrayList.clone(this.points);
                state.shape = this.shape;
                state.baseShapeSize = this.baseShapeSize;
                state.headShapeSize = this.headShapeSize;
                state.baseShape = this.baseShape;
                state.headShape = this.headShape;
                state.baseBrush = this.baseBrush;
                state.headBrush = this.headBrush;
                state.dynamic = this.dynamic;
                state.autoRoute = this.autoRoute;
                state.labels = this.labels;
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(DiagramLink, this, "restoreState", [state]);
                this.originConnection.removeLinkFromNode();
                this.originConnection = state.originConnection.clone(this, this.origin);
                this.originConnection.addLinkToNode();
                this.destinationConnection.removeLinkFromNode();
                this.destinationConnection = state.destinationConnection.clone(this, this.destination);
                this.destinationConnection.addLinkToNode();
                this.setPoints(state.points, true);
                this.updateFromPoints();
                this.setShape(state.shape);
                this.baseShapeSize = state.baseShapeSize;
                this.headShapeSize = state.headShapeSize;
                this.setBaseShape(state.baseShape);
                this.setBaseBrush(state.baseBrush);
                this.setHeadShape(state.headShape);
                this.setHeadBrush(state.headBrush);
                this.dynamic = state.dynamic;
                this.autoRoute = state.autoRoute;
                this.labels = state.labels
            },
            init: function() {
                if (!mdiag.DiagramLinkBuilder) {
                    mdiag.DiagramLinkBuilder = new MindFusion.Builder(DiagramLink.prototype, null, this)
                } else {
                    mdiag.DiagramLinkBuilder.setInstance(this)
                }
                return mdiag.DiagramLinkBuilder
            },
            defaultPoint: new Point(0, 0)
        };
        var BezierShape = {
            initialize: function(link, start, end) {
                var points = link.points = [start];
                var denom = 3;
                for (var i = 1; i < 3; ++i) {
                    points[i] = new Point(start.x + i * (end.x - start.x) / denom, start.y + i * (end.y - start.y) / denom)
                }
                link.points.push(end)
            },
            createElements: function(link, contentArray) {
                var points = link.points;
                if (points.length < 4) {
                    return PolylineShape.createElements(link, contentArray)
                }
                var stroke = link.getEffectiveStroke();
                var thickness = link.getEffectiveStrokeThickness();
                var dashStyle = link.getEffectiveStrokeDashStyle();
                for (var i = 1, n = points.length; i < n; i += 3) {
                    var bezier = MindFusion.Drawing.Bezier.fromPoints(points, i - 1);
                    bezier.pen = stroke;
                    bezier.strokeThickness = thickness;
                    bezier.strokeDashStyle = dashStyle;
                    bezier.shadow = link.createShadow();
                    contentArray.push(bezier)
                }
            },
            containsPoint: function(link, point, maxDist) {
                var approx = mdiag.Utils.approximateBezier(link.points, 16);
                return mdiag.Utils.distToPolyline(point, approx, approx.length) < maxDist
            },
            updateRelatedPoints: function(link, point, interactionState) {
                var points = link.points;
                if (points.length < 4) {
                    return
                }
                var originalPoints = interactionState.originalStates.get(link).controlPoints;
                var modifyHandle = interactionState.adjustmentHandle.index;
                if (points.length == originalPoints.length) {
                    if ((modifyHandle + 1) % 3 == 0 && modifyHandle < points.length - 3) {
                        points[modifyHandle + 2] = mdiag.Utils.symmetricPoint(points[modifyHandle], points[modifyHandle + 1])
                    }
                    if ((modifyHandle - 1) % 3 == 0 && modifyHandle > 3) {
                        points[modifyHandle - 2] = mdiag.Utils.symmetricPoint(points[modifyHandle], points[modifyHandle - 1])
                    }
                    if ((modifyHandle % 3 == 0) && modifyHandle > 0 && modifyHandle < points.length - 1) {
                        var delta = interactionState.delta();
                        points[modifyHandle - 1] = Point.addVector(originalPoints[modifyHandle - 1], delta);
                        points[modifyHandle + 1] = Point.addVector(originalPoints[modifyHandle + 1], delta)
                    }
                }
            },
            updateFromEndPoints: function(link, updateConnections) {
                link.updateFromPoints(updateConnections)
            },
            updateFromRoute: function(link) {
                var points = link.points;
                var newPoints = [];
                var ptf, ptf1, ptf2, ptf3;
                newPoints.push(points[0]);
                var i = 0;
                while (i < points.length - 2) {
                    ptf2 = points[i + 1];
                    newPoints.push(ptf2);
                    newPoints.push(ptf2);
                    if (i != points.length - 3) {
                        ptf3 = points[i + 2];
                        ptf = new Point((ptf2.x + ptf3.x) / 2, (ptf2.y + ptf3.y) / 2);
                        newPoints.push(ptf)
                    } else {
                        newPoints.push(points[i + 2])
                    }
                    i += 1
                }
                if (newPoints.length == 1) {
                    newPoints = [];
                    ptf1 = points[0];
                    ptf2 = points[points.length - 1];
                    ptf = new Point((ptf1.x + ptf2.x) / 2, (ptf1.y + ptf2.y) / 2);
                    newPoints[0] = ptf1;
                    newPoints[1] = ptf;
                    newPoints[2] = ptf.clone();
                    newPoints[3] = ptf2
                }
                link.points = newPoints
            },
            pointsValid: function(link) {
                return (link.points.length - 1) % 3 == 0
            },
            resetSelfLoopPoints: function(link, allowChangeSegments) {
                var topCenter = link.origin.bounds.topMiddle();
                var r = GraphicsUnit.getMillimeter(link.parent.measureUnit) * 8;
                if (allowChangeSegments) {
                    link.points = [topCenter, topCenter.newWithOffset(-r, -1.5 * r), topCenter.newWithOffset(+r, -1.5 * r), topCenter.clone()]
                } else {
                    var points = link.points;
                    points[0] = topCenter;
                    points[points.length - 1] = topCenter.clone();
                    for (var i = 0; i < points.length / 2 - 1; ++i) {
                        points[1 + i] = topCenter.newWithOffset(-r, -1.5 * r);
                        points[points.length - 2 - i] = topCenter.newWithOffset(+r, -1.5 * r)
                    }
                    if (points.length % 2 == 1) {
                        points[points.length / 2] = topCenter.newWithOffset(0, -1.8 * r)
                    }
                }
                link.updateFromPoints()
            }
        };
        var PolylineShape = {
            initialize: function(link, start, end) {
                link.points = [start, end]
            },
            createElements: function(link, contentArray) {
                var linkParent = link.getParent();
                if (linkParent && (linkParent.getRoundedLinks() || linkParent.getLinkCrossings() != mdiag.LinkCrossings.Straight)) {
                    var renderer = new PolylineRenderer(link);
                    contentArray.push(renderer);
                    return
                }
                var stroke = link.getEffectiveStroke();
                var thickness = link.getEffectiveStrokeThickness();
                var dashStyle = link.getEffectiveStrokeDashStyle();
                var points = link.points;
                for (var i = 0, l = points.length - 1; i < l; i++) {
                    var p1 = points[i];
                    var p2 = points[i + 1];
                    var line = new MindFusion.Drawing.Line(p1.x, p1.y, p2.x, p2.y);
                    line.setPen(stroke);
                    line.strokeThickness = thickness;
                    line.strokeDashStyle = dashStyle;
                    line.shadow = link.createShadow();
                    contentArray.push(line)
                }
            },
            containsPoint: function(link, point, maxDist) {
                return mdiag.Utils.distToPolyline(point, link.points, link.points.length) < maxDist
            },
            updateRelatedPoints: function(link, point, interactionState) {},
            updateFromEndPoints: function(link, updateConnections) {
                link.updateFromPoints(updateConnections)
            },
            updateFromRoute: function(link) {},
            pointsValid: function(link) {
                return true
            },
            resetSelfLoopPoints: function(link, allowChangeSegments) {
                BezierShape.resetSelfLoopPoints(link, allowChangeSegments)
            }
        };
        var CascadingShape = {
            initialize: function(link, start, end) {
                if (link.points.length < 3) {
                    ArrayList.insert(link.points, 1, new MindFusion.Drawing.Point(0, 0))
                }
                this.arrangeCascadingSegments(link, start, end)
            },
            createElements: function(link, contentArray) {
                PolylineShape.createElements(link, contentArray)
            },
            containsPoint: function(link, point, maxDist) {
                return PolylineShape.containsPoint(link, point, maxDist)
            },
            updateRelatedPoints: function(link, point, interactionState) {
                var points = link.points;
                if (points.length < 3) {
                    return
                }
                var current = interactionState.currentPoint;
                var modifyHandle = interactionState.adjustmentHandle.index;
                var dX = points[points.length - 1].x - points[0].x;
                var dY = points[points.length - 1].y - points[0].y;
                if (interactionState.action === mdiag.Action.Create && (modifyHandle == 0 || modifyHandle == points.length - 1) && ((link.cascadeStartHorizontal && Math.abs(dX) < Math.abs(dY)) || (!link.cascadeStartHorizontal && Math.abs(dX) > Math.abs(dY)))) {
                    link.cascadeStartHorizontal = Math.abs(dX) > Math.abs(dY);
                    this.arrangeCascadingSegments(link, points[0], points[points.length - 1])
                } else {
                    this.alignCascadingSegments(link, modifyHandle)
                }
            },
            arrangeCascadingSegments: function(link, start, end) {
                link.cascadeStartHorizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);
                var points = link.points = [start, start, end, end];
                var count = points.length;
                var dx = end.x - start.x;
                var dy = end.y - start.y;
                var ax, ay;
                for (var i = 1; i < count - 1; ++i) {
                    if (link.cascadeStartHorizontal) {
                        if (i % 2 != 0) {
                            ax = dx / (count / 2);
                            ay = 0
                        } else {
                            ax = 0;
                            ay = dy / ((count - 1) / 2)
                        }
                    } else {
                        if (i % 2 != 0) {
                            ax = 0;
                            ay = dy / (count / 2)
                        } else {
                            ax = dx / ((count - 1) / 2);
                            ay = 0
                        }
                    }
                    points[i] = new Point(points[i - 1].x + ax, points[i - 1].y + ay)
                }
                i--;
                if ((link.cascadeStartHorizontal && (i % 2 != 0)) || (!link.cascadeStartHorizontal && !(i % 2 != 0))) {
                    points[count - 2] = new Point(points[count - 1].x, points[count - 2].y)
                } else {
                    points[count - 2] = new Point(points[count - 2].x, points[count - 1].y)
                }
            },
            alignCascadingSegments: function(link, h) {
                var points = link.points;
                var ip = h - 1;
                var ix = h + 1;
                if ((link.cascadeStartHorizontal && h % 2 != 0) || (!link.cascadeStartHorizontal && !(h % 2 != 0))) {
                    if (ip == 0) {
                        points[h] = new Point(points[h].x, points[ip].y)
                    }
                    if (ix == points.length - 1) {
                        points[h] = new Point(points[ix].x, points[h].y)
                    }
                    if (ip >= 0 && ip < points.length) {
                        points[ip] = new Point(points[ip].x, points[h].y)
                    }
                    if (ix >= 0 && ix < points.length) {
                        points[ix] = new Point(points[h].x, points[ix].y)
                    }
                } else {
                    if (ip == 0) {
                        points[h] = new Point(points[ip].x, points[h].y)
                    }
                    if (ix == points.length - 1) {
                        points[h] = new Point(points[h].x, points[ix].y)
                    }
                    if (ip >= 0 && ip < points.length) {
                        points[ip] = new Point(points[h].x, points[ip].y)
                    }
                    if (ix >= 0 && ix < points.length) {
                        points[ix] = new Point(points[ix].x, points[h].y)
                    }
                }
            },
            updateFromEndPoints: function(link, updateConnections) {
                this.alignFirstCascadingSegment(link);
                this.alignLastCascadingSegment(link);
                link.updateFromPoints(updateConnections)
            },
            alignFirstCascadingSegment: function(link) {
                var points = link.points;
                var fx = points[1].x;
                var fy = points[1].y;
                if (link.cascadeStartHorizontal) {
                    fy = points[0].y
                } else {
                    fx = points[0].x
                }
                points[1] = new Point(fx, fy)
            },
            alignLastCascadingSegment: function(link) {
                var points = link.points;
                var pts = points.length;
                var lx = points[pts - 2].x;
                var ly = points[pts - 2].y;
                if (pts % 2 != 0) {
                    if (link.cascadeStartHorizontal) {
                        lx = points[pts - 1].x
                    } else {
                        ly = points[pts - 1].y
                    }
                } else {
                    if (link.cascadeStartHorizontal) {
                        ly = points[pts - 1].y
                    } else {
                        lx = points[pts - 1].x
                    }
                }
                points[pts - 2] = new Point(lx, ly)
            },
            updateFromRoute: function(link) {
                var points = link.points;
                link.cascadeStartHorizontal = points[0].y == points[1].y
            },
            pointsValid: function(link) {
                if (link.points.length < 3) {
                    return false
                }
                return true
            },
            resetSelfLoopPoints: function(link, allowChangeSegments) {
                var points = link.points;
                if (allowChangeSegments && points.length % 2 == 0) {
                    link.setSegmentCount(3)
                }
                var rc = link.origin.bounds;
                var w = rc.width;
                points[0] = link.origin.getTopIntr(1 / 3);
                points[points.length - 1] = link.origin.getTopIntr(2 / 3);
                for (var i = 0; i < points.length / 2 - 1; ++i) {
                    points[1 + i] = new Point(points[0].x, points[0].y - w / 3);
                    points[points.length - 2 - i] = new Point(points[points.length - 1].x, points[0].y - w / 3)
                }
                if (points.length % 2 == 1) {
                    points[points.length / 2] = new Point(points[points.length - 1].x, points[0].y - w / 3)
                }
                link.cascadeStartHorizontal = false;
                link.updateFromPoints()
            }
        };
        var SplineShape = {
            initialize: function(link, start, end) {
                link.points = [start, end]
            },
            createElements: function(link, contentArray) {
                var stroke = link.getEffectiveStroke();
                var thickness = link.getEffectiveStrokeThickness();
                var dashStyle = link.getEffectiveStrokeDashStyle();
                var spline = new MindFusion.Drawing.CardinalSpline(link.points);
                spline.pen = stroke;
                spline.strokeThickness = thickness;
                spline.strokeDashStyle = dashStyle;
                spline.shadow = link.createShadow();
                contentArray.push(spline)
            },
            getCurvePoints: function(pts) {
                var tension = 0.5;
                var numOfSegments = 16;
                var _pts = [],
                    res = [],
                    x, y, t1x, t2x, t1y, t2y, c1, c2, c3, c4, st, t, i;
                _pts = pts.slice(0);
                _pts.unshift(pts[1]);
                _pts.unshift(pts[0]);
                _pts.push(pts[pts.length - 2]);
                _pts.push(pts[pts.length - 1]);
                for (i = 2; i < (_pts.length - 4); i += 2) {
                    for (t = 0; t <= numOfSegments; t++) {
                        t1x = (_pts[i + 2] - _pts[i - 2]) * tension;
                        t2x = (_pts[i + 4] - _pts[i]) * tension;
                        t1y = (_pts[i + 3] - _pts[i - 1]) * tension;
                        t2y = (_pts[i + 5] - _pts[i + 1]) * tension;
                        st = t / numOfSegments;
                        c1 = 2 * Math.pow(st, 3) - 3 * Math.pow(st, 2) + 1;
                        c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2);
                        c3 = Math.pow(st, 3) - 2 * Math.pow(st, 2) + st;
                        c4 = Math.pow(st, 3) - Math.pow(st, 2);
                        x = c1 * _pts[i] + c2 * _pts[i + 2] + c3 * t1x + c4 * t2x;
                        y = c1 * _pts[i + 1] + c2 * _pts[i + 3] + c3 * t1y + c4 * t2y;
                        res.push(x);
                        res.push(y)
                    }
                }
                return res
            },
            containsPoint: function(link, point, maxDist) {
                return mdiag.Utils.distToPolyline(point, link.points, link.points.length) < maxDist
            },
            updateRelatedPoints: function(link, point, interactionState) {},
            updateFromEndPoints: function(link, updateConnections) {
                link.updateFromPoints(updateConnections)
            },
            updateFromRoute: function(link) {},
            pointsValid: function(link) {
                return true
            },
            resetSelfLoopPoints: function(link, allowChangeSegments) {
                BezierShape.resetSelfLoopPoints(link, allowChangeSegments)
            }
        };
        var PolylineRenderer = function(link) {
            this.link = link
        };
        PolylineRenderer.prototype = {
            draw: function(context, drawShadow) {
                var link = this.link;
                var parent = link.getParent();
                var stroke = link.getEffectiveStroke();
                var thickness = link.getEffectiveStrokeThickness();
                var dashStyle = link.getEffectiveStrokeDashStyle();
                var points = link.points;
                if (points.length < 2) {
                    return
                }
                var shadow = link.createShadow();
                if (shadow && drawShadow != false) {
                    context.save();
                    shadow.apply(context)
                }
                context.strokeStyle = stroke;
                context.lineWidth = (thickness ? thickness : 1) / context._mf_scale;
                DashStyle.apply(context, dashStyle);
                this.drawLink(context);
                if (shadow && drawShadow != false) {
                    context.restore()
                }
            },
            drawShadow: function(context) {
                var link = this.link;
                var thickness = link.getEffectiveStrokeThickness();
                var dashStyle = link.getEffectiveStrokeDashStyle();
                var shadow = link.createShadow();
                if (shadow) {
                    context.save();
                    shadow.apply(context);
                    context.strokeStyle = shadow.color;
                    context.lineWidth = (thickness ? thickness : 1) / context._mf_scale;
                    DashStyle.apply(context, dashStyle);
                    this.drawLink(context);
                    context.restore()
                }
            },
            drawLink: function(context) {
                var link = this.link;
                var parent = link.getParent();
                var points = link.points;
                if (points.length < 2) {
                    return
                }
                var linkCrossings = parent ? parent.getLinkCrossings() : mdiag.LinkCrossings.Straight;
                if (linkCrossings == mdiag.LinkCrossings.Straight) {
                    if (link.parent.getRoundedLinks()) {
                        this.drawRoundedPolyline(context, points, parent.getRoundedLinksRadius(), true)
                    } else {
                        this.drawLines(context, points)
                    }
                } else {
                    this.drawWithCrossings(context, link, points, parent.getRoundedLinksRadius())
                }
            },
            drawLines: function(context, points) {
                context.beginPath();
                context.moveTo(points[0].x, points[0].y);
                for (var i = 1, l = points.length; i < l; i++) {
                    var p = points[i];
                    context.lineTo(p.x, p.y)
                }
                context.stroke()
            },
            drawRoundedPolyline: function(context, points, radius, standalone) {
                var mgeo = MindFusion.Geometry;
                if (radius < 0.00001) {
                    this.drawLines(context, points);
                    return points[points.length - 1]
                }
                if (points.length <= 2) {
                    this.drawLines(context, points);
                    return points[points.length - 1]
                }
                var prev = points[0];
                if (standalone) {
                    context.beginPath();
                    context.moveTo(prev.x, prev.y)
                }
                var c, k1, k2, l2;
                for (var i = 0; i < points.length - 2; i++) {
                    c = points[i + 1];
                    k1 = points[i];
                    k2 = points[i + 1];
                    l2 = points[i + 2];
                    var continueLoop = false;
                    while (Math.abs(k2.x - l2.x) + Math.abs(k2.y - l2.y) < 0.00001) {
                        i++;
                        if (i >= points.length - 2) {
                            continueLoop = true;
                            break
                        }
                        l2 = points[i + 2]
                    }
                    if (continueLoop) {
                        continue
                    }
                    var polar1 = mgeo.cartesianToPolarDegrees(c, k1);
                    var a1 = polar1.a;
                    var r1 = polar1.r;
                    var polar2 = mgeo.cartesianToPolarDegrees(c, l2);
                    var a2 = polar2.a;
                    var r2 = polar2.r;
                    while (a1 < 0) {
                        a1 += 360
                    }
                    while (a2 < 0) {
                        a2 += 360
                    }
                    if (a2 < a1) {
                        a2 += 360
                    }
                    var a = a2 - a1;
                    if (a == 0 || a == 180) {
                        continue
                    }
                    var swap = false;
                    if (a > 180) {
                        var temp = a1;
                        a1 = a2;
                        a2 = temp;
                        temp = r1;
                        r1 = r2;
                        r2 = temp;
                        a = a2 - a1;
                        while (a < 0) {
                            a += 360
                        }
                        swap = true
                    }
                    var rr = radius;
                    var rrSin = Math.sin(mgeo.degreeToRadian(a / 2));
                    var xxSin = Math.sin(mgeo.degreeToRadian(90 - a / 2));
                    var xx = xxSin * rr / rrSin;
                    var len = Math.min(r1, r2);
                    if (xx > Math.min(len / 3, 10)) {
                        xx = Math.min(len / 3, 10);
                        rr = rrSin * xx / xxSin
                    }
                    var iK = mgeo.polarToCartesianDegrees(c, {
                        a: a1,
                        r: xx
                    });
                    var iL = mgeo.polarToCartesianDegrees(c, {
                        a: a2,
                        r: xx
                    });
                    var xc = Math.sqrt(Math.pow(xx, 2) + Math.pow(rr, 2));
                    var center = mgeo.polarToCartesianDegrees(c, {
                        a: a1 + a / 2,
                        r: xc
                    });
                    var ipol1 = mgeo.cartesianToPolarDegrees(center, iK);
                    iKa = ipol1.a;
                    iKr = ipol1.r;
                    var ipol2 = mgeo.cartesianToPolarDegrees(center, iL);
                    iLa = ipol2.a;
                    iLr = ipol2.r;
                    while (Math.abs(iLa - iKa) > 180) {
                        if (iLa < iKa) {
                            iLa += 360
                        } else {
                            iKa += 360
                        }
                    }
                    if (iLa < iKa) {
                        var temp = iLa;
                        iLa = iKa;
                        iKa = temp
                    }
                    if (swap) {
                        var temp = iK;
                        iK = iL;
                        iL = temp
                    }
                    context.lineTo(iK.x, iK.y);
                    if (rr > 0) {
                        var start = 360 - iKa;
                        var sweep = -(iLa - iKa);
                        if (!swap) {
                            start = start + sweep;
                            sweep = -sweep
                        }
                        context.arc(center.x, center.y, rr, mgeo.degreeToRadian(start), mgeo.degreeToRadian(start + sweep), sweep < 0)
                    }
                    prev = iL
                }
                if (standalone) {
                    var last = points[points.length - 1];
                    context.lineTo(last.x, last.y);
                    context.stroke()
                }
                return prev
            },
            drawWithCrossings: function(context, link, points, radius) {
                var crossings = link.getCrossings();
                if (!crossings || crossings.length == 0) {
                    this.drawLines(context, points);
                    return
                }
                var mgeo = MindFusion.Geometry;
                context.beginPath();
                context.moveTo(points[0].x, points[0].y);
                var startPoint = null;
                var segmentCount = link.getSegmentCount();
                var parent = link.getParent();
                var moveTo = false;
                for (var i = 0; i < segmentCount; ++i) {
                    var pc = crossings[i];
                    if (pc.length > 0) {
                        for (var j = 0; j < pc.length - 1; ++j) {
                            var crad = pc[j].radius;
                            var pt1 = pc[j].location;
                            var pt2 = pc[j + 1].location;
                            if (startPoint) {
                                pt1 = startPoint
                            }
                            if (moveTo) {
                                context.moveTo(pt1.x, pt1.y);
                                moveTo = false
                            }
                            startPoint = null;
                            if (j % 2 == 0) {
                                if (parent.getRoundedLinks()) {
                                    if (j == pc.length - 2 && i != segmentCount - 1) {
                                        var ni = i + 2;
                                        var next = points[ni];
                                        while (Math.abs(next.x - pt2.x) + Math.abs(next.y - pt2.y) < 0.00001) {
                                            ni++;
                                            if (ni == points.length) {
                                                break
                                            }
                                            next = points[ni]
                                        }
                                        if (ni == points.length) {
                                            context.lineTo(pt2.x, pt2.y)
                                        } else {
                                            var nextPc = crossings[ni - 1];
                                            if (nextPc.length > 2) {
                                                next = nextPc[1].location
                                            }
                                            var triPoints = [pt1, pt2, next];
                                            startPoint = this.drawRoundedPolyline(context, triPoints, radius, false)
                                        }
                                    } else {
                                        context.lineTo(pt2.x, pt2.y)
                                    }
                                } else {
                                    context.lineTo(pt2.x, pt2.y)
                                }
                            } else {
                                if (parent.getLinkCrossings() == mdiag.LinkCrossings.Arcs) {
                                    var rad = pt1.distance(pt2) / 2;
                                    var polar = mgeo.cartesianToPolarDegrees(pt1, pt2);
                                    var aa = polar.a;
                                    var rr = polar.r;
                                    var centers = [mgeo.polarToCartesianDegrees(pt1, {
                                        a: aa,
                                        r: crad
                                    }), mgeo.polarToCartesianDegrees(pt1, {
                                        a: aa,
                                        r: 2 * rad - crad
                                    })];
                                    var startPts = [pt1, mgeo.polarToCartesianDegrees(pt1, {
                                        a: aa,
                                        r: 2 * rad - 2 * crad
                                    })];
                                    var endPts = [mgeo.polarToCartesianDegrees(pt1, {
                                        a: aa,
                                        r: 2 * crad
                                    }), pt2];
                                    var angle = aa;
                                    if (angle < 90) {
                                        angle += 180
                                    }
                                    var ded = 0 * 90;
                                    if (aa < 90) {
                                        ded = 90 - ded
                                    }
                                    var start = 180 - angle - ded;
                                    var sweep = -90;
                                    if (aa < 90) {
                                        start += sweep;
                                        sweep = -sweep
                                    }
                                    context.arc(centers[0].x, centers[0].y, crad, mgeo.degreeToRadian(start), mgeo.degreeToRadian(start + sweep), sweep < 0);
                                    var p1 = mgeo.polarToCartesianDegrees(centers[0], {
                                        a: angle - 90,
                                        r: crad
                                    });
                                    var p2 = mgeo.polarToCartesianDegrees(centers[1], {
                                        a: angle - 90,
                                        r: crad
                                    });
                                    context.lineTo(p2.x, p2.y);
                                    ded = 1 * 90;
                                    if (aa < 90) {
                                        ded = 90 - ded
                                    }
                                    start = 180 - angle - ded;
                                    sweep = -90;
                                    if (aa < 90) {
                                        start += sweep;
                                        sweep = -sweep
                                    }
                                    context.arc(centers[1].x, centers[1].y, crad, mgeo.degreeToRadian(start), mgeo.degreeToRadian(start + sweep), sweep < 0)
                                } else {
                                    moveTo = true
                                }
                            }
                        }
                    } else {
                        context.lineTo(points[i + 1].x, points[i + 1].y)
                    }
                }
                var last = points[points.length - 1];
                context.lineTo(last.x, last.y);
                context.stroke()
            }
        };
        DiagramLink.With = function(diagram) {
            if (!mdiag.DiagramLinkBuilder) {
                mdiag.DiagramLinkBuilder = new MindFusion.Builder(DiagramLink.prototype, diagram)
            } else {
                mdiag.DiagramLinkBuilder.setInstance(null)
            }
            return mdiag.DiagramLinkBuilder
        };
        mdiag.DiagramLinkBuilder = null;
        var Shapes = [BezierShape, PolylineShape, CascadingShape, SplineShape];
        var closerDistance = function(compareWith) {
            return function(a, b) {
                var left = a.location;
                var right = b.location;
                if (left.equals(right)) {
                    return 0
                }
                var dl = (compareWith.x - left.x) * (compareWith.x - left.x);
                dl += (compareWith.y - left.y) * (compareWith.y - left.y);
                var dr = (compareWith.x - right.x) * (compareWith.x - right.x);
                dr += (compareWith.y - right.y) * (compareWith.y - right.y);
                if (dl == dr) {
                    return 0
                }
                return (dl < dr) ? -1 : 1
            }
        };
        MindFusion.registerClass(DiagramLink, "MindFusion.Diagramming.DiagramLink", mdiag.DiagramItem)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var DoNothingBehavior = mdiag.DoNothingBehavior = function(parent) {
            mflayer.initializeBase(DoNothingBehavior, this, [parent])
        };
        DoNothingBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                this.currentCursor = MindFusion.Controls.MouseCursors.Default;
                return this.currentCursor
            },
            createController: function(state) {
                return null
            }
        };
        MindFusion.registerClass(DoNothingBehavior, "MindFusion.Diagramming.DoNothingBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var DrawLinksBehavior = mdiag.DrawLinksBehavior = function(parent) {
            mflayer.initializeBase(DrawLinksBehavior, this, [parent])
        };
        DrawLinksBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                var handleAtPoint = this.diagram.selection.handleAtPoint(point);
                if (handleAtPoint) {
                    return this.setCurrentCursor(MouseCursors.Move)
                }
                var adjustmentHandle = this.diagram.getHandleAt(point);
                if (adjustmentHandle) {
                    return this.setModfCursor(point, adjustmentHandle)
                }
                var node = this.diagram.getNodeAt(point, true, true);
                if (node != null && node.acceptLinks(true)) {
                    return this.setCurrentCursor(MouseCursors.Pointer)
                }
                return this.setCurrentCursor(MouseCursors.Default)
            },
            createController: function(state) {
                var controller = mflayer.callBaseMethod(DrawLinksBehavior, this, "createController", [state]);
                if (controller) {
                    return controller
                }
                var diagram = this.diagram;
                var originNode = diagram.getNodeAt(state.pointerPosition, true, true);
                if (originNode != null && originNode.acceptLinks(true) || originNode == null && diagram.allowUnconnectedLinks) {
                    var link = this.createLink(originNode, state.pointerPosition);
                    var handle = {
                        item: link,
                        index: link.points.length - 1
                    };
                    return new mdiag.CreateLinkController(diagram, link)
                }
                return new mdiag.CreateSelectionController(diagram.selection)
            }
        };
        MindFusion.registerClass(DrawLinksBehavior, "MindFusion.Diagramming.DrawLinksBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var DrawNodesBehavior = mdiag.DrawNodesBehavior = function(parent, nodeConstructor) {
            mflayer.initializeBase(DrawNodesBehavior, this, [parent]);
            this.nodeConstructor = nodeConstructor
        };
        DrawNodesBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                var handleAtPoint = this.diagram.selection.handleAtPoint(point);
                if (handleAtPoint) {
                    return this.setCurrentCursor(MouseCursors.Move)
                }
                var adjustmentHandle = this.diagram.getHandleAt(point);
                if (adjustmentHandle) {
                    return this.setModfCursor(point, adjustmentHandle)
                }
                return this.setCurrentCursor(MouseCursors.Default)
            },
            createNode: function() {
                return this.nodeConstructor(this.diagram)
            },
            createController: function(state) {
                var controller = mflayer.callBaseMethod(DrawNodesBehavior, this, "createController", [state]);
                if (controller) {
                    return controller
                }
                var diagram = this.diagram;
                var w = diagram.getAlignToGrid() ? diagram.getGridSizeX() : 1;
                var h = diagram.getAlignToGrid() ? diagram.getGridSizeY() : 1;
                var node = this.createNode();
                var alignedPoint = diagram.alignResize(node, state.pointerPosition, mdiag.AdjustmentHandles.ResizeTopLeft);
                node.setBounds(new MindFusion.Drawing.Rect(alignedPoint.x, alignedPoint.y, w, h));
                controller = new mdiag.CreateNodeController(diagram, node);
                controller.convertToShape = this.convertToShape;
                return controller
            }
        };
        MindFusion.registerClass(DrawNodesBehavior, "MindFusion.Diagramming.DrawNodesBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var DummyNode = mdiag.DummyNode = function(parent) {
            mflayer.initializeBase(DummyNode, this, [parent])
        };
        DummyNode.prototype = {
            considerBounds: function() {
                return false
            },
            getIntersection: function(segmentStart, segmentEnd) {
                return segmentStart
            }
        };
        MindFusion.registerClass(DummyNode, "MindFusion.Diagramming.DummyNode", mdiag.DiagramNode)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ItemEventArgs = mdiag.ItemEventArgs = function(args) {
            mflayer.initializeBase(ItemEventArgs, this);
            if (args.sender) {
                this.sender = args.sender
            }
            if (args.bounds) {
                this.bounds = args.bounds
            }
            if (args.mousePosition) {
                this.mousePosition = args.mousePosition
            }
            if (args.mouseButton !== undefined) {
                this.mouseButton = args.mouseButton
            }
            if (args.adjustmentHandle !== undefined) {
                this.adjustmentHandle = args.adjustmentHandle
            }
            if (args.newText !== undefined) {
                this.newText = args.newText
            }
            if (args.oldText !== undefined) {
                this.oldText = args.oldText
            }
            if (args.context !== undefined) {
                this.context = args.context
            }
            if (args.item !== undefined) {
                this.item = args.item
            }
        };
        ItemEventArgs.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getMouseButton: function() {
                return this.mouseButton
            },
            getAdjustmentHandle: function() {
                return this.adjustmentHandle
            },
            setAdjustmentHandle: function(value) {
                this.adjustmentHandle = value
            },
            getNewText: function() {
                return this.newText
            },
            getOldText: function() {
                return this.oldText
            },
            getContext: function() {
                return this.context
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(value) {
                this.handled = value
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(value) {
                this.cancel = value
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            },
            getItem: function() {
                return this.item
            }
        };
        MindFusion.registerClass(ItemEventArgs, "MindFusion.Diagramming.ItemEventArgs", MindFusion.CancelEventArgs);
        var NodeEventArgs = mdiag.NodeEventArgs = function(args) {
            mflayer.initializeBase(NodeEventArgs, this, [args]);
            if (args.node) {
                this.node = args.node
            }
            if (args.container !== undefined) {
                this.container = args.container
            }
        };
        NodeEventArgs.prototype = {
            getNode: function() {
                return this.node
            },
            getContainer: function() {
                return this.container
            }
        };
        MindFusion.registerClass(NodeEventArgs, "MindFusion.Diagramming.NodeEventArgs", ItemEventArgs);
        var LinkEventArgs = mdiag.LinkEventArgs = function(args) {
            mflayer.initializeBase(LinkEventArgs, this, [args]);
            if (args.link) {
                this.link = args.link
            }
        };
        LinkEventArgs.prototype = {
            getLink: function() {
                return this.link
            }
        };
        MindFusion.registerClass(LinkEventArgs, "MindFusion.Diagramming.LinkEventArgs", ItemEventArgs);
        var ComponentEventArgs = mdiag.ComponentEventArgs = function(args) {
            mflayer.initializeBase(ComponentEventArgs, this, [args]);
            if (args.component) {
                this.component = args.component
            }
        };
        ComponentEventArgs.prototype = {
            getComponent: function() {
                return this.component
            }
        };
        MindFusion.registerClass(ComponentEventArgs, "MindFusion.Diagramming.ComponentEventArgs", NodeEventArgs);
        var SelectionEventArgs = mdiag.SelectionEventArgs = function(args) {
            mflayer.initializeBase(SelectionEventArgs, this);
            if (args.sender) {
                this.sender = args.sender
            }
            if (args.mousePosition) {
                this.mousePosition = args.mousePosition
            }
            if (args.adjustmentHandle !== undefined) {
                this.adjustmentHandle = args.adjustmentHandle
            }
        };
        SelectionEventArgs.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getAdjustmentHandle: function() {
                return this.adjustmentHandle
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(value) {
                this.cancel = value
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            }
        };
        MindFusion.registerClass(SelectionEventArgs, "MindFusion.Diagramming.SelectionEventArgs", MindFusion.CancelEventArgs);
        var DiagramEventArgs = mdiag.DiagramEventArgs = function(args) {
            mflayer.initializeBase(DiagramEventArgs, this);
            if (args.sender) {
                this.sender = args.sender
            }
            if (args.mousePosition) {
                this.mousePosition = args.mousePosition
            }
            if (args.mouseButton !== undefined) {
                this.mouseButton = args.mouseButton
            }
        };
        DiagramEventArgs.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getMouseButton: function() {
                return this.mouseButton
            }
        };
        MindFusion.registerClass(DiagramEventArgs, "MindFusion.Diagramming.DiagramEventArgs", MindFusion.EventArgs);
        var InplaceEditEventArgs = mdiag.InplaceEditEventArgs = function(args) {
            mflayer.initializeBase(InplaceEditEventArgs, this);
            if (args.item) {
                this.item = args.item
            }
            if (args.control) {
                this.control = args.control
            }
            if (args.bounds) {
                this.bounds = args.bounds
            }
        };
        InplaceEditEventArgs.prototype = {
            getItem: function() {
                return this.item
            },
            getControl: function() {
                return this.control
            },
            setControl: function(value) {
                this.control = value
            },
            getBounds: function() {
                return this.bounds
            }
        };
        MindFusion.registerClass(InplaceEditEventArgs, "MindFusion.Diagramming.InplaceEditEventArgs", MindFusion.EventArgs);
        var CellEventArgs = mdiag.CellEventArgs = function(args) {
            mflayer.initializeBase(CellEventArgs, this);
            if (args.sender) {
                this.sender = args.sender
            }
            if (args.node) {
                this.node = args.node
            }
            if (args.cell) {
                this.cell = args.cell
            }
            if (args.column !== undefined) {
                this.column = args.column
            }
            if (args.row !== undefined) {
                this.row = args.row
            }
            if (args.newText !== undefined) {
                this.newText = args.newText
            }
            if (args.oldText !== undefined) {
                this.oldText = args.oldText
            }
            if (args.context !== undefined) {
                this.context = args.context
            }
            if (args.mouseButton !== undefined) {
                this.mouseButton = args.mouseButton
            }
            if (args.mousePosition !== undefined) {
                this.mousePosition = args.mousePosition
            }
        };
        CellEventArgs.prototype = {
            getCell: function() {
                return this.cell
            },
            getMouseButton: function() {
                return this.mouseButton
            },
            getNewText: function() {
                return this.newText
            },
            getOldText: function() {
                return this.oldText
            },
            getContext: function() {
                return this.context
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(value) {
                this.handled = value
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(value) {
                this.cancel = value
            }
        };
        MindFusion.registerClass(CellEventArgs, "MindFusion.Diagramming.CellEventArgs", MindFusion.CancelEventArgs);
        var CellValidationEventArgs = mdiag.CellValidationEventArgs = function(args) {
            mflayer.initializeBase(CellValidationEventArgs, this, [args]);
            this.cancelDrag = false
        };
        CellValidationEventArgs.prototype = {
            cancelDrag: function() {
                this.cancelDrag = true
            },
            shouldCancelDrag: function() {
                return this.cancelDrag
            }
        };
        MindFusion.registerClass(CellValidationEventArgs, "MindFusion.Diagramming.CellValidationEventArgs", MindFusion.Diagramming.CellEventArgs);
        var SerializeTagEventArgs = mdiag.SerializeTagEventArgs = function(args) {
            mflayer.initializeBase(SerializeTagEventArgs, this);
            if (args.item !== undefined) {
                this.item = args.item
            }
            if (args.tag !== undefined) {
                this.tag = args.tag
            }
            if (args.element !== undefined) {
                this.element = args.element
            }
            if (args.context !== undefined) {
                this.context = args.context
            }
            if (args.propertyName !== undefined) {
                this.propertyName = args.propertyName
            }
            this.handled = false
        };
        SerializeTagEventArgs.prototype = {
            getObject: function() {
                return this.item
            },
            getTag: function() {
                return this.tag
            },
            setTag: function(value) {
                this.tag = value
            },
            getElement: function() {
                return this.element
            },
            getContext: function() {
                return this.context
            },
            getPropertyName: function() {
                return this.propertyName
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(value) {
                this.handled = value
            }
        };
        MindFusion.registerClass(SerializeTagEventArgs, "MindFusion.Diagramming.SerializeTagEventArgs", MindFusion.EventArgs);
        var HeaderEventArgs = mdiag.HeaderEventArgs = function(header) {
            mflayer.initializeBase(HeaderEventArgs, this);
            this.header = header
        };
        HeaderEventArgs.prototype = {
            getHeader: function() {
                return this.header
            }
        };
        MindFusion.registerClass(HeaderEventArgs, "MindFusion.Diagramming.HeaderEventArgs", MindFusion.EventArgs);
        var HeaderResizeEventArgs = mdiag.HeaderResizeEventArgs = function(header, horizontal) {
            mflayer.initializeBase(HeaderResizeEventArgs, this, [header]);
            this.horizontal = horizontal
        };
        HeaderResizeEventArgs.prototype = {
            getHorizontal: function() {
                return this.horizontal
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(value) {
                this.cancel = value
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            }
        };
        MindFusion.registerClass(HeaderResizeEventArgs, "MindFusion.Diagramming.HeaderResizeEventArgs", MindFusion.Diagramming.HeaderEventArgs)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Events = {
        initializeLink: "initializeLink",
        initializeNode: "initializeNode",
        linkClicked: "linkClicked",
        linkCreated: "linkCreated",
        linkDeleted: "linkDeleted",
        linkDoubleClicked: "linkDoubleClicked",
        linkModified: "linkModified",
        linkPointed: "linkPointed",
        linkTextEdited: "linkTextEdited",
        nodeClicked: "nodeClicked",
        nodeCreated: "nodeCreated",
        nodeDeleted: "nodeDeleted",
        nodeDoubleClicked: "nodeDoubleClicked",
        nodeModified: "nodeModified",
        nodePointed: "nodePointed",
        nodeTextEdited: "nodeTextEdited",
        linkCreating: "linkCreating",
        linkDeleting: "linkDeleting",
        linkModifying: "linkModifying",
        nodeCreating: "nodeCreating",
        nodeDeleting: "nodeDeleting",
        nodeModifying: "nodeModifying",
        containerChildAdded: "containerChildAdded",
        containerChildAdding: "containerChildAdding",
        containerChildRemoving: "containerChildRemoving",
        containerChildRemoved: "containerChildRemoved",
        containerFolded: "containerFolded",
        containerUnfolded: "containerUnfolded",
        treeExpanded: "treeExpanded",
        treeCollapsed: "treeCollapsed",
        selectionModifying: "selectionModifying",
        repaint: "repaint",
        sizeChanged: "sizeChanged",
        nodeSelected: "nodeSelected",
        nodeDeselected: "nodeDeselected",
        linkSelected: "linkSelected",
        linkDeselected: "linkDeselected",
        controlLoaded: "controlLoaded",
        hitTestAdjustmentHandles: "hitTestAdjustmentHandles",
        drawAdjustmentHandles: "drawAdjustmentHandles",
        clicked: "clicked",
        enterInplaceEditMode: "enterInplaceEditMode",
        leaveInplaceEditMode: "leaveInplaceEditMode",
        createEditControl: "createEditControl",
        cellTextEdited: "cellTextEdited",
        laneGridCellTextEdited: "laneGridCellTextEdited",
        serializeTag: "serializeTag",
        deserializeTag: "deserializeTag",
        tableColumnResizing: "tableColumnResizing",
        tableColumnResized: "tableColumnResized",
        tableRowResizing: "tableRowResizing",
        tableRowResized: "tableRowResized",
        nodePasted: "nodePasted",
        linkPasted: "linkPasted",
        headerStartResizing: "headerStartResizing",
        headerResized: "headerResized",
        itemAdded: "itemAdded",
        itemRemoved: "itemRemoved",
        animatedLayoutCompleted: "animatedLayoutCompleted"
    };
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var ExpandButton = mdiag.ExpandButton = function(node) {
            mflayer.initializeBase(ExpandButton, this, [node]);
            this.updateContent();
            this.updateLocation()
        };
        ExpandButton.prototype = {
            updateLocation: function() {
                var iconRect = this.getRect();
                this.x = iconRect.x;
                this.y = iconRect.y
            },
            onClick: function(mousePosition) {
                if (!this.hitTest(mousePosition)) {
                    return
                }
                if (this.node.parent != null) {
                    this.node.parent.startTotalChange()
                }
                var node = this.node;
                if (node.expanded) {
                    node.collapse();
                    node.parent.raiseTreeCollapsed(node)
                } else {
                    node.expand();
                    node.parent.raiseTreeExpanded(node)
                }
                if (this.node.parent != null) {
                    this.node.parent.commitCompositeOperation()
                }
            },
            hitTest: function(mousePosition) {
                return this.getRotatedRect().containsPoint(mousePosition)
            },
            getRect: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var c = node.bounds.center();
                return Rect.fromLTRB(node.bounds.right() + mm, c.y - 2 * mm, node.bounds.right() + 5 * mm, c.y + 2 * mm)
            },
            getRotatedRect: function() {
                var rect = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var p = [];
                    p.push(rect.topLeft());
                    p.push(rect.topRight());
                    p.push(rect.bottomRight());
                    p.push(rect.bottomLeft());
                    mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                    var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                    var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                    var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                    return Rect.fromLTRB(minX, minY, maxX, maxY)
                }
                return rect
            },
            drawMinus: function(rect, mm) {
                rect.brush = "white";
                this.content = [rect];
                var y = rect.y + rect.height / 2;
                var line = new MindFusion.Drawing.Line(rect.x + mm, y, rect.right() - mm, y);
                this.content.push(line)
            },
            drawPlus: function(rect, mm) {
                this.drawMinus(rect, mm);
                var x = rect.x + rect.width / 2;
                var line = new MindFusion.Drawing.Line(x, rect.y + mm, x, rect.bottom() - mm);
                this.content.push(line)
            },
            updateContent: function() {
                var mm = GraphicsUnit.getMillimeter(this.node.parent.measureUnit);
                var rect = this.getRect();
                rect.x = rect.y = 0;
                if (this.node.expanded) {
                    this.drawMinus(rect, mm)
                } else {
                    this.drawPlus(rect, mm)
                }
            }
        };
        MindFusion.registerClass(ExpandButton, "MindFusion.Diagramming.ExpandButton", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Rect = MindFusion.Drawing.Rect;
        var Factory = mdiag.Factory = function(diagram) {
            this.diagram = diagram
        };
        Factory.prototype.createShapeNode = function() {
            var node = new mdiag.ShapeNode(this.diagram);
            if (arguments.length == 1) {
                node.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    node.setBounds(Rect.fromArgs(arguments))
                }
            }
            this.diagram.addItem(node);
            return node
        };
        Factory.prototype.createTableNode = function() {
            var node = new mdiag.TableNode(this.diagram);
            if (arguments.length == 1) {
                node.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    node.setBounds(Rect.fromArgs(arguments))
                }
            }
            this.diagram.addItem(node);
            return node
        };
        Factory.prototype.createContainerNode = function() {
            var node = new mdiag.ContainerNode(this.diagram);
            if (arguments.length == 1) {
                node.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    node.setBounds(Rect.fromArgs(arguments))
                }
            }
            this.diagram.addItem(node);
            return node
        };
        Factory.prototype.createSvgNode = function() {
            var node = new mdiag.SvgNode(this.diagram);
            if (arguments.length == 1) {
                node.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    node.setBounds(Rect.fromArgs(arguments))
                }
            }
            this.diagram.addItem(node);
            return node
        };
        Factory.prototype.createDiagramLink = function(origin, destination) {
            var link = new mdiag.DiagramLink(this.diagram, origin, destination);
            this.diagram.addItem(link);
            return link
        };
        MindFusion.registerClass(Factory, "MindFusion.Diagramming.Factory")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var Ellipse = MindFusion.Drawing.Ellipse;
        var Line = MindFusion.Drawing.Line;
        var Folder = mdiag.Folder = function(node) {
            mflayer.initializeBase(Folder, this, [node]);
            this.updateContent();
            this.updateLocation()
        };
        Folder.prototype = {
            updateLocation: function() {
                var iconRect = this.getRect();
                this.x = iconRect.x;
                this.y = iconRect.y
            },
            onClick: function(mousePosition) {
                if (!this.hitTest(mousePosition)) {
                    return
                }
                var node = this.node;
                if (node.parent.getUndoEnabled()) {
                    node.parent.undoManager.startComposite();
                    node.parent.undoManager.executeCommand(new mdiag.FoldContainerCommand(this, node));
                    node.parent.undoManager.endComposite()
                } else {
                    node.setFolded(!node.getFolded())
                }
                if (node.getFolded()) {
                    node.raiseFolded(node)
                } else {
                    node.raiseUnfolded(node)
                }
            },
            hitTest: function(mousePosition) {
                return this.getRotatedRect().containsPoint(mousePosition) && mdiag.Utils.pointInPolygon(mousePosition, this.getOutline())
            },
            getRect: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var diameter = node.getCaptionHeight();
                if (node.getFoldIconSize() != null) {
                    diameter = node.getFoldIconSize()
                }
                var padding = mm;
                if (padding > diameter / 4) {
                    padding = diameter / 4
                }
                var rect = node.bounds.clone();
                rect.height = diameter;
                rect.x = rect.right() - diameter;
                rect.width = diameter;
                rect = rect.inflate(-padding, -padding);
                return rect
            },
            getRotatedRect: function() {
                var rect = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var p = [];
                    p.push(rect.topLeft());
                    p.push(rect.topRight());
                    p.push(rect.bottomRight());
                    p.push(rect.bottomLeft());
                    mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                    var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                    var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                    var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                    return Rect.fromLTRB(minX, minY, maxX, maxY)
                }
                return rect
            },
            getOutline: function() {
                var rect = this.getRect();
                var p = [];
                p.push(rect.topLeft());
                p.push(rect.topRight());
                p.push(rect.bottomRight());
                p.push(rect.bottomLeft());
                mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                return p
            },
            updateContent: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var hm = 3 * mm / 4;
                var folderRect = this.getRect();
                folderRect.x = folderRect.y = 0;
                var ellipse = new Ellipse(folderRect);
                ellipse.pen = "lightgray";
                ellipse.brush = "white";
                this.content = [ellipse];
                var off = folderRect.width / 5;
                var hcenter = folderRect.x + folderRect.width / 2;
                var vcenter1 = folderRect.y + folderRect.height / 2 - off / 2;
                var smalloff = mm / 2;
                var recip = off - smalloff;
                var vcenter2 = vcenter1 + smalloff;
                var vcenter3 = folderRect.y + folderRect.height / 2 + off / 2;
                var vcenter4 = vcenter3 - smalloff;
                if (!node.folded) {
                    var line1 = new Line(hcenter, vcenter1, hcenter - off, vcenter1 + off);
                    line1.pen = "lightgray";
                    this.content.push(line1);
                    var line2 = new Line(hcenter, vcenter1, hcenter + off, vcenter1 + off);
                    line2.pen = "lightgray";
                    this.content.push(line2);
                    if (recip > 0) {
                        var line3 = new Line(hcenter, vcenter2, hcenter - recip, vcenter2 + recip);
                        line3.pen = "lightgray";
                        this.content.push(line3);
                        var line4 = new Line(hcenter, vcenter2, hcenter + recip, vcenter2 + recip);
                        line4.pen = "lightgray";
                        this.content.push(line4)
                    }
                } else {
                    var line1 = new Line(hcenter, vcenter3, hcenter - off, vcenter3 - off);
                    line1.pen = "lightgray";
                    this.content.push(line1);
                    var line2 = new Line(hcenter, vcenter3, hcenter + off, vcenter3 - off);
                    line2.pen = "lightgray";
                    this.content.push(line2);
                    if (recip > 0) {
                        var line3 = new Line(hcenter, vcenter4, hcenter - recip, vcenter4 - recip);
                        line3.pen = "lightgray";
                        this.content.push(line3);
                        var line4 = new Line(hcenter, vcenter4, hcenter + recip, vcenter4 - recip);
                        line4.pen = "lightgray";
                        this.content.push(line4)
                    }
                }
            }
        };
        MindFusion.registerClass(Folder, "MindFusion.Diagramming.Folder", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Matrix = MindFusion.Drawing.Matrix;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var FreeFormNode = mdiag.FreeFormNode = function(parent) {
            mflayer.initializeBase(FreeFormNode, this, [parent]);
            this.points = [];
            this.path = new MindFusion.Drawing.Path();
            this.shapeRenderer = {
                node: this,
                getOutline: function() {
                    return this.node.path
                }
            };
            this.text.fitInBounds = true;
            this.text.textAlignment = mdiag.Alignment.Center;
            this.text.lineAlignment = mdiag.Alignment.Center
        };
        FreeFormNode.prototype = {
            getClosed: function() {
                return this.closed
            },
            setClosed: function(value) {
                if (this.closed != value) {
                    this.closed = value;
                    this.invalidate()
                }
            },
            getPoints: function() {
                return this.points
            },
            setPoints: function(value) {
                if (this.points != value) {
                    this.points = value;
                    this.updateFromPoints()
                }
            },
            clone: function() {
                var copy = mflayer.callBaseMethod(FreeFormNode, this, "clone", []);
                copy.closed = this.closed;
                copy.points = clonePoints(this.points);
                copy.updatePathFromPoints();
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(FreeFormNode, this, "toJson", []);
                json.closed = this.closed;
                json.points = toCoordString(this.points);
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(FreeFormNode, this, "fromJson", [json]);
                this.closed = json.closed;
                this.points = fromCoordString(json.points);
                this.updatePathFromPoints()
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(FreeFormNode, this, "loadFromXml", [xmlElement, context]);
                this.closed = context.readBool("Closed", xmlElement);
                this.points = fromCoordString(context.readString("Points", xmlElement));
                this.updatePathFromPoints()
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(FreeFormNode, this, "saveToXml", [xmlElement, context]);
                context.writeBool(this.closed, "Closed", xmlElement);
                context.writeString(toCoordString(this.points), "Points", xmlElement)
            },
            updateCanvasElements: function() {
                var content = this.graphicsContainer.content = [];
                var rect = this.bounds;
                var brush = this.getEffectiveBrush();
                if (this.closed) {
                    var params = {
                        brush: brush,
                        phase: EffectPhase.BeforeFill
                    };
                    this.applyEffects(content, params);
                    if (params.brush) {
                        brush = params.brush
                    }
                }
                if (this.closed) {
                    this.path.brush = brush
                } else {
                    this.path.brush = null
                }
                this.path.pen = this.getEffectiveStroke();
                this.path.strokeThickness = 1;
                this.path.strokeDashStyle = this.getEffectiveStrokeDashStyle();
                this.path.shadow = this.createShadow();
                content.push(this.path);
                if (this.closed) {
                    this.applyEffects(content, {
                        phase: EffectPhase.AfterFill
                    })
                }
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.setBounds(rect, (this.rotateText) ? this.rotationAngle : 0);
                content.push(this.text);
                this.addManipulatorVisuals(content);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            startDrag: function(ist) {
                if (ist.action == mdiag.Action.Create) {
                    var point = ist.startPoint.clone();
                    this.points.push(point);
                    this.path.moveTo(point.x, point.y)
                }
                if (ist.action == mdiag.Action.Modify && mflayer.isInstanceOfType(mdiag.FreeFormHandle, ist.adjustmentHandle)) {
                    var formHandle = ist.adjustmentHandle;
                    var attractThreshold = Math.min(this.bounds.width / 6, Math.min(this.bounds.height / 6, this.parent.freeFormAttractDistance));
                    this.attractedPoints = [];
                    var p = this.points[formHandle.index];
                    for (var inc = -1; inc <= 1; inc += 2) {
                        for (var i = formHandle.index + inc; true; i += inc) {
                            var index = i % this.points.length;
                            if (index < 0) {
                                index = this.points.length + index
                            }
                            if (index == formHandle.index) {
                                this.attractedPoints = [];
                                break
                            }
                            var p2 = this.points[index];
                            var d = Point.distance(p, p2);
                            if (d > attractThreshold) {
                                break
                            }
                            this.attractedPoints[index] = d
                        }
                    }
                }
                mflayer.callBaseMethod(FreeFormNode, this, "startDrag", [ist])
            },
            updateDrag: function(ist) {
                if (ist.action == mdiag.Action.Create) {
                    var last = this.points[this.points.length - 1];
                    var current = ist.currentPoint;
                    if (!last.equals(current)) {
                        var point = current.clone();
                        this.points.push(point);
                        this.path.lineTo(point.x, point.y);
                        this.updateFromPoints(false, false)
                    }
                    return
                }
                if (ist.action == mdiag.Action.Modify && mflayer.isInstanceOfType(mdiag.FreeFormHandle, ist.adjustmentHandle)) {
                    var state = ist.originalStates.get(this);
                    var originalPoints = state.originalPoints;
                    var formHandle = ist.adjustmentHandle;
                    var index = formHandle.index;
                    var dx = ist.currentPoint.x - originalPoints[index].x;
                    var dy = ist.currentPoint.y - originalPoints[index].y;
                    for (var k = 0; k < this.attractedPoints.length; k++) {
                        var v = this.attractedPoints[k];
                        if (v === undefined) {
                            continue
                        }
                        var p2 = originalPoints[k].clone();
                        var d = GraphicsUnit.convert(v, GraphicsUnit.Millimeter, this.parent.measureUnit);
                        d = Math.max(d / 2, 1);
                        p2.x += dx / (d * d);
                        p2.y += dy / (d * d);
                        this.points[k] = p2
                    }
                    this.points[index] = ist.currentPoint.clone();
                    if (!this.outlineBounds().equals(this.bounds)) {
                        this.updateFromPoints(true, false)
                    }
                    this.updatePathFromPoints();
                    this.invalidate();
                    return
                }
                mflayer.callBaseMethod(FreeFormNode, this, "updateDrag", [ist])
            },
            endDrag: function(ist) {
                mflayer.callBaseMethod(FreeFormNode, this, "endDrag", [ist]);
                if (ist.action == mdiag.Action.Create) {
                    if (Point.distance(ist.currentPoint, this.points[0]) < this.parent.autoCloseDistance) {
                        this.closed = true;
                        this.path.close();
                        this.invalidate()
                    }
                }
            },
            saveLocationState: function() {
                var state = mflayer.callBaseMethod(FreeFormNode, this, "saveLocationState", []);
                state.originalPoints = this.points.slice();
                return state
            },
            restoreLocationState: function(ist) {
                var state = ist.originalStates.get(this);
                if (state != null) {
                    if (mflayer.isInstanceOfType(mdiag.FreeFormHandle, ist.adjustmentHandle)) {
                        this.points = state.originalPoints.slice();
                        this.updateFromPoints(false, true)
                    }
                }
                mflayer.callBaseMethod(FreeFormNode, this, "restoreLocationState", [ist])
            },
            outlineBounds: function(points) {
                if (points === undefined) {
                    points = this.points
                }
                var union = null;
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    if (union == null) {
                        union = new Rect(point.x, point.y, 0, 0)
                    } else {
                        union = calcPointBounds(union, point)
                    }
                }
                return union != null ? union : Rect.empty
            },
            updateFromPoints: function(relations, path) {
                if (relations === undefined) {
                    relations = true
                }
                if (path === undefined) {
                    path = true
                }
                this.updateFlag = true;
                this.setBounds(this.outlineBounds(), relations);
                this.updateFlag = false;
                if (path) {
                    this.updatePathFromPoints()
                }
            },
            updatePathFromPoints: function() {
                this.path = new MindFusion.Drawing.Path();
                for (var i = 0; i < this.points.length; i++) {
                    var point = this.points[i];
                    if (i == 0) {
                        this.path.moveTo(point.x, point.y)
                    } else {
                        this.path.lineTo(point.x, point.y)
                    }
                }
                if (this.closed) {
                    this.path.close()
                }
            },
            onUpdateBounds: function() {
                mflayer.callBaseMethod(FreeFormNode, this, "onUpdateBounds", []);
                if (this.updateFlag) {
                    return
                }
                var strokeBounds = this.outlineBounds();
                if (strokeBounds.equals(this.bounds)) {
                    return
                }
                var w = this.bounds.width;
                var h = this.bounds.height;
                var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                if (w > mm && h > mm) {
                    if (w != strokeBounds.width || h != strokeBounds.height) {
                        var scale = new Matrix();
                        scale.scaleAtCenter(w / strokeBounds.width, h / strokeBounds.height, this.bounds);
                        scale.transformPoints(this.points)
                    }
                    var translate = new Matrix();
                    strokeBounds = this.outlineBounds();
                    translate.translate(this.bounds.x - strokeBounds.x, this.bounds.y - strokeBounds.y);
                    translate.transformPoints(this.points);
                    this.updatePathFromPoints()
                }
            },
            handleAtPoint: function(point) {
                var index = this.nearestPointIndex(point, 4 * GraphicsUnit.getMillimeter(this.parent.measureUnit));
                if (index !== null) {
                    return new mdiag.FreeFormHandle(this, index)
                }
                return mflayer.callBaseMethod(FreeFormNode, this, "handleAtPoint", [point])
            },
            nearestPointIndex: function(point, maxDist) {
                var minDist = Number.MAX_VALUE;
                var minDistIndex = null;
                for (var i = 0; i < this.points.length; i++) {
                    var sp = this.points[i];
                    if (Math.abs(sp.x - point.x) > maxDist || Math.abs(sp.y - point.y) > maxDist) {
                        continue
                    }
                    var dist = Point.distance(point, sp);
                    if (dist < minDist) {
                        minDistIndex = i;
                        minDist = dist
                    }
                }
                return minDistIndex
            },
            containsPoint: function(point) {
                return mdiag.ShapeNode.prototype.containsPoint.apply(this, [point])
            },
            drawHandles: function(context) {
                mflayer.callBaseMethod(FreeFormNode, this, "drawHandles", [context]);
                var handleSize = this.getEffectiveHandlesSize();
                context.save();
                context.lineWidth = 1 / context._mf_scale;
                context.strokeStyle = "black";
                context.fillStyle = "yellow";
                for (var i = 0; i < this.points.length; i++) {
                    var point = this.points[i];
                    context.beginPath();
                    context.arc(point.x, point.y, handleSize / 4, 0, 2 * Math.PI);
                    context.fill();
                    context.stroke()
                }
                context.restore()
            },
            getOutline: function() {
                return clonePoints(this.points)
            },
            getNearestBorderPoint: function(point) {
                return mflayer.callBaseMethod(FreeFormNode, this, "getNearestBorderPoint", [point])
            },
            resolveInheritedStyle: function(check, theme) {
                var nodeStyle = theme.styles["std:FreeFormNode"];
                if (nodeStyle) {
                    if (check.apply(nodeStyle)) {
                        return nodeStyle
                    }
                }
                return mflayer.callBaseMethod(FreeFormNode, this, "resolveInheritedStyle", [check, theme])
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(FreeFormNode, this, "saveState", []);
                state.closed = this.closed;
                state.points = clonePoints(this.points);
                return state
            },
            restoreState: function(state) {
                this.updateFlag = true;
                mflayer.callBaseMethod(FreeFormNode, this, "restoreState", [state]);
                this.updateFlag = false;
                this.closed = state.closed;
                this.points = clonePoints(state.points);
                this.updatePathFromPoints()
            },
            standardShapeReplacement: function(shapes, defaultShape) {
                var rect = this.getBounds();
                var bestShape = null;
                var bestDeviation = Number.MAX_VALUE;
                var maxDeviation = 20 * GraphicsUnit.getMillimeter(this.parent.measureUnit);
                var testNode = new mdiag.ShapeNode(this.parent);
                testNode.setBounds(rect);
                for (var i = 0; i < shapes.length; i++) {
                    var shape = shapes[i];
                    testNode.setShape(shape);
                    var outline = testNode.getOutline();
                    var deviation = 0;
                    for (var p = 0; p < this.points.length; p++) {
                        var point = this.points[p];
                        var distance = mdiag.Utils.distToPolyline(point, outline, outline.length);
                        deviation += distance
                    }
                    deviation /= this.points.length;
                    if (deviation < bestDeviation) {
                        bestShape = shape;
                        bestDeviation = deviation
                    }
                }
                testNode.setShape(bestDeviation < maxDeviation ? bestShape : defaultShape);
                return testNode
            },
            init: function() {
                if (!mdiag.FreeFormNodeBuilder) {
                    mdiag.FreeFormNodeBuilder = new MindFusion.Builder(FreeFormNode.prototype, null, this)
                } else {
                    mdiag.FreeFormNodeBuilder.setInstance(this)
                }
                return mdiag.FreeFormNodeBuilder
            }
        };
        FreeFormNode.With = function(diagram) {
            if (!mdiag.FreeFormNodeBuilder) {
                mdiag.FreeFormNodeBuilder = new MindFusion.Builder(FreeFormNode.prototype, diagram)
            } else {
                mdiag.FreeFormNodeBuilder.setInstance(null)
            }
            return mdiag.FreeFormNodeBuilder
        };
        mdiag.FreeFormNodeBuilder = null;
        MindFusion.registerClass(FreeFormNode, "MindFusion.Diagramming.FreeFormNode", mdiag.DiagramNode);
        mdiag.FreeFormHandle = function(node, pointIndex) {
            this.item = node;
            this.index = pointIndex
        };
        MindFusion.registerClass(mdiag.FreeFormHandle, "MindFusion.Diagramming.FreeFormHandle");

        function calcPointBounds(bounds, newPoint) {
            if (bounds.containsPoint(newPoint)) {
                return bounds
            }
            return Rect.fromLTRB(Math.min(bounds.left(), newPoint.x), Math.min(bounds.top(), newPoint.y), Math.max(bounds.right(), newPoint.x), Math.max(bounds.bottom(), newPoint.y))
        }

        function clonePoints(points) {
            var copy = [];
            for (var i = 0; i < points.length; i++) {
                copy[i] = points[i].clone()
            }
            return copy
        }

        function toCoordString(points) {
            var coords = "";
            for (var i = 0; i < points.length; i++) {
                if (i > 0) {
                    coords += ","
                }
                coords += points[i].x.toString();
                coords += ",";
                coords += points[i].y.toString()
            }
            return coords
        }

        function fromCoordString(coords) {
            var points = [];
            var vals = coords.split(",");
            for (var i = 0; i < vals.length; i += 2) {
                var xs = vals[i];
                var ys = vals[i + 1];
                var point = new Point(Number(xs), Number(ys));
                points.push(point)
            }
            return points
        }
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Point = MindFusion.Drawing.Point;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var HandleUtils = mdiag.HandleUtils = {
            pointInHandle: function(point, item) {
                var AdjustmentHandles = mdiag.AdjustmentHandles;
                var HandlesStyle = mdiag.HandlesStyle;
                var bounds = item.getBounds();
                var rotationAngle = item.getRotationAngle();
                var style = item.getHandlesStyle();
                var mask = item.getEnabledHandles();
                var diagram = item.getParent();
                var size = item.getEffectiveHandlesSize();
                var touchThreshold = diagram.touchThreshold;
                if (touchThreshold === undefined) {
                    touchThreshold = 0
                }
                if (rotationAngle) {
                    point = mdiag.Utils.rotatePointAt(point, bounds.center(), -rotationAngle)
                }
                if (style == HandlesStyle.MoveOnly || style == HandlesStyle.InvisibleMove) {
                    return bounds.containsPoint(point) && (mask & AdjustmentHandles.Move) != 0 ? {
                        item: item,
                        index: 8
                    } : null
                }
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                if (style == HandlesStyle.SquareHandles || style == HandlesStyle.HatchHandles || style == HandlesStyle.EasyMove || style == HandlesStyle.RoundAndSquare || style == HandlesStyle.RoundAndSquare2) {
                    var pts = HandleUtils.getHandlePositions(bounds, mm);
                    if (style == HandlesStyle.EasyMove && (point.distance(pts[8]) < 1.5 * size)) {
                        return null
                    }
                    for (var i = 0; i < 10; ++i) {
                        if (Math.abs(pts[i].x - point.x) <= (size / 2 + touchThreshold) && Math.abs(pts[i].y - point.y) <= (size / 2 + touchThreshold) && (mask & (1 << i)) != 0) {
                            return {
                                item: item,
                                index: i
                            }
                        }
                    }
                    if (style == HandlesStyle.EasyMove && bounds.containsPoint(point) && (mask & AdjustmentHandles.Move) != 0) {
                        return {
                            item: item,
                            index: 8
                        }
                    }
                    bounds = bounds.inflate(size / 2);
                    if (style == HandlesStyle.HatchHandles && bounds.containsPoint(point) && (mask & AdjustmentHandles.Move) != 0) {
                        bounds = bounds.inflate(-size);
                        return !bounds.containsPoint(point) ? {
                            item: item,
                            index: 8
                        } : null
                    }
                } else {
                    var ptCorner = HandleUtils.getHandlePositions(bounds, mm);
                    for (var i = 0; i < 4; ++i) {
                        if (Math.abs(ptCorner[i].x - point.x) <= (size / 2) && Math.abs(ptCorner[i].y - point.y) <= (size / 2) && (mask & (1 << i)) != 0) {
                            return {
                                item: item,
                                index: i
                            }
                        }
                    }
                    var relax = mm / 2;
                    bounds = bounds.inflate(relax);
                    if (bounds.containsPoint(point)) {
                        bounds = bounds.inflate(-relax);
                        if (Math.abs(bounds.top() - point.y) <= (size / 2) && (mask & AdjustmentHandles.ResizeTopCenter) != 0) {
                            return {
                                item: item,
                                index: 4
                            }
                        }
                        if (Math.abs(bounds.right() - point.x) <= (size / 2) && (mask & AdjustmentHandles.ResizeMiddleRight) != 0) {
                            return {
                                item: item,
                                index: 5
                            }
                        }
                        if (Math.abs(bounds.bottom() - point.y) <= (size / 2) && (mask & AdjustmentHandles.ResizeBottomCenter) != 0) {
                            return {
                                item: item,
                                index: 6
                            }
                        }
                        if (Math.abs(bounds.left() - point.x) <= (size / 2) && (mask & AdjustmentHandles.ResizeMiddleLeft) != 0) {
                            return {
                                item: item,
                                index: 7
                            }
                        }
                    }
                    var rotHandle = ptCorner[9];
                    if (Math.abs(rotHandle.x - point.x) <= (size / 2) && Math.abs(rotHandle.y - point.y) <= (size / 2) && (mask & AdjustmentHandles.Rotate) != 0) {
                        return {
                            item: item,
                            index: 9
                        }
                    }
                    var rcCpt = bounds.clone();
                    var ht = item.getCaptionHeight ? item.getCaptionHeight() : 0;
                    if (ht != 0) {
                        rcCpt.height = ht
                    } else {
                        rcCpt = rcCpt.inflate(-size * 2)
                    }
                    if ((rcCpt.width < mm || rcCpt.height < mm) && bounds.containsPoint(point)) {
                        rcCpt = rcCpt.inflate(size)
                    }
                    if (rcCpt.containsPoint(point) && (mask & AdjustmentHandles.Move) != 0) {
                        return {
                            item: item,
                            index: 8
                        }
                    }
                }
                return null
            },
            drawAdjustmentHandles: function(context, item) {
                var AdjustmentHandles = mdiag.AdjustmentHandles;
                var HandlesStyle = mdiag.HandlesStyle;
                var diagram = item.getParent();
                var handlesStyle = item.getHandlesStyle();
                var nodeBounds = item.getBounds();
                var size = item.getEffectiveHandlesSize();
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                if (context.setLineDash) {
                    context.setLineDash([])
                }
                if (handlesStyle == HandlesStyle.Invisible || handlesStyle == HandlesStyle.InvisibleMove) {
                    return
                }
                if (handlesStyle == HandlesStyle.SquareHandles || handlesStyle == HandlesStyle.SquareHandles2 || handlesStyle == HandlesStyle.EasyMove) {
                    HandleUtils.drawSquareHandles(context, item);
                    return
                }
                if (handlesStyle == HandlesStyle.RoundAndSquare || handlesStyle == HandlesStyle.RoundAndSquare2) {
                    HandleUtils.drawRoundAndSquareHandles(context, item);
                    return
                }
                var center = nodeBounds.center();
                if (handlesStyle == HandlesStyle.DashFrame) {
                    HandleUtils.drawDashFrame(context, nodeBounds, mm);
                    if ((item.getEnabledHandles() & AdjustmentHandles.Rotate) != 0) {
                        HandleUtils.drawRotationHandle(context, item)
                    }
                    return
                }
                if (handlesStyle == HandlesStyle.HatchFrame) {
                    HandleUtils.drawHatchFrame(context, nodeBounds, HandleUtils.getHatchFill(), size);
                    if ((item.getEnabledHandles() & AdjustmentHandles.Rotate) != 0) {
                        HandleUtils.drawRotationHandle(context, item)
                    }
                    return
                }
                if (handlesStyle == HandlesStyle.HatchHandles || handlesStyle == HandlesStyle.HatchHandles2 || handlesStyle == HandlesStyle.HatchHandles3 || handlesStyle == HandlesStyle.MoveOnly) {
                    var hatchBrush = handlesStyle == HandlesStyle.HatchHandles3 || handlesStyle == HandlesStyle.MoveOnly ? HandleUtils.getPatternFill() : HandleUtils.getHatchFill();
                    HandleUtils.drawHatchFrame(context, nodeBounds, hatchBrush, size);
                    if (handlesStyle == HandlesStyle.MoveOnly) {
                        return
                    }
                    HandleUtils.drawSquareHandles(context, item);
                    return
                }
            },
            drawSquareHandles: function(context, item) {
                var AdjustmentHandles = mdiag.AdjustmentHandles;
                var HandlesStyle = mdiag.HandlesStyle;
                var bounds = item.getBounds();
                var diagram = item.getParent();
                var showDisabled = diagram.getShowDisabledHandles();
                var center = bounds.center();
                var size = item.getEffectiveHandlesSize();
                var hsize = size / 2;
                var style = item.getHandlesStyle();
                var mask = item.getEnabledHandles();
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                var handlePoints = HandleUtils.getHandlePositions(bounds, mm);
                context.fillStyle = mdiag.Utils.getBrush(context, diagram.handleBrush, diagram.getBounds());
                context.strokeStyle = "black";
                context.lineWidth = 1 / context._mf_scale;
                if ((mask & AdjustmentHandles.Rotate) != 0) {
                    HandleUtils.drawRotationHandle(context, item)
                }
                for (var h = 0; h < 9; h++) {
                    var disabled = (mask & (1 << h)) == 0;
                    if (disabled && !showDisabled) {
                        continue
                    }
                    var point = handlePoints[h];
                    if (h == 8) {
                        if (style == HandlesStyle.EasyMove) {
                            HandleUtils.drawCircle(context, point, size);
                            continue
                        }
                        if (style != HandlesStyle.SquareHandles) {
                            continue
                        }
                    }
                    context.fillRect(point.x - hsize, point.y - hsize, size, size);
                    context.strokeRect(point.x - hsize, point.y - hsize, size, size)
                }
            },
            drawRoundAndSquareHandles: function(context, item) {
                var AdjustmentHandles = mdiag.AdjustmentHandles;
                var bounds = item.getBounds();
                var diagram = item.getParent();
                var showDisabled = diagram.getShowDisabledHandles();
                var center = bounds.center();
                var size = item.getEffectiveHandlesSize();
                var hsize = size / 2;
                var mask = item.getEnabledHandles();
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                var handlePoints = HandleUtils.getHandlePositions(bounds, mm);
                context.fillStyle = mdiag.Utils.getBrush(context, diagram.handleBrush, diagram.getBounds());
                context.strokeStyle = "black";
                context.lineWidth = 1 / context._mf_scale;
                if ((mask & AdjustmentHandles.Rotate) != 0) {
                    HandleUtils.drawRotationHandle(context, item)
                }
                for (var h = 0; h < 9; h++) {
                    var disabled = (mask & (1 << h)) == 0;
                    if (disabled && !showDisabled) {
                        continue
                    }
                    var point = handlePoints[h];
                    if (h < 4) {
                        HandleUtils.drawCircle(context, point, hsize * 1.2)
                    } else {
                        context.fillRect(point.x - hsize, point.y - hsize, size, size);
                        context.strokeRect(point.x - hsize, point.y - hsize, size, size)
                    }
                }
            },
            drawDashFrame: function(context, bounds, mm) {
                context.lineWidth = 1 / context._mf_scale;
                if (context.setLineDash) {
                    context.strokeStyle = "white";
                    context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                    var dash = context.getLineDash();
                    context.setLineDash([2 * mm]);
                    context.strokeStyle = "black";
                    context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                    context.setLineDash(dash)
                } else {
                    context.strokeStyle = "lightgray";
                    context.beginPath();
                    HandleUtils.drawDashedLine(context, bounds.topLeft(), bounds.topRight(), 2 * mm);
                    HandleUtils.drawDashedLine(context, bounds.topRight(), bounds.bottomRight(), 2 * mm);
                    HandleUtils.drawDashedLine(context, bounds.bottomRight(), bounds.bottomLeft(), 2 * mm);
                    HandleUtils.drawDashedLine(context, bounds.bottomLeft(), bounds.topLeft(), 2 * mm);
                    context.stroke()
                }
            },
            drawDashedLine: function(context, p1, p2, dashLen) {
                var dashes = Math.floor(p1.distance(p2) / dashLen);
                var dx = (p2.x - p1.x) / dashes;
                var dy = (p2.y - p1.y) / dashes;
                context.moveTo(p1.x, p1.y);
                var x = p1.x,
                    y = p1.y;
                for (var i = 0; i < dashes; i++) {
                    x += dx;
                    y += dy;
                    if (i % 2 == 0) {
                        context.moveTo(x, y)
                    } else {
                        context.lineTo(x, y)
                    }
                }
                if (i % 2 == 0) {
                    context.moveTo(p2.x, p2.y)
                } else {
                    context.lineTo(p2.x, p2.y)
                }
            },
            drawHatchFrame: function(context, bounds, hatchBrush, size) {
                var scale = context._mf_scale;
                context.save();
                context.scale(1 / scale, 1 / scale);
                var pattern = context.createPattern(hatchBrush, "repeat");
                context.strokeStyle = pattern;
                context.lineWidth = scale * size / 2;
                context.strokeRect(scale * bounds.x, scale * bounds.y, scale * bounds.width, scale * bounds.height);
                context.restore()
            },
            drawRotationHandle: function(context, item) {
                var diagram = item.getParent();
                var mm = GraphicsUnit.getMillimeter(diagram.measureUnit);
                var bounds = item.getBounds();
                var tl = bounds.topLeft();
                var center = bounds.center();
                var point = new Point(center.x, tl.y - 6 * mm);
                var radius = 1.4 * item.getEffectiveHandlesSize() / 2;
                context.lineWidth = 1 / context._mf_scale;
                context.strokeStyle = "lightgray";
                context.beginPath();
                HandleUtils.drawDashedLine(context, point, bounds.topMiddle(), mm);
                context.stroke();
                context.fillStyle = mdiag.Utils.getBrush(context, diagram.handleBrush, diagram.getBounds());
                context.strokeStyle = "black";
                HandleUtils.drawCircle(context, point, radius)
            },
            getHandlePositions: function(bounds, mm) {
                var tl = bounds.topLeft();
                var br = bounds.bottomRight();
                var center = bounds.center();
                var positions = [];
                positions.push(tl);
                positions.push(bounds.topRight());
                positions.push(br);
                positions.push(bounds.bottomLeft());
                positions.push(new Point(center.x, tl.y));
                positions.push(new Point(br.x, center.y));
                positions.push(new Point(center.x, br.y));
                positions.push(new Point(tl.x, center.y));
                positions.push(center);
                positions.push(new Point(center.x, tl.y - 6 * mm));
                return positions
            },
            drawCircle: function(context, center, radius) {
                context.beginPath();
                context.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
                context.closePath();
                context.fill();
                context.stroke()
            },
            getHatchFill: function() {
                if (!HandleUtils.hatchFill) {
                    HandleUtils.hatchFill = HandleUtils.createPattern([1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1])
                }
                return HandleUtils.hatchFill
            },
            getPatternFill: function() {
                if (!HandleUtils.patternFill) {
                    HandleUtils.patternFill = HandleUtils.createPattern([1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1])
                }
                return HandleUtils.patternFill
            },
            createPattern: function(pixels) {
                var pattern = document.createElement("canvas");
                pattern.width = 8;
                pattern.height = 8;
                var context = pattern.getContext("2d");
                context.fillStyle = "rgb(255,255,255)";
                context.fillRect(0, 0, 8, 8);
                var whitePixel = context.createImageData(1, 1);
                var data = whitePixel.data;
                data[0] = 0;
                data[1] = 0;
                data[2] = 0;
                data[3] = 255;
                for (var y = 0; y < 8; y++) {
                    for (var x = 0; x < 8; x++) {
                        var i = 8 * y + x;
                        if (pixels[i]) {
                            context.putImageData(whitePixel, x, y)
                        }
                    }
                }
                return pattern
            },
            hatchFill: null,
            patternFill: null
        }
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Set = MindFusion.Collections.Set;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var LayoutUtils = mdiag.LayoutUtils = {
            arrange: function(layout, layoutCtr, animation) {
                var graph = layoutCtr.toGraph(layout.requiresSimpleGraph, layout.keepGroupLayout, layout.requiresHierarchyInfo);
                graph.layoutArea = layoutCtr.getBounds();
                if (layout.requiresHierarchyInfo) {
                    LayoutUtils.collectHierarchyInfo(graph)
                }
                var components = layout.requiresConnectedGraph ? graph.getConnectedComponents() : [graph];
                var dx = layout.margins + layoutCtr.bounds.x;
                var dy = layout.margins + layoutCtr.bounds.y;
                if (layoutCtr.captionHeight !== undefined) {
                    dy += layoutCtr.captionHeight
                }
                ArrayList.forEach(components, function(component) {
                    var MultipleGraphsPlacement = MindFusion.Graphs.MultipleGraphsPlacement;
                    var info = LayoutUtils.prepareLayout(component);
                    if (layout.arrange(component) === $skipLayout) {
                        return
                    }
                    var componentSize = animation != undefined ? LayoutUtils.applyAnimatedLayout(component, layout, dx, dy, info, layoutCtr, animation, graph) : LayoutUtils.applyLayout(component, layout, dx, dy, info, layoutCtr);
                    if (layout.multipleGraphsPlacement == MultipleGraphsPlacement.Horizontal) {
                        dx += componentSize.width + layout.margins
                    } else {
                        dy += componentSize.height + layout.margins
                    }
                });
                if (!animation) {
                    LayoutUtils.completeLayout(graph)
                }
            },
            completeLayout: function(graph) {
                graph.$selfLoops.forEach(function(edge) {
                    edge.setLoopShape()
                });
                graph.$repeatingLinks.forEach(function(link, links) {
                    links.forEach(function(r) {
                        r.shape = link.shape;
                        r.resetLink()
                    })
                })
            },
            prepareLayout: function(graph) {
                var anchoring = new Dictionary();
                graph.edges.forEach(function(e) {
                    var link = e.owner;
                    if (link) {
                        var originAnchor = link.getOriginAnchor();
                        var destinationAnchor = link.getDestinationAnchor();
                        anchoring.set(link, {
                            originAnchor: originAnchor,
                            destinationAnchor: destinationAnchor
                        })
                    }
                });
                return {
                    anchoring: anchoring
                }
            },
            applyAnimatedLayout: function(graph, layout, dx, dy, info, layoutCtr, animationOptions, completeGraph) {
                var bounds = LayoutUtils.getGraphBounds(graph, layoutCtr.bounds);
                var animations = [];
                graph.vertices.forEach(function(v) {
                    var options = {
                        animationType: animationOptions.animationType,
                        duration: animationOptions.duration,
                        easingType: animationOptions.easingType
                    };
                    if (v.owner) {
                        if (layout.keepGroupLayout) {
                            var ddx = v.x - v.width / 2;
                            var ddy = v.y - v.height / 2;
                            if (!(layout.isStatic && layout.isStatic())) {
                                var b = v.owner.bounds;
                                options.fromValue = new Point(b.x, b.y);
                                options.toValue = new Point(ddx + dx - bounds.x, ddy + dy - bounds.y);
                                if (options.fromValue.x != options.toValue.x || options.fromValue.y != options.toValue.y) {
                                    animations.push(new MindFusion.Animations.Animation(v, options, function(a, progress) {
                                        var item = a.item.owner;
                                        var fromValue = a.getFromValue();
                                        var toValue = a.getToValue();
                                        item.move(fromValue.x + (toValue.x - fromValue.x) * progress, fromValue.y + (toValue.y - fromValue.y) * progress, true, true)
                                    }))
                                }
                            } else {
                                var b = v.owner.bounds;
                                options.fromValue = new Point(b.x, b.y);
                                options.toValue = new Point(ddx, ddy);
                                if (options.fromValue.x != options.toValue.x || options.fromValue.y != options.toValue.y) {
                                    animations.push(new MindFusion.Animations.Animation(v, options, function(a, progress) {
                                        var item = a.item.owner;
                                        var fromValue = a.getFromValue();
                                        var toValue = a.getToValue();
                                        item.move(fromValue.x + (toValue.x - fromValue.x) * progress, fromValue.y + (toValue.y - fromValue.y) * progress, true, true)
                                    }))
                                }
                            }
                        } else {
                            var updateChildren = layout.requiresHierarchyInfo ? false : true;
                            var master = v.owner.getMasterNode();
                            if (!(layout.isStatic && layout.isStatic())) {
                                var b = v.owner.bounds;
                                options.fromValue = new Point(b.x + b.width / 2 - (dx - bounds.x), b.y + b.height / 2 - (dy - bounds.y));
                                options.toValue = new Point(v.x, v.y);
                                if (options.fromValue.x != options.toValue.x || options.fromValue.y != options.toValue.y || (master != null && LayoutUtils.shouldMoveWithMaster(graph.vertices, master, new Point(master.bounds.x + master.bounds.width / 2 - (dx - bounds.x), master.bounds.y + master.bounds.height / 2 - (dy - bounds.y))))) {
                                    animations.push(new MindFusion.Animations.Animation(v.owner, options, function(a, progress) {
                                        var item = a.item;
                                        var fromValue = a.getFromValue();
                                        var toValue = a.getToValue();
                                        v.x = fromValue.x + (toValue.x - fromValue.x) * progress;
                                        v.y = fromValue.y + (toValue.y - fromValue.y) * progress;
                                        item.setCenterAndSize(v, dx - bounds.x, dy - bounds.y, true, updateChildren)
                                    }))
                                }
                            } else {
                                var b = v.owner.bounds;
                                options.fromValue = new Point(b.x + b.width / 2, b.y + b.height / 2);
                                options.toValue = new Point(v.x, v.y);
                                if (options.fromValue.x != options.toValue.x || options.fromValue.y != options.toValue.y || (master != null && LayoutUtils.shouldMoveWithMaster(graph.vertices, master, new Point(master.bounds.x + master.bounds.width / 2, master.bounds.y + master.bounds.height / 2)))) {
                                    animations.push(new MindFusion.Animations.Animation(v, options, function(a, progress) {
                                        var item = a.item.owner;
                                        var g = a.item;
                                        var fromValue = a.getFromValue();
                                        var toValue = a.getToValue();
                                        v.x = fromValue.x + (toValue.x - fromValue.x) * progress;
                                        v.y = fromValue.y + (toValue.y - fromValue.y) * progress;
                                        item.setCenterAndSize(g, 0, 0, true, updateChildren)
                                    }))
                                }
                            }
                        }
                    }
                });
                var animationsRunning = animations.length;
                ArrayList.forEach(animations, function(a) {
                    a.addEventListener("animationComplete", function(s, e) {
                        animationsRunning--;
                        if (animationsRunning == 0) {
                            if (!layout.setsLinkPoints) {
                                LayoutUtils.resetLinks(layoutCtr.links)
                            } else {
                                graph.edges.forEach(function(e) {
                                    var link = e.owner;
                                    if (link) {
                                        if (layout.requiresCascadingLinks && layout.requiresCascadingLinks()) {
                                            link.setShape(mdiag.LinkShape.Cascading)
                                        }
                                        if (!(layout.isStatic && layout.isStatic())) {
                                            link.copyPoints(e.points, dx - bounds.x, dy - bounds.y, !layout.setsLinkEndPoints)
                                        } else {
                                            link.copyPoints(e.points, 0, 0, !layout.setsLinkEndPoints)
                                        }
                                        if (layout.setsLinkEndPoints) {
                                            link.updateFromPoints()
                                        }
                                        link.fixRowConnections()
                                    }
                                })
                            }
                            graph.edges.forEach(function(e) {
                                var link = e.owner;
                                if (link) {
                                    if (layout.anchoring == MindFusion.Graphs.Anchoring.Reassign) {
                                        var oanchor = link.origin.getNearestAnchor(link.points[0], link, false);
                                        var danchor = link.destination.getNearestAnchor(link.points[link.points.length - 1], link, true);
                                        link.setOriginAnchor(oanchor.index);
                                        link.setDestinationAnchor(danchor.index)
                                    } else {
                                        if (layout.anchoring == MindFusion.Graphs.Anchoring.Keep) {
                                            if (info && info.anchoring) {
                                                var anchoringInfo = info.anchoring.get(link);
                                                if (anchoringInfo) {
                                                    if (anchoringInfo.originAnchor || anchoringInfo.originAnchor === 0) {
                                                        link.setOriginAnchor(anchoringInfo.originAnchor)
                                                    }
                                                    if (anchoringInfo.destinationAnchor || anchoringInfo.destinationAnchor === 0) {
                                                        link.setDestinationAnchor(anchoringInfo.destinationAnchor)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                            LayoutUtils.completeLayout(completeGraph);
                            if (layoutCtr.arrangeAnimatedComplete) {
                                layoutCtr.arrangeAnimatedComplete(layout)
                            }
                            if (layoutCtr.raiseAnimatedLayoutCompleted) {
                                layoutCtr.raiseAnimatedLayoutCompleted()
                            } else {
                                if (layoutCtr.parent && layoutCtr.parent.raiseAnimatedLayoutCompleted) {
                                    layoutCtr.parent.raiseAnimatedLayoutCompleted(layoutCtr)
                                }
                            }
                        }
                    });
                    window.setTimeout(function() {
                        a.start()
                    }, 10)
                });
                return bounds
            },
            shouldMoveWithMaster: function(vertices, master, oldPos) {
                var vmaster = null;
                vertices.forEach(function(v) {
                    if (v.owner == master) {
                        vmaster = v
                    }
                });
                return vmaster != null && (oldPos.x != vmaster.x || oldPos.y != vmaster.y)
            },
            applyLayout: function(graph, layout, dx, dy, info, layoutCtr) {
                var bounds = LayoutUtils.getGraphBounds(graph, layoutCtr.bounds);
                graph.vertices.forEach(function(v) {
                    if (v.owner) {
                        if (layout.keepGroupLayout) {
                            var ddx = v.x - v.width / 2;
                            var ddy = v.y - v.height / 2;
                            if (!(layout.isStatic && layout.isStatic())) {
                                v.owner.move(ddx + dx - bounds.x, ddy + dy - bounds.y, true, true)
                            } else {
                                v.owner.move(ddx, ddy, true, true)
                            }
                        } else {
                            var updateChildren = layout.requiresHierarchyInfo ? false : true;
                            if (!(layout.isStatic && layout.isStatic())) {
                                v.owner.setCenterAndSize(v, dx - bounds.x, dy - bounds.y, true, updateChildren)
                            } else {
                                v.owner.setCenterAndSize(v, 0, 0, true, updateChildren)
                            }
                        }
                    }
                });
                if (!layout.setsLinkPoints) {
                    LayoutUtils.resetLinks(layoutCtr.links)
                } else {
                    graph.edges.forEach(function(e) {
                        var link = e.owner;
                        if (link) {
                            if (layout.requiresCascadingLinks && layout.requiresCascadingLinks()) {
                                link.setShape(mdiag.LinkShape.Cascading)
                            }
                            if (!(layout.isStatic && layout.isStatic())) {
                                link.copyPoints(e.points, dx - bounds.x, dy - bounds.y, !layout.setsLinkEndPoints)
                            } else {
                                link.copyPoints(e.points, 0, 0, !layout.setsLinkEndPoints)
                            }
                            if (layout.setsLinkEndPoints) {
                                link.updateFromPoints()
                            }
                            link.fixRowConnections()
                        }
                    })
                }
                graph.edges.forEach(function(e) {
                    var link = e.owner;
                    if (link) {
                        if (layout.anchoring == MindFusion.Graphs.Anchoring.Reassign) {
                            var oanchor = link.origin.getNearestAnchor(link.points[0], link, false);
                            var danchor = link.destination.getNearestAnchor(link.points[link.points.length - 1], link, true);
                            link.setOriginAnchor(oanchor.index);
                            link.setDestinationAnchor(danchor.index)
                        } else {
                            if (layout.anchoring == MindFusion.Graphs.Anchoring.Keep) {
                                if (info && info.anchoring) {
                                    var anchoringInfo = info.anchoring.get(link);
                                    if (anchoringInfo) {
                                        if (anchoringInfo.originAnchor || anchoringInfo.originAnchor === 0) {
                                            link.setOriginAnchor(anchoringInfo.originAnchor)
                                        }
                                        if (anchoringInfo.destinationAnchor || anchoringInfo.destinationAnchor === 0) {
                                            link.setDestinationAnchor(anchoringInfo.destinationAnchor)
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                return bounds
            },
            toGraph: function(simple, keepGroups, hierarchy, nodes, links, container) {
                var graph = new MindFusion.Graphs.Graph();
                var selfLoops = graph.$selfLoops = new ArrayList();
                var repeatingLinks = graph.$repeatingLinks = new Dictionary();
                if (hierarchy) {
                    nodes.forEach(function(node) {
                        var vertex = graph.createVertex(node.getBounds(), node);
                        vertex.debugId = node.getText();
                        vertex.weight = node.getWeight();
                        node.vertex = vertex
                    });
                    return graph
                }
                var topNodes = new Dictionary();
                var nodeMap = new Dictionary();
                mdiag.LayoutUtils.buildNodeMap(nodes, topNodes, nodeMap, keepGroups, container);
                topNodes.forEach(function(master) {
                    var bounds = LayoutUtils.getUnionBounds(topNodes.get(master));
                    var vertex = graph.createVertex(bounds, master);
                    vertex.debugId = master.getText();
                    vertex.weight = master.getWeight();
                    master.vertex = vertex
                });
                ArrayList.forEach(links, function(link) {
                    if (link.isFrozen()) {
                        return
                    }
                    if (!nodeMap.contains(link.origin)) {
                        return
                    }
                    if (!nodeMap.contains(link.destination)) {
                        return
                    }
                    var linkOrigin = nodeMap.get(link.origin);
                    var linkDestination = nodeMap.get(link.destination);
                    if (simple) {
                        if (link.origin == link.destination) {
                            selfLoops.push(link)
                        }
                        if (linkOrigin == linkDestination) {
                            return
                        }
                    }
                    var commonEdge;
                    if (simple && (commonEdge = linkOrigin.vertex.getCommonEdge(linkDestination.vertex)) != null) {
                        if (!repeatingLinks.contains(commonEdge.owner)) {
                            repeatingLinks.set(commonEdge.owner, new ArrayList())
                        }
                        repeatingLinks.get(commonEdge.owner).push(link);
                        return
                    }
                    if (link.origin != link.destination && linkOrigin == linkDestination) {
                        return
                    }
                    var edge = graph.createEdge(linkOrigin.vertex, linkDestination.vertex, link)
                });
                return graph
            },
            getAbsoluteNodeMaster: function(node, includeGroups, container) {
                var temp = node;
                var tempMaster = temp.getLayoutMaster(includeGroups);
                var visited = new ArrayList();
                visited.push(temp);
                while (tempMaster != null && tempMaster != container) {
                    temp = tempMaster;
                    if (visited.contains(temp)) {
                        var ignored = false;
                        ArrayList.forEach(visited, function(n) {
                            if (n.isFrozen()) {
                                ignored = true;
                                return $break
                            }
                        });
                        if (ignored) {
                            throw new Error("Layouts that preserve grouping cannot operate on diagrams with cyclic groups which contain or have related to them nodes that are ignored.")
                        }
                        return node
                    }
                    visited.push(temp);
                    tempMaster = temp.getLayoutMaster(includeGroups)
                }
                return temp
            },
            collectGroup: function(node, group, visited, includeGroups) {
                group.add(node);
                visited.push(node);
                if (includeGroups) {
                    ArrayList.forEach(node.getAttachedNodes(), function(sub) {
                        if (sub.isFrozen()) {
                            return
                        }
                        LayoutUtils.collectGroup(sub, group, visited, includeGroups)
                    })
                }
                if (node.children) {
                    ArrayList.forEach(node.children, function(sub) {
                        if (sub.isFrozen()) {
                            return
                        }
                        LayoutUtils.collectGroup(sub, group, visited, includeGroups)
                    })
                }
            },
            buildNodeMap: function(nodes, topNodes, nodeMap, keepGroups, container) {
                var visited = new ArrayList();
                ArrayList.forEach(nodes, function(node) {
                    if (visited.contains(node)) {
                        return
                    }
                    var master = LayoutUtils.getAbsoluteNodeMaster(node, keepGroups, container);
                    if (master.isFrozen()) {
                        return
                    }
                    var group = new Set();
                    LayoutUtils.collectGroup(master, group, visited, keepGroups);
                    topNodes.set(master, group);
                    group.forEach(function(n) {
                        nodeMap.set(n, master)
                    })
                })
            },
            getUnionBounds: function(nodes) {
                if (nodes.getCount() == 0) {
                    return Rect.empty
                }
                var bounds = null;
                nodes.forEach(function(node) {
                    bounds = node.bounds.union(bounds)
                });
                return bounds
            },
            resetLinks: function(links) {
                ArrayList.forEach(links, function(link) {
                    link.resetLink()
                })
            },
            getGraphBounds: function(graph, defaultBounds) {
                if (graph.vertices.length == 0) {
                    return defaultBounds
                }
                var bounds = null;
                graph.vertices.forEach(function(v) {
                    bounds = Rect.fromVertex(v).union(bounds)
                });
                return bounds
            },
            collectHierarchyInfo: function(graph) {
                graph.vertices.forEach(function(v) {
                    var owner = v.owner;
                    if (mflayer.isInstanceOfType(mdiag.ContainerNode, owner)) {
                        v.headerSize = owner.getCaptionHeight()
                    }
                    var masterNode = owner.getLayoutMaster(true);
                    if (masterNode) {
                        var master = masterNode.vertex;
                        v.master = master;
                        if (master.subordinates == null) {
                            master.subordinates = []
                        }
                        master.subordinates.push(v)
                    }
                })
            }
        }
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var Thickness = MindFusion.Drawing.Thickness;
        var Text = MindFusion.Drawing.Text;
        var RelativeToLink = MindFusion.Diagramming.RelativeToLink;
        var LinkLabel = mdiag.LinkLabel = function(link, text) {
            this.link = link;
            this.text = new MindFusion.Drawing.Text(text || "", new Rect(0, 0, 1, 1));
            this.text.baseline = "top";
            this.text.padding = new Thickness(0, 0, 0, 0);
            this.horizontalAlign = mdiag.Alignment.Center;
            this.verticalAlign = mdiag.Alignment.Far;
            this.relativeTo = RelativeToLink.LinkLength;
            this.index = 0;
            this.horizontalOffset = 0.5;
            this.verticalOffset = 0;
            this.margin = new Thickness(2, 2, 2, 2);
            this.enableWrap = false;
            this.maxWidth = Number.MAX_VALUE;
            this.cachedLayoutRect = Rect.empty;
            this.autoArrange = false
        };
        LinkLabel.prototype = {
            fromJson: function(json) {
                this.text = new MindFusion.Drawing.Text(json.text || "", new Rect(0, 0, 1, 1));
                this.text.baseline = "top";
                this.text.padding = new Thickness(0, 0, 0, 0);
                this.relativeTo = json.relativeTo;
                this.index = json.index;
                this.horizontalOffset = json.horizontalOffset;
                this.verticalOffset = json.verticalOffset;
                if (typeof json.margin == "number") {
                    this.margin = new Thickness(json.margin, json.margin, json.margin, json.margin)
                } else {
                    this.margin = Thickness.copy(json.margin)
                }
                this.horizontalAlign = json.horizontalAlign;
                this.verticalAlign = json.verticalAlign;
                this.enableWrap = json.enableWrap;
                if (json.maxWidth) {
                    this.maxWidth = json.maxWidth
                }
                if (json.font) {
                    this.setFont(Font.copy(json.font))
                }
                if (json.textColor) {
                    this.setTextColor(json.textColor)
                }
                this.setAutoArrange(json.autoArrange);
                if (json.brush != undefined) {
                    this.setBrush(json.brush)
                }
            },
            toJson: function() {
                var json = {
                    text: this.text.text,
                    relativeTo: this.relativeTo,
                    index: this.index,
                    horizontalOffset: this.horizontalOffset,
                    verticalOffset: this.verticalOffset,
                    margin: this.margin,
                    horizontalAlign: this.horizontalAlign,
                    verticalAlign: this.verticalAlign,
                    enableWrap: this.enableWrap,
                    maxWidth: this.maxWidth == Number.MAX_VALUE ? undefined : this.maxWidth,
                    autoArrange: this.autoArrange,
                    font: this.font,
                    textColor: this.textColor,
                    brush: this.brush
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                xmlElement.setAttribute("Version", "2");
                context.writeString(this.getText(), "Text", xmlElement);
                context.writeInt(this.relativeTo, "RelativeTo", xmlElement);
                context.writeInt(this.index, "Index", xmlElement);
                context.writeFloat(this.horizontalOffset, "HorizontalOffset", xmlElement);
                context.writeFloat(this.verticalOffset, "VerticalOffset", xmlElement);
                context.writeThickness(this.margin, "Margin", xmlElement);
                context.writeInt(this.horizontalAlign, "HorizontalAlign", xmlElement);
                context.writeInt(this.verticalAlign, "VerticalAlign", xmlElement);
                context.writeBool(this.enableWrap, "EnableWrap", xmlElement);
                context.writeFloat(this.maxWidth, "MaxWidth", xmlElement);
                context.writeBrush(this.textColor, "TextBrush", xmlElement);
                context.writeBrush(this.brush, "Brush", xmlElement);
                context.writeFont(this.font, "Font", xmlElement);
                context.writeBool(this.autoArrange, "AutoArrange", xmlElement)
            },
            loadFromXml: function(xmlElement, context) {
                this.setText(context.readString("Text", xmlElement));
                this.relativeTo = context.readInt("RelativeTo", xmlElement);
                this.index = context.readInt("Index", xmlElement);
                this.horizontalOffset = context.readFloat("HorizontalOffset", xmlElement);
                this.verticalOffset = context.readFloat("VerticalOffset", xmlElement);
                this.margin = context.readThickness("Margin", xmlElement);
                this.horizontalAlign = context.readInt("HorizontalAlign", xmlElement);
                this.verticalAlign = context.readInt("VerticalAlign", xmlElement);
                this.enableWrap = context.readBool("EnableWrap", xmlElement);
                this.maxWidth = context.readFloat("MaxWidth", xmlElement);
                this.textColor = context.readBrush("TextBrush", xmlElement);
                this.brush = context.readBrush("Brush", xmlElement);
                this.font = context.readFont("Font", xmlElement);
                this.autoArrange = context.readBool("AutoArrange", xmlElement)
            },
            clone: function() {
                var copy = new this.constructor(this.link);
                copy.text = this.text.clone();
                copy.relativeTo = this.relativeTo;
                copy.index = this.index;
                copy.horizontalOffset = this.horizontalOffset;
                copy.verticalOffset = this.verticalOffset;
                copy.margin = Thickness.copy(this.margin);
                copy.horizontalAlign = this.horizontalAlign;
                copy.verticalAlign = this.verticalAlign;
                copy.enableWrap = this.enableWrap;
                copy.maxWidth = this.maxWidth;
                copy.autoArrange = this.autoArrange;
                copy.font = (this.font) ? Font.copy(this.font) : undefined, copy.brush = this.brush;
                copy.textColor = this.textColor;
                return copy
            },
            setSegmentPosition: function(segment, dx, dy) {
                this.relativeTo = RelativeToLink.Segment;
                this.index = segment;
                this.horizontalOffset = dx;
                this.verticalOffset = dy;
                this.invalidate()
            },
            setControlPointPosition: function(controlPoint, dx, dy) {
                this.relativeTo = RelativeToLink.ControlPoint;
                this.index = controlPoint;
                this.horizontalOffset = dx;
                this.verticalOffset = dy;
                this.invalidate()
            },
            setLinkLengthPosition: function(lengthFactor) {
                this.relativeTo = RelativeToLink.LinkLength;
                this.horizontalOffset = lengthFactor;
                this.invalidate()
            },
            getLayoutRect: function() {
                if (this.cachedLayoutRect != Rect.empty) {
                    return this.cachedLayoutRect
                }
                var pivot = this.getPivotPoint();
                var font = (this.font != undefined) ? this.font : this.link.getEffectiveFont();
                var size = this.link.parent.measureString(this.text.text, font, new Rect(0, 0, Number.MAX_VALUE, 1));
                if (this.enableWrap && this.maxWidth != Number.MAX_VALUE) {
                    size = this.link.parent.measureString(this.text.text, font, new Rect(0, 0, this.maxWidth, size.height));
                    size.width = Text.getMinWidth(this.text.text, this.text.font, this.link.parent.context, this.link.parent.scale);
                    this.text.fitInBounds = true
                }
                var match = /\r|\n/.exec(this.text.text);
                if (match) {
                    this.text.fitInBounds = true
                }
                var x = 0;
                switch (this.horizontalAlign) {
                    case mdiag.Alignment.Near:
                        x = pivot.x + this.margin.left;
                        break;
                    case mdiag.Alignment.Center:
                        x = pivot.x - size.width / 2;
                        break;
                    case mdiag.Alignment.Far:
                        x = pivot.x - size.width - this.margin.right;
                        break
                }
                var y = 0;
                switch (this.verticalAlign) {
                    case mdiag.Alignment.Near:
                        y = pivot.y + this.margin.top;
                        break;
                    case mdiag.Alignment.Center:
                        y = pivot.y - size.height / 2;
                        break;
                    case mdiag.Alignment.Far:
                        y = pivot.y - size.height - this.margin.bottom;
                        break
                }
                this.cachedLayoutRect = new Rect(x, y, size.width, size.height);
                this.text.setBounds(this.cachedLayoutRect, 0);
                return this.cachedLayoutRect
            },
            getPivotPoint: function() {
                switch (this.relativeTo) {
                    case RelativeToLink.Segment:
                        var segment = this.index;
                        if (segment < 0) {
                            segment = Math.max(0, this.link.getSegmentCount() + segment)
                        } else {
                            segment = Math.min(segment, this.link.getSegmentCount() - 1)
                        }
                        var points = this.link.segmentToPolyline(segment);
                        var p = this.pointAlongLength(0.5, points);
                        return new Point(p.x + this.horizontalOffset, p.y + this.verticalOffset);
                    case RelativeToLink.ControlPoint:
                        var point = this.index;
                        if (point < 0) {
                            point = Math.max(0, this.link.points.length + point)
                        } else {
                            point = Math.min(point, this.link.points.length - 1)
                        }
                        var p = this.link.points[point];
                        return new Point(p.x + this.horizontalOffset, p.y + this.verticalOffset);
                    case RelativeToLink.LinkLength:
                        return this.pointAlongLength(this.horizontalOffset);
                    default:
                        return new Point()
                }
            },
            pointAlongLength: function(lengthFactor, segments) {
                if (segments == undefined) {
                    segments = this.link.getPolyLine(20)
                }
                var lengthPos = lengthFactor * this.getLength(segments);
                var totalLength = 0;
                for (var i = 0; i < segments.length - 1; ++i) {
                    var point1 = segments[i];
                    var point2 = segments[i + 1];
                    var segmentLength = point1.distance(point2);
                    if (totalLength + segmentLength > lengthPos) {
                        var normalX = (point2.x - point1.x) / segmentLength;
                        var normalY = (point2.y - point1.y) / segmentLength;
                        var pointOffset = lengthPos - totalLength;
                        return new Point(point1.x + normalX * pointOffset, point1.y + normalY * pointOffset)
                    }
                    totalLength += segmentLength
                }
                return segments[0]
            },
            getLength: function(segments) {
                var total = 0;
                for (var i = 0; i < segments.length - 1; ++i) {
                    var point1 = segments[i];
                    var point2 = segments[i + 1];
                    total += point1.distance(point2)
                }
                return total
            },
            invalidateLayout: function() {
                this.cachedLayoutRect = Rect.empty
            },
            invalidate: function() {
                if (this.link && this.link.parent && this.link.parent.labelsAutoArrange) {
                    this.link.parent.invalidateLabelLayout()
                } else {
                    this.cachedLayoutRect = Rect.empty
                }
            },
            updateRect: function(center) {
                this.cachedLayoutRect.setLocation(new Point(center.x - this.cachedLayoutRect.width / 2, center.y - this.cachedLayoutRect.height / 2));
                this.text.setBounds(this.cachedLayoutRect, 0);
                return this.cachedLayoutRect
            },
            getTextToEdit: function() {
                return this.text.text
            },
            getEditRect: function() {
                return this.getLayoutRect()
            },
            setEditedText: function(newText) {
                this.setText(newText)
            },
            getDiagramItem: function() {
                return this.link
            },
            getAutoArrange: function() {
                return this.autoArrange
            },
            setAutoArrange: function(value) {
                if (this.autoArrange != value) {
                    this.autoArrange = value;
                    if (this.autoArrange == true) {
                        this.link.parent.labelsAutoArrange = true
                    }
                    this.invalidate()
                }
            },
            setTextColor: function(value) {
                this.textColor = value;
                this.text.pen = value;
                this.invalidate()
            },
            getTextColor: function() {
                return this.textColor
            },
            setFont: function(value) {
                this.font = value;
                this.text.font = value;
                this.invalidate()
            },
            getFont: function() {
                return this.font
            },
            setText: function(value) {
                if (this.text.text != value) {
                    this.text.text = value;
                    this.invalidate()
                }
            },
            getText: function() {
                return this.text.text
            },
            setHorizontalAlign: function(value) {
                if (this.horizontalAlign != value) {
                    this.horizontalAlign = value;
                    this.invalidate()
                }
            },
            getHorizontalAlign: function() {
                return this.horizontalAlign
            },
            setVerticalAlign: function(value) {
                if (this.verticalAlign != value) {
                    this.verticalAlign = value;
                    this.invalidate()
                }
            },
            getVerticalAlign: function() {
                return this.verticalAlign
            },
            setMargin: function(value) {
                if (this.margin != value) {
                    this.margin = value;
                    this.invalidate()
                }
            },
            getMargin: function() {
                return this.margin
            },
            setBrush: function(value) {
                if (this.brush !== value) {
                    this.brush = value;
                    if (this.link && this.link.parent) {
                        this.link.parent.invalidate()
                    }
                }
            },
            getBrush: function() {
                return this.brush
            }
        };
        MindFusion.registerClass(LinkLabel, "MindFusion.Diagramming.LinkLabel")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var LinkNodesBehavior = mdiag.LinkNodesBehavior = function(parent, nodeConstructor, linkConstructor) {
            mflayer.initializeBase(LinkNodesBehavior, this, [parent]);
            this.nodeConstructor = nodeConstructor;
            this.linkConstructor = linkConstructor || function(diagram, origin, destination) {
                return new mdiag.DiagramLink(diagram, origin, destination)
            }
        };
        LinkNodesBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                var handleAtPoint = this.diagram.selection.handleAtPoint(point);
                if (handleAtPoint) {
                    return this.setModfCursor(point, handleAtPoint)
                }
                var adjustmentHandle = this.diagram.getHandleAt(point);
                if (adjustmentHandle) {
                    return this.setModfCursor(point, adjustmentHandle)
                }
                var node = this.diagram.getNodeAt(point, true, true);
                if (node != null && node.acceptLinks(true)) {
                    return this.setCurrentCursor(MouseCursors.Pointer)
                }
                return this.setCurrentCursor(MouseCursors.Default)
            },
            createNode: function() {
                return this.nodeConstructor(this.diagram)
            },
            createLink: function(origin, point) {
                var link = this.linkConstructor(this.diagram, origin, point);
                link.originConnection.chooseBestAnchorPoint(point);
                return link
            },
            createController: function(state) {
                var controller = mflayer.callBaseMethod(LinkNodesBehavior, this, "createController", [state]);
                if (controller) {
                    return controller
                }
                var handle = null;
                var originNode = this.diagram.getNodeAt(state.pointerPosition, true, true);
                if (originNode != null && originNode.acceptLinks(true)) {
                    var link = this.createLink(originNode, state.pointerPosition);
                    handle = {
                        item: link,
                        index: link.points.length - 1
                    };
                    controller = new mdiag.CreateLinkController(this.diagram, link)
                } else {
                    var w = this.diagram.getAlignToGrid() ? this.diagram.getGridSizeX() : 1;
                    var h = this.diagram.getAlignToGrid() ? this.diagram.getGridSizeY() : 1;
                    var node = this.createNode();
                    var alignedPoint = this.diagram.alignResize(node, state.pointerPosition, mdiag.AdjustmentHandles.ResizeTopLeft);
                    node.setBounds(new MindFusion.Drawing.Rect(alignedPoint.x, alignedPoint.y, w, h));
                    handle = {
                        item: node,
                        index: 2
                    };
                    controller = new mdiag.CreateNodeController(this.diagram, node);
                    controller.convertToShape = this.convertToShape
                }
                return controller
            }
        };
        MindFusion.registerClass(LinkNodesBehavior, "MindFusion.Diagramming.LinkNodesBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Matrix = MindFusion.Drawing.Matrix;
        var ArrayList = MindFusion.Collections.ArrayList;
        var LinkTextRenderer = mdiag.LinkTextRenderer = function(link) {
            mflayer.initializeBase(LinkTextRenderer, this);
            this.type = this.constructor.__typeName;
            this.link = link;
            this.clearLayout();
            this.transform = new Matrix();
            this.textAlignment = mdiag.Alignment.Near;
            this.lineAlignment = mdiag.Alignment.Near
        };
        LinkTextRenderer.prototype = {
            getType: function() {
                return this.type
            },
            clone: function() {
                var copy = new LinkTextRenderer(this.link);
                copy.transform = this.transform.clone();
                copy.textAlignment = this.textAlignment;
                copy.lineAlignment = this.lineAlignment;
                return copy
            },
            processText: function(context, stringCallback) {
                var Utils = MindFusion.Diagramming.Utils;
                var scale = this.ignoreTransform ? 1 : context._mf_scale;
                context.font = this.font.toString(scale);
                context.fillStyle = this.pen;
                if (this.stroke) {
                    context.strokeStyle = Utils.getBrush(context, this.stroke, this.bounds, true)
                }
                context.textAlign = "left";
                context.textBaseline = "top";
                for (var i = 0; i < this.strings.length; ++i) {
                    var textChunk = this.strings[i];
                    if (textChunk.length == 0) {
                        continue
                    }
                    var stringDrawn = false;
                    var angle = this.angles[i];
                    var textRect = this.rectangles[i].clone();
                    if (!this.ignoreTransform) {
                        if (context._mf_transform) {
                            textRect = context._mf_transform.transformRect(textRect)
                        }
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.lineWidth = context.lineWidth * scale
                    }
                    if (angle && angle !== 0) {
                        var matrix = new Matrix();
                        matrix.translate(textRect.x, textRect.y);
                        matrix.rotate(angle);
                        matrix.translate(-textRect.x, -textRect.y);
                        context.transform.apply(context, matrix.matrix())
                    }
                    if (this.link.textStyle == mdiag.LinkTextStyle.OverLongestSegment) {
                        var parent = this.link.parent;
                        context.fillStyle = parent ? Utils.getBrush(context, parent.getEffectiveBackBrush(), textRect) : "white";
                        var size = textRect.getSize();
                        size.width += GraphicsUnit.getMillimeter(parent.measureUnit);
                        size.height += GraphicsUnit.getMillimeter(parent.measureUnit);
                        if (this.textAlignment == mdiag.Alignment.Center) {
                            context.fillRect(textRect.x - size.width / 2, textRect.y, size.width, size.height);
                            context.fillStyle = this.pen;
                            stringCallback(textChunk, textRect.x - size.width / 2, textRect.y, context, scale, angle)
                        } else {
                            context.fillRect(textRect.x, textRect.y, textRect.width, textRect.height);
                            context.fillStyle = this.pen;
                            stringCallback(textChunk, textRect.x, textRect.y, context, scale, angle)
                        }
                    } else {
                        stringCallback(textChunk, textRect.x, textRect.y, context, scale, angle)
                    }
                }
            },
            draw: function(context) {
                context.save();
                this.processText(context, this.drawText.bind(this));
                context.restore()
            },
            drawText: function(text, x, y, context, scale) {
                var lines = text.split("\n");
                var maxLines = lines.length;
                var lineHeight = this.font.size * scale;
                for (var i = 0; i < maxLines; i++) {
                    if (lines[i]) {
                        var lineY = y + lineHeight * i;
                        if (this.stroke) {
                            context.strokeText(lines[i], x, lineY)
                        }
                        context.fillText(lines[i], x, lineY);
                        if (this.font.underline) {
                            lineY += lineHeight * 1.05;
                            var measure = context.measureText(lines[i]);
                            var drawUnderline = MindFusion.Drawing.Text.prototype.drawUnderline;
                            drawUnderline.call(this, context, x, lineY, measure.width)
                        }
                    }
                }
            },
            clearLayout: function() {
                this.rectangles = new ArrayList();
                this.angles = new ArrayList();
                this.strings = new ArrayList()
            },
            createSvgElement: function(svgdoc) {
                var element = svgdoc.createElementNS("http://www.w3.org/2000/svg", "g");
                var context = {
                    transform: function() {},
                    setTransform: function() {},
                    fillRect: function() {}
                };
                var fontSize = this.font.size;
                this.processText(context, function(text, x, y, context, scale, angle) {
                    var textElement = svgdoc.createElementNS("http://www.w3.org/2000/svg", "text");
                    textElement.setAttribute("stroke", "none");
                    textElement.setAttribute("fill", this.pen);
                    textElement.setAttribute("style", "font: " + context.font);
                    textElement.setAttribute("x", x);
                    textElement.setAttribute("y", y + fontSize);
                    textElement.setAttribute("transform", "rotate(" + angle + " " + x + " " + y + ")");
                    textElement.textContent = text;
                    element.appendChild(textElement)
                });
                return element
            }
        };
        MindFusion.registerClass(LinkTextRenderer, "MindFusion.Diagramming.LinkTextRenderer")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MagnifyBehavior = mdiag.MagnifyBehavior = function(parent, nodeConstructor) {
            mflayer.initializeBase(MagnifyBehavior, this, [parent])
        };
        MagnifyBehavior.prototype = {
            onMouseDown: function(e) {
                this.diagram.invalidate()
            },
            onMouseMove: function(e) {
                this.diagram.invalidate()
            },
            onMouseUp: function(e) {
                this.diagram.invalidate()
            },
            createController: function(state) {
                return new mdiag.MagnifyController(this.diagram)
            }
        };
        MindFusion.registerClass(MagnifyBehavior, "MindFusion.Diagramming.MagnifyBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ModifierKeyActions = MindFusion.Diagramming.ModifierKeyActions;
        var ModifierKeyActions = mdiag.ModifierKeyActions = function(parent, nodeConstructor) {
            mflayer.initializeBase(ModifierKeyActions, this);
            this.control = mdiag.ModifierKeyAction.Select;
            this.shift = mdiag.ModifierKeyAction.OverrideBehavior;
            this.alt = mdiag.ModifierKeyAction.Pan
        };
        ModifierKeyActions.prototype = {
            getControl: function() {
                return this.control
            },
            setControl: function(value) {
                this.control = value
            },
            getShift: function() {
                return this.shift
            },
            setShift: function(value) {
                this.shift = value
            },
            getAlt: function() {
                return this.alt
            },
            setAlt: function(value) {
                this.alt = value
            },
            getKeys: function(action, e) {
                if ((this.control == action) && (e.ctrlKey)) {
                    return true
                }
                if ((this.shift == action) && (e.shiftKey)) {
                    return true
                }
                if ((this.alt == action) && (e.altKey)) {
                    return true
                }
                return false
            }
        };
        MindFusion.registerClass(ModifierKeyActions, "MindFusion.Diagramming.ModifierKeyActions")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var ModifyBehavior = mdiag.ModifyBehavior = function(parent) {
            mflayer.initializeBase(ModifyBehavior, this, [parent])
        };
        ModifyBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                var handleAtPoint = this.diagram.selection.handleAtPoint(point);
                if (handleAtPoint) {
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, handleAtPoint.item) && handleAtPoint.index < 8) {
                        return this.setCurrentCursor(this.getResizeCursor(handleAtPoint.index))
                    } else {
                        return this.setCurrentCursor(MouseCursors.Move)
                    }
                }
                var adjustmentHandle = this.diagram.getHandleAt(point);
                if (adjustmentHandle) {
                    return this.setModfCursor(point, adjustmentHandle)
                }
                return this.setCurrentCursor(MouseCursors.Default)
            },
            createController: function(state) {
                var controller = mflayer.callBaseMethod(ModifyBehavior, this, "createController", [state]);
                if (controller) {
                    return controller
                }
                return new mdiag.CreateSelectionController(this.diagram.selection)
            }
        };
        MindFusion.registerClass(ModifyBehavior, "MindFusion.Diagramming.ModifyBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Rect = MindFusion.Drawing.Rect;
        var Size = MindFusion.Drawing.Size;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Font = MindFusion.Drawing.Font;
        var Point = MindFusion.Drawing.Point;
        var NodeListView = mdiag.NodeListView = function(element) {
            mflayer.initializeBase(NodeListView, this, [element]);
            this.bounds = new Rect(0, 0, element.width, element.height);
            this.measureUnit = MindFusion.Drawing.GraphicsUnit.Pixel;
            this.enabled = true;
            this.items = [];
            this.boxes = [];
            this.captions = [];
            this.padding = 5;
            this.iconSize = new Size(24, 24);
            this.defaultNodeSize = new Size(24, 24);
            this.captionFont = new MindFusion.Drawing.Font("sans-serif", 12);
            this.defaultShape = "Rectangle";
            this.preventDefaultTouch = true;
            this.eventHandlers = mflayer.eventHandlerList();
            this.orientation = mdiag.Orientation.Vertical;
            this.shapeLibraryLocation = "";
            this.updateLayoutDelegate = mflayer.createDelegate(this, this.updateLayout)
        };
        NodeListView.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(NodeListView, this, "initialize");
                var canvasElement = this.get_element();
                mflayer.addHandlers(canvasElement, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                this.mouseMoveDelegate = mflayer.createDelegate(this, this.onMouseMove);
                mflayer.addHandlers(document, {
                    mousemove: this.mouseMoveDelegate
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                });
                canvasElement.addEventListener("touchstart", mflayer.createDelegate(this, this.onTouchStart), false);
                canvasElement.addEventListener("touchmove", mflayer.createDelegate(this, this.onTouchMove), false);
                canvasElement.addEventListener("touchend", mflayer.createDelegate(this, this.onTouchEnd), false);
                canvasElement.addEventListener("touchcancel", mflayer.createDelegate(this, this.onTouchEnd), false);
                this.raiseEvent(mdiag.Events.controlLoaded)
            },
            dispose: function() {
                mflayer.removeHandler(document, "mousemove", this.mouseMoveDelegate);
                mflayer.removeHandler(document, "mouseup", this.mouseUpDelegate);
                mflayer.callBaseMethod(NodeListView, this, "dispose")
            },
            registerForSubmit: function(id) {
                var field = document.getElementById(id);
                if (field) {
                    var form = field.form;
                    if (form) {
                        form.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: id
                        })))
                    }
                }
            },
            preparePostback: function(sender, args) {
                var field = document.getElementById(args.id);
                if (field) {
                    field.value = mdiag.Utils.escapeHtml(this.toJson())
                }
            },
            fromJson: function(json) {
                this.clearAll();
                if (json > "") {
                    var obj = mflayer.fromJson(json);
                    if (!this.json && obj.shapeLibraryLocation != null && obj.shapeLibraryLocation != "") {
                        this.setShapeLibraryLocation(obj.shapeLibraryLocation);
                        this.json = json;
                        return
                    }
                    if (obj.iconSize != null) {
                        if (obj.iconSize.width == 0 && obj.iconSize.height == 0) {
                            this.iconSize = null
                        } else {
                            this.iconSize = obj.iconSize
                        }
                    }
                    if (obj.defaultNodeSize != null) {
                        if (obj.defaultNodeSize.width == 0 && obj.defaultNodeSize.height == 0) {
                            this.defaultNodeSize = null
                        } else {
                            this.defaultNodeSize = obj.defaultNodeSize
                        }
                    }
                    this.padding = obj.padding;
                    this.setEnabled(obj.enabled);
                    this.setMeasureUnit(obj.measureUnit);
                    if (obj.backColor !== undefined) {
                        this.setBackColor(obj.backColor)
                    }
                    if (obj.orientation !== undefined) {
                        this.setOrientation(obj.orientation)
                    }
                    this.prepareScriptEvent(mdiag.Events.controlLoaded, obj.controlLoadedScript);
                    this.prepareScriptEvent(mdiag.Events.nodeSelected, obj.nodeSelectedScript);
                    if (obj.items instanceof Object) {
                        for (var i = 0; i < obj.items.length; i++) {
                            if (obj.items[i]) {
                                var item = this.loadItem(obj.items[i], i);
                                var caption = "";
                                if (obj.captions instanceof Object) {
                                    caption = obj.captions[i] || ""
                                }
                                this.addNode(item, caption)
                            }
                        }
                    }
                }
                this.raiseEvent(mdiag.Events.controlLoaded);
                this.invalidate()
            },
            loadItem: function(obj, index) {
                var type = mflayer.parseType(obj.__type || obj.type);
                if (!type) {
                    return null
                }
                if (mflayer.inheritsFrom(type, mdiag.DiagramNode)) {
                    var node = new type(this);
                    node.fromJson(obj);
                    return node
                }
            },
            toJson: function() {
                var parentDiv = this.get_element().parentNode;
                var bounds = mflayer.getBounds(parentDiv);
                var json = {
                    id: this.get_element().id,
                    width: bounds.width,
                    height: bounds.height,
                    items: this.serializeItems(),
                    captions: this.serializeCaptions(),
                    iconSize: this.iconSize == null ? new Size(0, 0) : this.iconSize,
                    defaultNodeSize: this.defaultNodeSize == null ? new Size(0, 0) : this.defaultNodeSize,
                    enabled: this.enabled,
                    measureUnit: this.measureUnit,
                    padding: this.padding,
                    orientation: this.orientation
                };
                return mflayer.toJson(json)
            },
            serializeItems: function() {
                var result = [];
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var json = this.items[i].toJson();
                    result.push(json)
                }
                return result
            },
            serializeCaptions: function() {
                var result = [];
                for (var i = 0, l = this.captions.length; i < l; i++) {
                    var text = this.captions[i].text;
                    result.push(text)
                }
                return result
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler != null) {
                    handler(this, args)
                }
            },
            clearAll: function() {
                this.items = [];
                this.elements = [];
                this.captions = [];
                this.updateSize()
            },
            repaint: function() {
                this.get_element().width = this.get_element().width;
                this.context.save();
                var matrix = new MindFusion.Drawing.Matrix();
                matrix.scale(this.scale, this.scale);
                this.context._mf_transform = matrix;
                this.context.transform.apply(this.context, matrix.matrix());
                this.context.lineWidth = 1 / this.scale;
                this.context._mf_scale = this.scale;
                this.context._mf_minVisibleFontSize = this.minVisibleFontSize;
                for (var i = 0, l = this.elements.length; i < l; i++) {
                    this.elements[i].draw(this.context)
                }
                this.context.restore();
                if (this.repaintId) {
                    clearTimeout(this.repaintId);
                    this.repaintId = null
                }
            },
            updateCanvasSize: function() {
                var maxBreadth = 0;
                if (this.captions.length > 0) {
                    for (var i = 0, l = this.captions.length; i < l; i++) {
                        var breadth = this.brth(this.measureString(this.captions[i].text, this.captionFont));
                        maxBreadth = Math.max(maxBreadth, breadth)
                    }
                }
                var parentBreadth = this.brth(mflayer.getBounds(this.get_element().parentNode));
                var breadth = (this.brth(this.getItemsSize()) + maxBreadth + this.padding * 3) * this.scale;
                var newBrth = Math.max(breadth, parentBreadth) - 2;
                this.brth(this.get_element(), newBrth);
                for (var i = 0, l = this.boxes.length; i < l; i++) {
                    this.brth(this.boxes[i], newBrth)
                }
                this.updateSize()
            },
            invalidateLayout: function() {
                if (!this.updateLayoutId) {
                    this.updateLayoutId = setTimeout(this.updateLayoutDelegate, 20)
                }
            },
            updateLayout: function() {
                var prevSize = new Size(0, 0);
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var size = this.iconSize != null ? this.iconSize : this.items[i].getRotatedBounds().getSize();
                    this.items[i].removeCanvasElements();
                    this.removeElement(this.boxes[i]);
                    this.removeElement(this.items[i].text);
                    var b = Rect.fromPositionAndSize(this.listCoords(this.padding + (this.len(prevSize) + i * this.padding * 2), this.padding), size);
                    if (this.iconSize != null) {
                        this.items[i].setBounds(b)
                    } else {
                        this.items[i].getBounds().setLocation(b.topLeft())
                    }
                    var angle = this.items[i].getRotationAngle();
                    if (angle != 0) {
                        var ib = this.items[i].getBounds();
                        var rotated = MindFusion.Diagramming.Utils.rotateRect(ib, ib.center(), angle);
                        var dx = rotated.x - b.x;
                        var dy = rotated.y - b.y;
                        var newPos = new Point(b.x - dx, b.y - dy);
                        this.items[i].getBounds().setLocation(newPos)
                    }
                    var c = Rect.fromPositionAndSize(this.listCoords(this.padding + (this.len(prevSize) + i * this.padding * 2), this.brth(size) + this.padding * 2), this.listSize(this.len(size), this.brth(this.get_element()) - (this.brth(size) + this.padding)));
                    this.captions[i].setBounds(c);
                    var b = Rect.fromPositionAndSize(this.listCoords((this.len(prevSize) + i * this.padding * 2), 0), this.listSize(this.len(size) + this.padding * 2, this.brth(this.get_element())));
                    this.boxes[i].x = b.x;
                    this.boxes[i].y = b.y;
                    this.boxes[i].width = b.width;
                    this.boxes[i].height = b.height;
                    this.items[i].addCanvasElements();
                    this.addElement(this.boxes[i]);
                    this.addElement(this.items[i].text);
                    prevSize.width += size.width;
                    prevSize.height += size.height
                }
                this.updateCanvasSize();
                if (this.updateLayoutId) {
                    clearTimeout(this.updateLayoutId);
                    this.updateLayoutId = null
                }
            },
            updateSize: function() {
                var size = (this.iconSize != null) ? this.items.length * this.scale * (this.len(this.iconSize) + 2 * this.padding) : this.scale * (this.len(this.getItemsSize()) + this.items.length * 2 * this.padding);
                this.len(this.get_element(), size);
                this.invalidate()
            },
            getItemsSize: function() {
                var size = new Size(0, 0);
                for (var i = 0, l = this.items.length; i < l; i++) {
                    var bounds = this.items[i].getRotatedBounds();
                    size.height += bounds.height;
                    size.width += bounds.width
                }
                return size
            },
            addNode: function(node, caption) {
                if (node != undefined) {
                    ArrayList.add(this.items, node);
                    node.parent = this;
                    node.addCanvasElements();
                    var box = new Rect();
                    box.brush = {
                        type: "SolidBrush",
                        color: "transparent"
                    };
                    box.pen = "transparent";
                    this.boxes.push(box);
                    this.addElement(box);
                    var nodeCaption = node.text.clone();
                    nodeCaption.text = (caption != undefined) ? caption : "";
                    nodeCaption.font = this.captionFont;
                    if (this.orientation == mdiag.Orientation.Horizontal) {
                        nodeCaption.textAlignment = mdiag.Alignment.Center;
                        nodeCaption.lineAlignment = mdiag.Alignment.Near
                    } else {
                        nodeCaption.textAlignment = mdiag.Alignment.Near;
                        nodeCaption.lineAlignment = mdiag.Alignment.Center
                    }
                    nodeCaption.fitInBounds = true;
                    ArrayList.add(this.captions, nodeCaption);
                    this.addElement(nodeCaption);
                    this.invalidateLayout()
                }
            },
            listCoords: function(length, breadth) {
                return this.orientation == mdiag.Orientation.Horizontal ? {
                    x: length,
                    y: breadth
                } : {
                    x: breadth,
                    y: length
                }
            },
            listSize: function(length, breadth) {
                return this.orientation == mdiag.Orientation.Horizontal ? {
                    width: length,
                    height: breadth
                } : {
                    width: breadth,
                    height: length
                }
            },
            len: function(size, newValue) {
                if (newValue === undefined) {
                    return this.orientation == mdiag.Orientation.Horizontal ? size.width : size.height
                } else {
                    if (this.orientation == mdiag.Orientation.Horizontal) {
                        size.width = newValue
                    } else {
                        size.height = newValue
                    }
                }
            },
            brth: function(size, newValue) {
                if (newValue === undefined) {
                    return this.orientation == mdiag.Orientation.Horizontal ? size.height : size.width
                } else {
                    if (this.orientation == mdiag.Orientation.Horizontal) {
                        size.height = newValue
                    } else {
                        size.width = newValue
                    }
                }
            },
            getBoxAt: function(point) {
                for (var i = 0; i < this.boxes.length; i++) {
                    if (this.boxes[i].containsPoint(point)) {
                        return this.boxes[i]
                    }
                }
            },
            getNodeAt: function(point) {
                var box = this.getBoxAt(point);
                var index = ArrayList.indexOf(this.boxes, box);
                return this.items[index]
            },
            selectBox: function(box) {
                for (var i = 0, l = this.boxes.length; i < l; i++) {
                    if (this.boxes[i] === box) {
                        this.draggedNode = this.items[i].clone();
                        document.body.style.cursor = "pointer";
                        this.boxes[i].pen = "#3366CC";
                        this.boxes[i].brush = {
                            type: "SolidBrush",
                            color: "rgba(51,102,204,0.2)"
                        }
                    } else {
                        this.boxes[i].pen = "transparent";
                        this.boxes[i].brush = {
                            type: "SolidBrush",
                            color: "transparent"
                        }
                    }
                }
                this.invalidate()
            },
            selectItem: function(item) {
                var index = ArrayList.indexOf(this.items, item);
                var box = this.boxes[index];
                this.selectBox(box);
                this.raiseEvent(mdiag.Events.nodeSelected, new mdiag.NodeEventArgs({
                    node: item
                }))
            },
            getNodes: function() {
                return this.items
            },
            setDefaultNodeSize: function(value) {
                this.defaultNodeSize = value;
                this.invalidateLayout();
                this.invalidate()
            },
            getDefaultNodeSize: function() {
                return this.defaultNodeSize
            },
            setIconSize: function(value) {
                this.iconSize = value;
                this.invalidateLayout();
                this.invalidate()
            },
            getIconSize: function() {
                return this.iconSize
            },
            setOrientation: function(value) {
                this.orientation = value;
                this.invalidateLayout();
                if (this.orientation == mdiag.Orientation.Horizontal) {
                    this.get_element().parentNode.style.overflowX = "auto";
                    this.get_element().parentNode.style.overflowY = "hidden"
                } else {
                    this.get_element().parentNode.style.overflowX = "hidden";
                    this.get_element().parentNode.style.overflowY = "auto"
                }
                this.invalidate()
            },
            getOrientation: function() {
                return this.orientation
            },
            setPadding: function(value) {
                this.padding = value;
                this.invalidateLayout();
                this.invalidate()
            },
            getPadding: function() {
                return this.padding
            },
            getEffectiveBackBrush: function() {
                return this.backBrush
            },
            setEnabled: function(value) {
                this.enabled = value
            },
            getEnabled: function() {
                return this.enabled
            },
            getBackColor: function() {
                return this.backColor
            },
            setBackColor: function(value) {
                this.backColor = value;
                this.get_element().parentNode.style.backgroundColor = this.backColor
            },
            setShapeLibraryLocation: function(value) {
                if (this.shapeLibraryLocation != value) {
                    this.shapeLibraryLocation = value;
                    if (this.shapeLibraryLocation != null && this.shapeLibraryLocation != "") {
                        try {
                            mdiag.Shape.loadFromLibPending = true;
                            new mdiag.ShapeLibrary().loadFromXml(this.shapeLibraryLocation, mflayer.createDelegate(this, this.onShapeLibraryLoad), mflayer.createDelegate(this, this.onShapeLibraryError))
                        } catch (err) {
                            mdiag.Shape.loadFromLibPending = false;
                            throw err
                        }
                    } else {
                        mdiag.Shape.loadFromLibPending = false
                    }
                }
            },
            getShapeLibraryLocation: function() {
                return this.shapeLibraryLocation
            },
            onShapeLibraryLoad: function() {
                this.fromJson(this.json);
                delete this.json;
                mdiag.Shape.loadFromLibPending = false;
                this.invalidate()
            },
            onShapeLibraryLoaded: function(success) {
                mdiag.Shape.loadFromLibPending = false;
                ArrayList.forEach(this.items, function(item) {
                    if (item.onShapeLoaded) {
                        item.onShapeLoaded()
                    }
                })
            },
            onShapeLibraryError: function() {
                this.fromJson(this.json);
                delete this.json;
                mdiag.Shape.loadFromLibPending = false;
                this.invalidate()
            },
            onMouseDown: function(e) {
                if (!this.enabled) {
                    return
                }
                if (e.button === 0) {
                    this.onMouseLeftButtonDown(e)
                }
            },
            onMouseLeftButtonDown: function(e) {
                var cursor = MindFusion.Diagramming.Utils.getCursorPos(e, this.get_element());
                this.draggedNode = null;
                var box = this.getBoxAt(this.clientToDoc(cursor));
                if (box) {
                    this.selectBox(box);
                    var index = ArrayList.indexOf(this.boxes, box);
                    this.raiseEvent(mdiag.Events.nodeSelected, new mdiag.NodeEventArgs({
                        node: this.items[index]
                    }));
                    e.preventDefault()
                }
                this.invalidate()
            },
            targetAsDiagram: function(e) {
                if (e.target.nodeType === 1) {
                    if (e.target.id) {
                        var target = mflayer.findControl(e.target.id);
                        if (target != null) {
                            if (mflayer.isInstanceOfType(mdiag.Diagram, target)) {
                                return target
                            }
                        }
                    }
                }
                return null
            },
            onMouseMove: function(e) {
                if (!this.enabled) {
                    return
                }
                var cursor = MindFusion.Diagramming.Utils.getCursorPos(e, this.get_element());
                var point = this.clientToDoc(cursor);
                var node = this.draggedNode;
                if (node != null) {
                    var target = this.targetAsDiagram(e);
                    if (target != null) {
                        target.stopCursorChange = true;
                        var cursor = MindFusion.Diagramming.Utils.getCursorPos(e, target.get_element());
                        var point = target.clientToDoc(cursor);
                        if (!target.raiseCreating(node, {
                                currentPoint: point,
                                cancelNow: new Function()
                            }) || !target.onItemDragging(node, point)) {
                            target.get_element().style.cursor = "not-allowed"
                        } else {
                            target.get_element().style.cursor = "pointer"
                        }
                    }
                    document.body.style.cursor = "pointer";
                    var canvas = mflayer.findControl(this.get_element().id + "_shapeCanvas");
                    if (!canvas) {
                        canvas = this.addDragShape()
                    }
                    var pos = mdiag.Utils.getClientPos(e);
                    canvas.get_element().style.left = pos.x + 5 + "px";
                    canvas.get_element().style.top = pos.y - 20 + "px"
                } else {
                    document.body.style.cursor = "default";
                    this.removeDragShape()
                }
            },
            removeDragShape: function() {
                var canvas = mflayer.findControl(this.get_element().id + "_shapeCanvas");
                if (canvas) {
                    canvas.get_element().parentNode.removeChild(canvas.get_element());
                    canvas.dispose()
                }
            },
            addDragShape: function() {
                var bounds = new Rect(0, 0, 20, 20);
                var canvasElement = document.createElement("canvas");
                canvasElement.id = this.get_element().id + "_shapeCanvas";
                canvasElement.width = bounds.width;
                canvasElement.height = bounds.height;
                canvasElement.style.position = "absolute";
                canvasElement.style.zIndex = 9999;
                document.body.appendChild(canvasElement);
                var canvas = mflayer.createControl(MindFusion.Drawing.Canvas, null, null, null, canvasElement);
                canvas.scale = 1;
                canvas.repaint = this.repaint;
                canvas.setBounds(bounds);
                var node = this.draggedNode.clone();
                node.shadowColor = "transparent";
                node.parent = canvas;
                node.setBounds(bounds);
                node.addCanvasElements();
                canvas.repaint();
                return canvas
            },
            onMouseUp: function(e) {
                if (!this.enabled) {
                    return
                }
                if (e.button === 0) {
                    this.onMouseLeftButtonUp(e)
                }
            },
            onMouseLeftButtonUp: function(e) {
                if (this.draggedNode == null) {
                    return
                }
                var target = this.targetAsDiagram(e);
                if (target != null) {
                    var node = this.draggedNode;
                    this.scaleFont(node, target);
                    this.scaleStrokeThickness(node, target);
                    var size = this.defaultNodeSize;
                    if (size == null) {
                        size = node.getBounds().getSize()
                    }
                    var cursor = MindFusion.Diagramming.Utils.getCursorPos(e, target.get_element());
                    var point = target.clientToDoc(cursor);
                    if (target.onItemDragging(node, point) && target.raiseCreating(node, {
                            currentPoint: point,
                            cancelNow: new Function()
                        })) {
                        node.setBounds(Rect.fromCenterAndSize(point, size));
                        node.setParent(target);
                        if (node.expandButton) {
                            node.expandButton.updateContent();
                            node.expandButton.updateLocation()
                        }
                        if (node.scroller) {
                            node.scroller.updateContent();
                            node.scroller.updateLocation()
                        }
                        if (node.folder) {
                            node.folder.updateContent();
                            node.folder.updateLocation()
                        }
                        target.addItem(node);
                        target.raiseCreated(node);
                        target.onItemDropped(node, point);
                        target.invalidate()
                    }
                    target.get_element().style.cursor = "default"
                }
                document.body.style.cursor = "default";
                this.draggedNode = null;
                this.removeDragShape()
            },
            scaleFont: function(node, target) {
                if (node.font) {
                    if (node.font.size) {
                        var size = (node.font.size * GraphicsUnit.getPixel(target.measureUnit));
                        node.font.size = size
                    }
                } else {
                    if (node.style) {
                        if (node.style.fontSize) {
                            var size = (node.style.fontSize * GraphicsUnit.getPixel(target.measureUnit));
                            node.font = new Font(node.style.fontName || "sans-serif", size, false, false)
                        }
                    }
                }
            },
            scaleStrokeThickness: function(node, target) {
                if (node.style) {
                    if (node.style.strokeThickness) {
                        node.style.strokeThickness = GraphicsUnit.convert(node.style.strokeThickness, target.measureUnit, GraphicsUnit.Pixel)
                    }
                }
            },
            emulateMouse: function(e) {
                var parentDiv = this.get_element().parentNode;
                var bounds = mflayer.getBounds(parentDiv);
                var scrollX = window.pageXOffset;
                var scrollY = window.pageYOffset;
                var touches = e.touches;
                var me = {
                    button: 0,
                    clientX: touches[0].clientX - scrollX,
                    clientY: touches[0].clientY - scrollY
                };
                return me
            },
            onTouchStart: function(e) {
                var touches = e.touches;
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch = this.emulateMouse(e);
                    this.onMouseLeftButtonDown(this.lastTouch);
                    e.preventDefault()
                }
            },
            onTouchMove: function(e) {
                var touches = e.touches;
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch = this.emulateMouse(e);
                    this.onMouseMove(this.lastTouch);
                    e.preventDefault()
                }
            },
            onTouchEnd: function(e) {
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch.target = this.targetView;
                    this.onMouseLeftButtonUp(this.lastTouch);
                    this.lastTouch = new Date()
                }
            },
            setTargetView: function(diagramView) {
                this.targetView = diagramView
            },
            prepareScriptEvent: function(eventName, script) {
                if (!script || script == "") {
                    return
                }
                var fn = new Function("sender", "args", "return " + script + "(sender, args)");
                this.addEventListener(eventName, fn)
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            }
        };
        MindFusion.Diagramming.NodeListView.create = function(element) {
            return mflayer.createControl(MindFusion.Diagramming.NodeListView, null, null, null, element)
        };
        MindFusion.Diagramming.NodeListView.find = function(element, parent) {
            return mflayer.findControl(element, parent)
        };
        MindFusion.registerClass(NodeListView, "MindFusion.Diagramming.NodeListView", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Overview = mdiag.Overview = function(element) {
            mflayer.initializeBase(Overview, this, [element]);
            this.enabled = true;
            this.diagramId = "";
            this.backColor = "#FFFFFF";
            this.scaleFactor = 0.3;
            this.scaleMode = mdiag.ScaleMode.FitAll;
            this.allowZoom = false;
            this.zooming = false;
            this.nofitScaleFactor = 0.3;
            this.eventHandlers = mflayer.eventHandlerList();
            this.scrollZoneSize = 25;
            this.autoScrollAmount = 0
        };
        Overview.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(Overview, this, "initialize");
                this.mouseMoveDelegate = mflayer.createDelegate(this, this.onMouseMove);
                mflayer.addHandlers(document, {
                    mousemove: this.mouseMoveDelegate
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                });
                this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                mflayer.addHandlers(window, {
                    resize: this.resizeDelegate
                });
                mflayer.addHandlers(this.get_element(), {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                mflayer.addHandlers(this.get_element(), {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(this.get_element(), {
                    mouseup: mflayer.createDelegate(this, this.onMouseUp)
                })
            },
            dispose: function() {
                mflayer.removeHandler(document, "mousemove", this.mouseMoveDelegate);
                mflayer.removeHandler(document, "mouseup", this.mouseUpDelegate);
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(Overview, this, "dispose")
            },
            registerForSubmit: function(id) {
                var field = document.getElementById(id);
                if (field) {
                    var form = field.form;
                    if (form) {
                        form.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: id
                        })))
                    }
                }
            },
            setDiagram: function(diagram) {
                this.diagram = diagram;
                if (diagram) {
                    this.diagramId = diagram.get_element().id;
                    diagram.addEventListener(mdiag.Events.repaint, mflayer.createDelegate(this, this.onDiagramRepaint));
                    diagram.addEventListener(mdiag.Events.sizeChanged, mflayer.createDelegate(this, this.onResize));
                    this.init()
                }
            },
            preparePostback: function(sender, args) {
                var field = document.getElementById(args.id);
                if (field) {
                    field.value = this.toJson()
                }
            },
            fromJson: function(json) {
                if (json > "") {
                    var obj = mflayer.fromJson(json);
                    if (obj.diagramView) {
                        this.diagramId = obj.diagramView;
                        this.setDimColor(obj.dimColor);
                        this.setBackColor(obj.backColor);
                        this.setEnabled(obj.enabled);
                        this.prepareScriptEvent(mdiag.Events.controlLoaded, obj.controlLoadedScript);
                        var thisObj = this;
                        setTimeout(function() {
                            return thisObj.prepare()
                        }, 100)
                    }
                }
            },
            prepare: function() {
                this.setDiagram(mdiag.Diagram.find(this.diagramId));
                this.diagram.invalidate();
                this.invalidate()
            },
            toJson: function() {
                var parentDiv = this.get_element().parentNode;
                var bounds = mflayer.getBounds(parentDiv);
                var json = {
                    id: this.get_element().id,
                    width: bounds.width,
                    height: bounds.height,
                    enabled: this.enabled,
                    diagramView: this.diagramId,
                    dimColor: this.dimColor,
                    backColor: this.backColor
                };
                return mflayer.toJson(json)
            },
            getViewport: function() {
                var scrollDiv = this.get_element().parentNode;
                var point1 = new Point(scrollDiv.scrollLeft, scrollDiv.scrollTop);
                var point2 = new Point(scrollDiv.scrollLeft + scrollDiv.offsetWidth, scrollDiv.scrollTop + scrollDiv.offsetHeight);
                return Rect.fromPoints(point1, point2)
            },
            fit: function() {
                if (this.scaleMode != mdiag.ScaleMode.FitAll) {
                    return
                }
                if (this.diagram == null) {
                    return
                }
                var diagramBounds = mflayer.getBounds(this.diagram.sizeElement());
                diagramBounds.width = diagramBounds.width * 100 / this.diagram.zoomFactor;
                diagramBounds.height = diagramBounds.height * 100 / this.diagram.zoomFactor;
                var divSize = new MindFusion.Drawing.Size(this.get_element().parentNode.clientWidth, this.get_element().parentNode.clientHeight);
                this.scaleFactor = Math.min(divSize.width / diagramBounds.width, divSize.height / diagramBounds.height)
            },
            init: function() {
                if (this.diagram == null) {
                    return
                }
                var diagramView = document.getElementById(this.diagramId).parentNode;
                var viewBounds = mflayer.getBounds(diagramView);
                var diagramBounds = mflayer.getBounds(this.diagram.sizeElement());
                this.bounds = new MindFusion.Drawing.Rect(this.diagram.bounds.x, this.diagram.bounds.y, diagramBounds.width / this.diagram.scale, diagramBounds.height / this.diagram.scale);
                diagramBounds.width = diagramBounds.width * 100 / this.diagram.zoomFactor;
                diagramBounds.height = diagramBounds.height * 100 / this.diagram.zoomFactor;
                var divSize = new MindFusion.Drawing.Size(this.get_element().parentNode.clientWidth, this.get_element().parentNode.clientHeight);
                var canvasSize = this.shrinkToFit(diagramBounds.width, diagramBounds.height, divSize.width, divSize.height);
                var canvas = this.get_element();
                canvas.width = canvasSize.width;
                canvas.height = canvasSize.height;
                canvas.style.width = canvasSize.width + "px";
                canvas.style.height = canvasSize.height + "px";
                canvas.style.marginLeft = (divSize.width - canvasSize.width) / 2 + "px";
                canvas.style.marginTop = (divSize.height - canvasSize.height) / 2 + "px";
                this.fit();
                if (this.scaleMode != mdiag.ScaleMode.FitAll) {
                    this.recalculateCanvas()
                }
                var scrollbarWidth = diagramView.offsetHeight - diagramView.clientHeight;
                var trackerSize = {
                    width: (viewBounds.width - scrollbarWidth) / this.diagram.scale,
                    height: (viewBounds.height - scrollbarWidth) / this.diagram.scale
                };
                this.trackerRect = new MindFusion.Drawing.Rect(0, 0, trackerSize.width, trackerSize.height);
                this.trackerRect.brush = {
                    type: "SolidBrush",
                    color: "rgba(204,204,204,0.2)"
                };
                this.trackerRect.pen = "#000000";
                this.trackerRect.overview = this;
                this.resizerWidth = 12;
                this.resizerHeight = 12;
                mflayer.addHandlers(this.diagram.scrollElement(), {
                    scroll: mflayer.createDelegate(this, this.onScroll)
                });
                this.setTrackerPosition();
                this.onDiagramRepaint(this.diagram);
                this.raiseEvent(mdiag.Events.controlLoaded)
            },
            recalculateCanvas: function() {
                var diagramBounds = mflayer.getBounds(this.diagram.sizeElement());
                var canvas = this.get_element();
                canvas.width = diagramBounds.width * this.scaleFactor;
                canvas.height = diagramBounds.height * this.scaleFactor;
                if (this.scaleMode == mdiag.ScaleMode.FixedScale) {
                    canvas.width /= this.diagram.getZoomFactor() / 100;
                    canvas.height /= this.diagram.getZoomFactor() / 100
                }
                canvas.style.width = canvas.width + "px";
                canvas.style.height = canvas.height + "px";
                canvas.parentNode.style.overflow = "scroll";
                canvas.parentNode.style.overflowY = "scroll"
            },
            onDiagramRepaint: function(sender, args) {
                this.scale = 1 / MindFusion.Drawing.GraphicsUnit.getPixel(sender.measureUnit) * this.scaleFactor;
                if (this.scaleMode == mdiag.ScaleMode.CombinedScales) {
                    this.scale *= this.diagram.getZoomFactor() / 100
                }
                this.elements = this.cachedZOrder = ArrayList.clone(sender.getZOrder());
                if (this.trackerRect) {
                    this.elements.push(this.trackerRect)
                }
                if (this.trackerRect) {
                    this.trackerRect.draw = function(context, drawShadow) {
                        context.save();
                        context.transform.apply(context, this.transform.matrix());
                        context.beginPath();
                        context.rect(this.x, this.y, this.width, this.height);
                        context.save();
                        if (this.shadow && drawShadow != false) {
                            this.shadow.apply(context)
                        }
                        if (this.brush) {
                            context.fillStyle = MindFusion.Diagramming.Utils.getBrush(context, this.brush, this.getBounds());
                            context.fill()
                        }
                        context.restore();
                        if (this.pen) {
                            context.strokeStyle = this.pen;
                            context.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / context._mf_scale;
                            MindFusion.Drawing.DashStyle.apply(context, this.strokeDashStyle);
                            context.stroke()
                        }
                        var resizer = this.overview.getTrackerResizer();
                        if (this.pen && this.overview.allowZoom && this.overview.scaleMode != mdiag.ScaleMode.CombinedScales) {
                            var rx = resizer.x;
                            var ry = resizer.y;
                            var rw = resizer.width;
                            var rh = resizer.height;
                            context.moveTo(rx + rw, ry);
                            context.lineTo(rx, ry + rh);
                            context.moveTo(rx + rw, ry + rh / 3);
                            context.lineTo(rx + rw / 3, ry + rh);
                            context.moveTo(rx + rw, ry + 2 * rh / 3);
                            context.lineTo(rx + 2 * rw / 3, ry + rh);
                            context.stroke()
                        }
                        context.restore()
                    }
                }
                this.invalidate()
            },
            getTrackerResizer: function() {
                var rw = this.resizerWidth / this.scale;
                var rh = this.resizerHeight / this.scale;
                return new MindFusion.Drawing.Rect(this.trackerRect.right() - rw, this.trackerRect.bottom() - rh, rw, rh)
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler != null) {
                    handler(this, args)
                }
            },
            onMouseDown: function(e) {
                if (!this.enabled) {
                    return
                }
                var cursor = this.currentMousePoint = mdiag.Utils.getCursorPos(e, this.get_element());
                var point = this.clientToDoc(cursor);
                var thisObj = this;
                this.scrollTimeoutId = setInterval(function() {
                    thisObj.autoScrollIfNeeded()
                }, 100);
                var resizer = this.getTrackerResizer();
                if (this.allowZoom && resizer && resizer.containsPoint(point) && this.scaleMode != mdiag.ScaleMode.CombinedScales) {
                    this.resizeEnabled = true;
                    this.trackerW = this.trackerRect.width;
                    this.trackerH = this.trackerRect.height;
                    this.initialZoomFactor = this.diagram.getZoomFactor();
                    this.startX = point.x - resizer.x;
                    this.startY = point.y - resizer.y;
                    this.savedScrollX = this.diagram.getScrollX();
                    this.savedScrollY = this.diagram.getScrollY();
                    e.preventDefault()
                } else {
                    if (this.trackerRect && this.trackerRect.containsPoint(point)) {
                        this.startX = point.x - this.trackerRect.x;
                        this.startY = point.y - this.trackerRect.y;
                        this.startDrag = true;
                        e.preventDefault()
                    } else {
                        var x = Math.floor(point.x - this.trackerRect.width / 2);
                        var y = Math.floor(point.y - this.trackerRect.height / 2);
                        this.tryMoveTracker(x, y);
                        var scroll = this.scrollPosFromTracker();
                        if (this.diagram) {
                            this.diagram.scrollElement().scrollLeft = scroll.x;
                            this.diagram.scrollElement().scrollTop = scroll.y
                        }
                    }
                }
            },
            onMouseMove: function(e) {
                if (!this.enabled) {
                    return
                }
                this.changeCursor(e);
                this.currentMousePoint = mdiag.Utils.getCursorPos(e, this.get_element());
                if (this.allowZoom) {
                    var point = this.clientToDoc(this.currentMousePoint);
                    if (this.resizeEnabled) {
                        var dx = point.x - this.startX;
                        var dy = point.y - this.startY;
                        this.zooming = true;
                        this.tryMoveTrackerResizer(dx, dy);
                        this.invalidate();
                        this.zooming = false;
                        return false
                    }
                }
                this.moveTrackerRectIfExists()
            },
            moveTrackerRectIfExists: function() {
                if (this.trackerRect) {
                    if (this.startDrag) {
                        var point = this.clientToDoc(this.currentMousePoint);
                        this.tryMoveTracker(Math.floor(point.x - this.startX), Math.floor(point.y - this.startY));
                        var scroll = this.scrollPosFromTracker();
                        if (this.diagram) {
                            this.diagram.scrollElement().scrollLeft = scroll.x;
                            this.diagram.scrollElement().scrollTop = scroll.y
                        }
                        return false
                    }
                }
            },
            onMouseLeave: function(e) {
                if (!this.enabled) {
                    return
                }
                this.startDrag = false;
                this.resizeEnabled = false
            },
            autoScrollIfNeeded: function() {
                var viewport = this.getViewport();
                if (viewport.width > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, -this.scrollZoneSize, 0)
                }
                if (viewport.height > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, 0, -this.scrollZoneSize)
                }
                var scroll = !viewport.containsPoint(this.currentMousePoint);
                if (scroll) {
                    var scrollAmount = this.autoScrollAmount > 0 ? this.autoScrollAmount : 4;
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (this.currentMousePoint.x < viewport.left()) {
                        this.autoScrDX = -scrollAmount
                    }
                    if (this.currentMousePoint.y < viewport.top()) {
                        this.autoScrDY = -scrollAmount
                    }
                    if (this.currentMousePoint.x > viewport.right()) {
                        this.autoScrDX = scrollAmount
                    }
                    if (this.currentMousePoint.y > viewport.bottom()) {
                        this.autoScrDY = scrollAmount
                    }
                    this.onAutoScroll()
                }
            },
            onScroll: function(e) {
                if (!this.enabled) {
                    return
                }
                if (!this.startDrag && !this.resizeEnabled) {
                    this.setTrackerPosition()
                }
            },
            checkAutoScroll: function(point) {
                var viewport = this.getViewport();
                if (viewport.width > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, -this.scrollZoneSize, 0)
                }
                if (viewport.height > this.scrollZoneSize * 2) {
                    viewport = mdiag.Utils.inflate(viewport, 0, -this.scrollZoneSize)
                }
                var scroll = !viewport.containsPoint(point);
                if (scroll) {
                    var scrollAmount = this.autoScrollAmount > 0 ? this.autoScrollAmount : 4;
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (point.x < viewport.left()) {
                        this.autoScrDX = -scrollAmount
                    }
                    if (point.y < viewport.top()) {
                        this.autoScrDY = -scrollAmount
                    }
                    if (point.x > viewport.right()) {
                        this.autoScrDX = scrollAmount
                    }
                    if (point.y > viewport.bottom()) {
                        this.autoScrDY = scrollAmount
                    }
                    this.onAutoScroll();
                    if (!this.scrollTimeoutId) {
                        var thisObj = this;
                        this.scrollTimeoutId = setInterval(function() {
                            thisObj.onAutoScroll()
                        }, 100)
                    }
                } else {
                    if (this.scrollTimeoutId) {
                        this.stopAutoScroll();
                        this.invalidate()
                    }
                }
                return scroll
            },
            stopAutoScroll: function() {
                if (this.scrollTimeoutId) {
                    clearInterval(this.scrollTimeoutId);
                    delete this.scrollTimeoutId
                }
            },
            onAutoScroll: function() {
                var rcPage = this.getViewport();
                if (this.scroller) {
                    rcPage.width -= this.getScrollbarSize(0);
                    rcPage.height -= this.getScrollbarSize(1)
                }
                var scrX = this.getScrollX(),
                    scrY = this.getScrollY();
                if (rcPage.width < this.bounds.width) {
                    scrX += this.autoScrDX;
                    this.currentMousePoint.x += this.autoScrDX
                }
                if (rcPage.height < this.bounds.height) {
                    scrY += this.autoScrDY;
                    this.currentMousePoint.y += this.autoScrDY
                }
                this.scrollStayInDoc(scrX, scrY, rcPage, this.bounds);
                this.moveTrackerRectIfExists();
                this.invalidate()
            },
            scrollStayInDoc: function(scrX, scrY, rcPage, diagBounds) {
                if (!diagBounds) {
                    diagBounds = this.bounds
                }
                if (scrX < diagBounds.left()) {
                    scrX = diagBounds.left()
                }
                if (scrX > diagBounds.right() - rcPage.width) {
                    scrX = Math.max(diagBounds.right() - rcPage.width, diagBounds.left())
                }
                if (scrY < diagBounds.top()) {
                    scrY = diagBounds.top()
                }
                if (scrY > diagBounds.bottom() - rcPage.height) {
                    scrY = Math.max(diagBounds.bottom() - rcPage.height, diagBounds.top())
                }
                var dx = this.get_element().parentNode.scrollLeft - scrX;
                var dy = this.get_element().parentNode.scrollTop - scrY;
                this.get_element().parentNode.scrollLeft = scrX;
                this.get_element().parentNode.scrollTop = scrY;
                if (this.currentMousePoint) {
                    this.currentMousePoint.x -= dx;
                    this.currentMousePoint.y -= dy
                }
            },
            onMouseUp: function(e) {
                if (!this.enabled) {
                    return
                }
                this.startDrag = false;
                this.resizeEnabled = false;
                this.stopAutoScroll();
                this.changeCursor(e)
            },
            changeCursor: function(e) {
                if (this.allowZoom) {
                    var cursor = mdiag.Utils.getCursorPos(e, this.get_element());
                    var point = this.clientToDoc(cursor);
                    if (this.getTrackerResizer().containsPoint(point) || this.resizeEnabled) {
                        this.get_element().parentNode.style.cursor = "nwse-resize"
                    } else {
                        this.get_element().parentNode.style.cursor = "default"
                    }
                }
            },
            onResize: function(e) {
                if (!this.zooming) {
                    if (this.trackerRect) {
                        this.init();
                        this.invalidate()
                    }
                }
            },
            shrinkToFit: function(sourceWidth, sourceHeight, targetWidth, targetHeight) {
                var percent = 0;
                var percentW = 0;
                var percentH = 0;
                percentW = (targetWidth / sourceWidth);
                percentH = (targetHeight / sourceHeight);
                percent = (percentH < percentW) ? percentH : percentW;
                var destWidth = Math.floor(sourceWidth * percent);
                var destHeight = Math.floor(sourceHeight * percent);
                return new MindFusion.Drawing.Size(destWidth, destHeight)
            },
            setTrackerPosition: function() {
                if (!this.diagram) {
                    return
                }
                var scroller = this.diagram.scrollElement();
                var point = new MindFusion.Drawing.Point(scroller.scrollLeft / this.diagram.scale, scroller.scrollTop / this.diagram.scale);
                if (!isNaN(point.x) && !isNaN(point.y)) {
                    point.x += this.bounds.x;
                    point.y += this.bounds.y;
                    this.tryMoveTracker(Math.floor(point.x), Math.floor(point.y))
                }
            },
            tryMoveTracker: function(x, y) {
                this.trackerRect.x = Math.max(this.bounds.x, Math.min(x, this.bounds.width + this.bounds.x - this.trackerRect.width));
                this.trackerRect.y = Math.max(this.bounds.y, Math.min(y, this.bounds.height + this.bounds.y - this.trackerRect.height));
                this.invalidate()
            },
            tryMoveTrackerResizer: function(x, y) {
                var newX = Math.max(this.bounds.x, Math.min(x, this.bounds.width + this.bounds.x - this.resizerWidth));
                if (newX < this.trackerRect.x) {
                    newX = this.trackerRect.x
                }
                var newY = Math.max(this.bounds.y, Math.min(y, this.bounds.height + this.bounds.y - this.resizerHeight));
                if (newY < this.trackerRect.y) {
                    newY = this.trackerRect.y
                }
                var q = this.trackerW / this.trackerH;
                var x1 = this.trackerRect.x;
                var y1 = this.trackerRect.y;
                var x2 = this.trackerRect.x + this.trackerRect.width - this.resizerWidth;
                var y2 = this.trackerRect.y + this.trackerRect.height - this.resizerHeight;
                if (Math.abs(y1 - y2) < 0.01) {
                    y2 = y1 + 0.001
                }
                var a = (y1 - y2) / (x1 - x2);
                var b = y2 - a * x2;
                var minY = a * newX + b;
                var minX = (newY - b) / a;
                var h = minY + this.resizerHeight - this.trackerRect.y;
                var w = h * q;
                this.trackerRect.width = w;
                this.trackerRect.height = h;
                var coef = this.trackerW / w;
                this.diagram.setZoomFactorAndScroll(this.initialZoomFactor * coef, this.savedScrollX, this.savedScrollY);
                this.invalidate()
            },
            scrollPosFromTracker: function() {
                return new MindFusion.Drawing.Point((this.trackerRect.x - this.bounds.x) * this.diagram.scale, (this.trackerRect.y - this.bounds.y) * this.diagram.scale)
            },
            getEffectiveBackBrush: function() {
                if (this.diagram) {
                    return this.diagram.getEffectiveBackBrush != null ? this.diagram.getEffectiveBackBrush() : this.diagram.backBrush
                }
                return this.dimColor
            },
            getBackgroundImage: function() {
                if (this.diagram) {
                    return this.diagram.getBackgroundImage()
                }
                return null
            },
            getBackgroundImageSize: function() {
                if (this.diagram) {
                    if (this.diagram.backgroundImage) {
                        return new MindFusion.Drawing.Size(this.diagram.backgroundImage.width * this.scaleFactor * (this.scaleMode == mdiag.ScaleMode.CombinedScales ? this.diagram.getZoomFactor() / 100 : 1), this.diagram.backgroundImage.height * this.scaleFactor * (this.scaleMode == mdiag.ScaleMode.CombinedScales ? this.diagram.getZoomFactor() / 100 : 1))
                    }
                }
                return new MindFusion.Drawing.Size(0, 0)
            },
            getBackgroundImageAlign: function() {
                if (this.diagram) {
                    return this.diagram.getBackgroundImageAlign()
                }
                return MindFusion.Drawing.ImageAlign.Center
            },
            prepareScriptEvent: function(eventName, script) {
                if (!script || script == "") {
                    return
                }
                var fn = new Function("sender", "args", "return " + script + "(sender, args)");
                this.addEventListener(eventName, fn)
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            },
            getBackColor: function() {
                return this.backColor
            },
            setBackColor: function(value) {
                this.backColor = value;
                this.get_element().parentNode.style.backgroundColor = this.backColor
            },
            getDimColor: function() {
                return this.dimColor
            },
            setDimColor: function(value) {
                this.dimColor = value
            },
            setEnabled: function(value) {
                this.enabled = value
            },
            getEnabled: function() {
                return this.enabled
            },
            setScaleFactor: function(value) {
                var newScale = value / 100;
                if (newScale > 1) {
                    newScale = 1
                }
                if (newScale < 0.001) {
                    newScale = 0.001
                }
                if (this.scaleMode == mdiag.ScaleMode.FitAll) {
                    this.nofitScaleFactor = newScale
                } else {
                    this.scaleFactor = newScale;
                    this.recalculateCanvas();
                    this.invalidate()
                }
            },
            getScaleFactor: function() {
                return this.scaleFactor * 100
            },
            setScaleMode: function(value) {
                if (this.scaleMode == value) {
                    return
                }
                this.scaleMode = value;
                if (this.scaleMode == mdiag.ScaleMode.FitAll) {
                    this.nofitScaleFactor = this.scaleFactor;
                    this.fit()
                } else {
                    this.scaleFactor = this.nofitScaleFactor
                }
                this.invalidate()
            },
            getScaleMode: function() {
                return this.scaleMode
            },
            getAllowZoom: function() {
                return this.allowZoom
            },
            setAllowZoom: function(value) {
                if (this.allowZoom == value) {
                    return
                }
                this.allowZoom = value;
                this.invalidate()
            },
            getAutoScrollAmount: function() {
                return this.autoScrollAmount
            },
            setAutoScrollAmount: function(value) {
                if (this.autoScrollAmount != value) {
                    this.autoScrollAmount = value
                }
            },
            getScrollX: function() {
                return this.get_element().parentNode.scrollLeft
            },
            getScrollY: function() {
                return this.get_element().parentNode.scrollTop
            }
        };
        MindFusion.Diagramming.Overview.create = function(element) {
            return mflayer.createControl(MindFusion.Diagramming.Overview, null, null, null, element)
        };
        MindFusion.Diagramming.Overview.find = function(element, parent) {
            return mflayer.findControl(element, parent)
        };
        MindFusion.registerClass(Overview, "MindFusion.Diagramming.Overview", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var PanBehavior = mdiag.PanBehavior = function(parent, nodeConstructor) {
            mflayer.initializeBase(PanBehavior, this, [parent])
        };
        PanBehavior.prototype = {
            setMouseCursor: function(point, startInteraction) {
                this.currentCursor = MindFusion.Controls.MouseCursors.Pan;
                return this.currentCursor
            },
            createController: function(state) {
                return new mdiag.PanController(this.diagram)
            }
        };
        MindFusion.registerClass(PanBehavior, "MindFusion.Diagramming.PanBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var MouseCursors = MindFusion.Controls.MouseCursors;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var RowResizer = mdiag.RowResizer = function(node, rowIndex) {
            mflayer.initializeBase(RowResizer, this, [node]);
            this.rowIndex = rowIndex;
            this.row = this.node.getRow(this.rowIndex);
            this.startHeight = this.row.height
        };
        RowResizer.prototype = {
            hitTest: function(mousePosition) {
                return false
            },
            needsMouseMessages: function(mousePosition) {
                return true
            },
            setMouseCursor: function(mousePosition) {
                if (this.node.getRotationAngle() != 0) {
                    var a = this.node.getRotationAngle();
                    if (a >= -180 && a < -135) {
                        return MouseCursors.CounterDiagonalResize
                    } else {
                        if (a >= -135 && a < -90) {
                            return MouseCursors.HorizontalResize
                        } else {
                            if (a >= -90 && a < -45) {
                                return MouseCursors.DiagonalResize
                            } else {
                                if (a >= -45 && a < 0) {
                                    return MouseCursors.VerticalResize
                                } else {
                                    if (a >= 0 && a < 45) {
                                        return MouseCursors.CounterDiagonalResize
                                    } else {
                                        if (a >= 45 && a < 90) {
                                            return MouseCursors.HorizontalResize
                                        } else {
                                            if (a >= 90 && a < 135) {
                                                return MouseCursors.DiagonalResize
                                            } else {
                                                return MouseCursors.VerticalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return MouseCursors.VerticalResize
            },
            localPoint: function(point) {
                if (this.node.getRotationAngle() != 0) {
                    return mdiag.Utils.rotatePointAt(point, this.node.bounds.center(), -this.node.getRotationAngle())
                }
                return point.clone()
            },
            onMouseDown: function(mousePosition) {
                this.mouseDown = true;
                var localPoint = this.localPoint(mousePosition);
                this.current = this.last = localPoint.y
            },
            onMouseMove: function(mousePosition) {
                if (!this.mouseDown) {
                    return
                }
                var localPoint = this.localPoint(mousePosition);
                this.current = localPoint.y;
                var diagram = this.node.getParent();
                if (!this.resizing) {
                    if (Math.abs(this.current - this.last) >= GraphicsUnit.getMillimeter(diagram.measureUnit)) {
                        this.resizing = true;
                        if (diagram.getUndoEnabled()) {
                            this.cmd = new mdiag.ResizeTableRowCommand(diagram, this.node, this.row)
                        }
                    }
                }
                if (this.resizing) {
                    var oldHeight = this.row.height;
                    this.node.setRowHeight(this.rowIndex, Math.max(GraphicsUnit.getMillimeter(diagram.measureUnit), this.row.height + (this.current - this.last)));
                    var shouldCancel = {
                        value: undefined
                    };
                    if (!diagram.raiseTableRowResizing(this.node, this.rowIndex, mousePosition, 0, shouldCancel)) {
                        this.node.setRowHeight(this.rowIndex, oldHeight)
                    }
                    if (shouldCancel.value) {
                        this.cancel()
                    }
                    if (oldHeight != this.row.height) {
                        this.last = this.current
                    }
                }
            },
            onMouseUp: function(mousePosition) {
                if (this.resizing) {
                    var diagram = this.node.getParent();
                    if (diagram.getUndoEnabled()) {
                        diagram.undoManager.executeCommand(this.cmd)
                    }
                    diagram.raiseTableRowResized(this.node, this.rowIndex, mousePosition, 0)
                }
                this.mouseDown = false;
                this.resizing = false
            },
            cancel: function() {
                if (this.resizing) {
                    this.mouseDown = false;
                    this.resizing = false;
                    this.node.setRowHeight(this.rowIndex, this.startHeight);
                    this.cmd = null
                }
            }
        };
        MindFusion.registerClass(RowResizer, "MindFusion.Diagramming.RowResizer", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Path = MindFusion.Drawing.Path;
        var Text = MindFusion.Drawing.Text;
        var Utils = MindFusion.Diagramming.Utils;
        var Alignment = MindFusion.Diagramming.Alignment;
        var Orientation = MindFusion.Diagramming.Orientation;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var AlignStart = mdiag.AlignStart = {
            Decrease: 0,
            Increase: 1,
            Undetermined: 2
        };
        var Scale = mdiag.Scale = function(element, parent, orientation) {
            mflayer.initializeBase(Scale, this, [element]);
            this.parent = parent;
            this.orientation = orientation;
            this.unit = parent.unit;
            this.foreColor = parent.foreColor;
            this.backColor = parent.backColor;
            this.projectionColor = parent.projectionColor;
            this.enableGuides = parent.enableGuides;
            this.guideColor = parent.guideColor;
            this.textColor = parent.textColor;
            this.pointerColor = parent.pointerColor;
            this.aligning = false;
            this.alignedNodes = new MindFusion.Collections.Dictionary();
            this.repaintDelegate = mflayer.createDelegate(this, this.repaint);
            this.initialize()
        };
        Scale.prototype = {
            initialize: function() {
                var canvas = this.get_element();
                if (typeof canvas.getContext !== "undefined") {
                    this.canvas = canvas;
                    this.context = canvas.getContext("2d")
                }
                mflayer.addHandlers(canvas, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(canvas, {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                })
            },
            dispose: function() {},
            invalidate: function() {
                if (!this.repaintId) {
                    this.repaintId = setTimeout(this.repaintDelegate, 20)
                }
            },
            repaint: function() {
                if (!this.context) {
                    return
                }
                this.canvas.width = this.canvas.width;
                var bounds = mflayer.getBounds(this.get_element());
                this.context.strokeStyle = this.foreColor;
                this.context.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / this.context._mf_scale;
                this.context.fillStyle = this.backColor;
                this.context.rect(0, 0, bounds.width, bounds.height);
                this.context.fill();
                this.drawProjection(this.context);
                this.drawMarks(this.context);
                if (this.e != null) {
                    this.drawCursorProjection(this.e, this.context)
                }
                if (this.repaintId) {
                    clearTimeout(this.repaintId);
                    this.repaintId = null
                }
            },
            onMouseDown: function(e) {
                if (!this.enableGuides) {
                    return
                }
                if (e.button != 0) {
                    return
                }
                var diagram = this.parent.diagram;
                if (diagram == null) {
                    return
                }
                diagram.startTotalChange();
                this.aligning = true;
                this.alignedNodes = new MindFusion.Collections.Dictionary();
                if (this.get_element().setCapture) {
                    this.get_element().setCapture()
                }
                var cursor = mdiag.Utils.getCursorPos(e, diagram.get_element());
                this.ptInitial = diagram.clientToDoc(cursor);
                this.ptCurrent = this.ptInitial;
                this.align = AlignStart.Undetermined
            },
            onMouseMove: function(e) {
                this.e = e;
                if (this.aligning) {
                    var diagram = this.parent.diagram;
                    var cursor = mdiag.Utils.getCursorPos(e, diagram.get_element());
                    var ptDoc = diagram.clientToDoc(cursor);
                    if (this.align == AlignStart.Undetermined) {
                        if (this.orientation == Orientation.Horizontal) {
                            if (ptDoc.x < this.ptInitial.x) {
                                this.align = AlignStart.Decrease
                            } else {
                                if (ptDoc.x > this.ptInitial.x) {
                                    this.align = AlignStart.Increase
                                }
                            }
                        } else {
                            if (ptDoc.y < this.ptInitial.y) {
                                this.align = AlignStart.Decrease
                            } else {
                                if (ptDoc.y > this.ptInitial.y) {
                                    this.align = AlignStart.Increase
                                }
                            }
                        }
                        if (this.align == AlignStart.Undetermined) {
                            return
                        }
                    }
                    var items = diagram.getItems();
                    for (var i in items) {
                        var node = items[i];
                        if (node == null) {
                            continue
                        }
                        if (!mflayer.isInstanceOfType(mdiag.DiagramNode, node)) {
                            continue
                        }
                        if (!diagram.isItemVisible(node)) {
                            continue
                        }
                        if (node.getLocked()) {
                            continue
                        }
                        if (diagram.getSelection().items.length > 0 && !node.getSelected()) {
                            continue
                        }
                        var bounds = node.getBounds();
                        if (this.orientation == Orientation.Horizontal) {
                            if (this.align == AlignStart.Increase) {
                                if (bounds.x >= Math.min(ptDoc.x, this.ptCurrent.x) - this.getThresh() && bounds.x <= Math.max(ptDoc.x, this.ptCurrent.x) + this.getThresh() && !this.alignedNodes.contains(node)) {
                                    this.alignedNodes.set(node, Alignment.Near)
                                }
                            } else {
                                if (bounds.right() >= Math.min(ptDoc.x, this.ptCurrent.x) - this.getThresh() && bounds.right() <= Math.max(ptDoc.x, this.ptCurrent.x) + this.getThresh() && !this.alignedNodes.contains(node)) {
                                    this.alignedNodes.set(node, Alignment.Far)
                                }
                            }
                        } else {
                            if (this.align == AlignStart.Increase) {
                                if (bounds.y >= Math.min(ptDoc.y, this.ptCurrent.y) - this.getThresh() && bounds.y <= Math.max(ptDoc.y, this.ptCurrent.y) + this.getThresh() && !this.alignedNodes.contains(node)) {
                                    this.alignedNodes.set(node, Alignment.Near)
                                }
                            } else {
                                if (bounds.bottom() >= Math.min(ptDoc.y, this.ptCurrent.y) - this.getThresh() && bounds.bottom() <= Math.max(ptDoc.y, this.ptCurrent.y) + this.getThresh() && !this.alignedNodes.contains(node)) {
                                    this.alignedNodes.set(node, Alignment.Far)
                                }
                            }
                        }
                    }
                    this.alignedNodes.forEach(function(node) {
                        var alignment = this.alignedNodes.get(node);
                        var bounds = node.getBounds();
                        if (this.orientation == Orientation.Horizontal) {
                            if (alignment == Alignment.Near) {
                                bounds.x = ptDoc.x
                            } else {
                                bounds.x = ptDoc.x - bounds.width
                            }
                        } else {
                            if (alignment == Alignment.Near) {
                                bounds.y = ptDoc.y
                            } else {
                                bounds.y = ptDoc.y - bounds.height
                            }
                        }
                        node.setBounds(bounds, false)
                    }, this);
                    diagram.invalidate();
                    this.ptCurrent = ptDoc
                }
            },
            onMouseUp: function(e) {
                if (this.aligning) {
                    this.aligning = false;
                    this.parent.diagram.commitCompositeOperation();
                    this.parent.diagram.invalidate();
                    this.alignedNodes.forEach(function(node) {
                        node.setBounds(node.getBounds(), true)
                    })
                }
                if (document.releaseCapture) {
                    document.releaseCapture()
                }
            },
            onDiagramMouseMove: function(e) {
                this.e = e;
                this.invalidate()
            },
            onDiagramPaint: function() {
                if (!this.aligning) {
                    return
                }
                var diagram = this.parent.diagram;
                var cursor = mdiag.Utils.getCursorPos(this.e, diagram.get_element());
                var point = diagram.clientToDoc(cursor);
                var rect = diagram.getBounds();
                var context = diagram.context;
                context.strokeStyle = this.guideColor;
                context.beginPath();
                if (this.orientation == Orientation.Horizontal) {
                    context.moveTo(point.x, rect.y);
                    context.lineTo(point.x, rect.bottom())
                } else {
                    context.moveTo(rect.x, point.y);
                    context.lineTo(rect.right(), point.y)
                }
                context.stroke()
            },
            drawProjection: function(context) {
                var diagram = this.parent.diagram;
                if (diagram == null) {
                    return
                }
                if (diagram.getActiveItem() == null) {
                    return
                }
                var node = diagram.getActiveItem();
                if (!mflayer.isInstanceOfType(mdiag.DiagramNode, node)) {
                    return
                }
                var bounds = this.parent.getProjectRotatedBounds() ? node.getRotatedBounds() : node.getBounds();
                var client = mflayer.getBounds(this.get_element());
                client.x = client.y = 0;
                var lt = this.parent.diagram.docToClient(new Point(bounds.x, bounds.y));
                var rb = this.parent.diagram.docToClient(new Point(bounds.right(), bounds.bottom()));
                var scroll = this.parent.diagram.docToClient(new Point(this.parent.diagram.getScrollX(), this.parent.diagram.getScrollY()));
                lt.x -= scroll.x;
                lt.y -= scroll.y;
                rb.x -= scroll.x;
                rb.y -= scroll.y;
                this.context.fillStyle = this.projectionColor;
                if (this.orientation == Orientation.Horizontal) {
                    var rect = client;
                    rect.y += 1;
                    rect.height -= 2;
                    rect.x = lt.x;
                    rect.width = rb.x - lt.x + 1;
                    if (rect.x < client.x) {
                        rect.width -= (client.x - rect.x);
                        rect.x = client.x
                    }
                    if (rect.x + rect.width > client.right()) {
                        rect.width = client.right() - rect.x - 1
                    }
                    context.fillRect(rect.x, rect.y, rect.width, rect.height)
                } else {
                    var rect = client;
                    rect.x += 1;
                    rect.width -= 2;
                    rect.y = lt.y;
                    rect.height = rb.y - lt.y + 1;
                    if (rect.y < client.y) {
                        rect.height -= (client.y - rect.y);
                        rect.y = client.y
                    }
                    if (rect.y + rect.height > client.bottom()) {
                        rect.height = client.bottom() - rect.y - 1
                    }
                    context.fillRect(rect.x, rect.y, rect.width, rect.height)
                }
            },
            drawMarks: function(context) {
                var diagram = this.parent.diagram;
                if (diagram == null) {
                    return
                }
                var rect = mflayer.getBounds(this.get_element());
                rect.x = rect.y = 0;
                var pixelsPerUnit = this.calcPixelsPerUnit();
                var units = this.calcUnitInterval(pixelsPerUnit);
                var doc0InDevice;
                if (this.unit != GraphicsUnit.Percent) {
                    doc0InDevice = diagram.docToClient(new Point(0, 0))
                } else {
                    doc0InDevice = diagram.docToClient(diagram.bounds.location())
                }
                var scroll = diagram.docToClient(new Point(diagram.getScrollX(), diagram.getScrollY()));
                doc0InDevice.x -= scroll.x;
                doc0InDevice.y -= scroll.y;
                var fontHeight = (diagram.font) ? diagram.font.size : MindFusion.Drawing.Font.defaultFont.size;
                this.context.fillStyle = this.backColor;
                this.context.beginPath();
                if (this.orientation == Orientation.Horizontal) {
                    var x = doc0InDevice.x;
                    var steps = 0;
                    if (x <= rect.x) {
                        while (x < rect.x) {
                            x += units * pixelsPerUnit;
                            steps++
                        }
                        x -= units * pixelsPerUnit;
                        steps--
                    } else {
                        if (x > rect.x) {
                            while (x > rect.x) {
                                x -= units * pixelsPerUnit;
                                steps--
                            }
                        }
                    }
                    var sign = this.parent.getNegatedX() ? -1 : 1;
                    while (x < rect.right()) {
                        var num = sign * steps * units;
                        context.moveTo(x, rect.top() + 1);
                        context.lineTo(x, rect.top() + rect.height);
                        context.stroke();
                        context.strokeStyle = this.textColor;
                        context.strokeText(num, x + 1, rect.height / 2 + 1);
                        context.strokeStyle = this.foreColor;
                        var sub = GraphicsUnit.getStandardDivisions(this.unit);
                        if (units * pixelsPerUnit > 100) {
                            sub *= 2
                        } else {
                            if (units * pixelsPerUnit <= 40) {
                                sub /= 2
                            }
                        }
                        var dist = units * pixelsPerUnit / sub;
                        for (var i = 1; i < sub; i++) {
                            var f = (sub % 2 == 0 && i == sub / 2) ? 3 : 0;
                            context.moveTo(x + i * dist, rect.x + fontHeight + rect.height / 2 - f);
                            context.lineTo(x + i * dist, rect.bottom() - 1);
                            context.stroke()
                        }
                        x += units * pixelsPerUnit;
                        steps++
                    }
                } else {
                    var y = doc0InDevice.y;
                    var steps = 0;
                    if (y <= rect.y) {
                        while (y < rect.y) {
                            y += units * pixelsPerUnit;
                            steps++
                        }
                        y -= units * pixelsPerUnit;
                        steps--
                    } else {
                        if (y > rect.y) {
                            while (y > rect.y) {
                                y -= units * pixelsPerUnit;
                                steps--
                            }
                        }
                    }
                    var sign = this.parent.getNegatedY() ? -1 : 1;
                    while (y < rect.bottom() + pixelsPerUnit * units) {
                        var num = sign * steps * units;
                        context.moveTo(rect.x + 1, y);
                        context.lineTo(rect.x + rect.width - 2, y);
                        context.stroke();
                        context.save();
                        context.translate(rect.width / 2 - fontHeight, y + 1);
                        context.rotate(90 * Math.PI / 180);
                        context.strokeStyle = this.textColor;
                        context.strokeText(num, fontHeight / 2, 0);
                        context.strokeStyle = this.foreColor;
                        context.restore();
                        var sub = GraphicsUnit.getStandardDivisions(this.unit);
                        if (units * pixelsPerUnit > 100) {
                            sub *= 2
                        } else {
                            if (units * pixelsPerUnit <= 40) {
                                sub /= 2
                            }
                        }
                        var dist = units * pixelsPerUnit / sub;
                        for (var i = 1; i < sub; i++) {
                            var f = (sub % 2 == 0 && i == sub / 2) ? 3 : 0;
                            context.moveTo(rect.x + fontHeight + rect.width / 2 - f, y + i * dist);
                            context.lineTo(rect.right() - 1, y + i * dist);
                            context.stroke()
                        }
                        y += units * pixelsPerUnit;
                        steps++
                    }
                }
            },
            drawCursorProjection: function(e, context) {
                var diagram = this.parent.diagram;
                if (diagram == null) {
                    return
                }
                var rect = mflayer.getBounds(this.get_element());
                rect.x = rect.y = 0;
                var cursor = mdiag.Utils.getCursorPos(e, diagram.get_element());
                var point = diagram.clientToDoc(cursor);
                var point = diagram.docToClient(point);
                var scroll = diagram.docToClient(new Point(diagram.getScrollX(), diagram.getScrollY()));
                point.x -= scroll.x;
                point.y -= scroll.y;
                context.beginPath();
                context.strokeStyle = this.pointerColor;
                if (this.orientation == Orientation.Horizontal) {
                    context.moveTo(point.x, rect.y);
                    context.lineTo(point.x, rect.bottom())
                } else {
                    context.moveTo(rect.x, point.y);
                    context.lineTo(rect.right(), point.y)
                }
                context.stroke()
            },
            calcPixelsPerUnit: function() {
                var pixels = GraphicsUnit.convert(1, this.unit, GraphicsUnit.Pixel);
                if (this.parent.diagram != null) {
                    pixels *= this.parent.diagram.zoomFactor / 100
                }
                return pixels
            },
            calcUnitInterval: function(pixelsPerUnit) {
                var text = "10000";
                var width = this.context.measureText(text).width;
                var intervals = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];
                for (var i = 0; i < intervals.length; i++) {
                    if (intervals[i] * pixelsPerUnit > width) {
                        return intervals[i]
                    }
                }
                return intervals[intervals.length - 1]
            },
            getThresh: function() {
                var div = 5;
                if (this.parent.diagram == null) {
                    return 1 / div
                }
                return GraphicsUnit.convert(1, this.parent.diagram.measureUnit, GraphicsUnit.Millimeter) / div
            }
        };
        MindFusion.registerClass(Scale, "MindFusion.Diagramming.Scale", "Control");
        var Ruler = mdiag.Ruler = function(element) {
            mflayer.initializeBase(Ruler, this, [element]);
            this.horizontalScaleVisible = true;
            this.verticalScaleVisible = true;
            this.diagramId = "";
            this.scaleSize = 20;
            this.unit = GraphicsUnit.Millimeter;
            this.backColor = "#dddddd";
            this.foreColor = "#000000";
            this.projectionColor = "lightSteelBlue";
            this.enableGuides = true;
            this.guideColor = "#000000";
            this.textColor = "#000000";
            this.pointerColor = "red";
            this.eventHandlers = mflayer.eventHandlerList()
        };
        Ruler.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(Ruler, this, "initialize")
            },
            dispose: function() {
                if (this.horizontalScale) {
                    this.horizontalScale.dispose();
                    this.get_element().removeChild(this.horizontalScale.get_element());
                    this.horizontalScale = null
                }
                if (this.verticalScale) {
                    this.verticalScale.dispose();
                    this.get_element().removeChild(this.verticalScale.get_element());
                    this.verticalScale = null
                }
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(Ruler, this, "dispose")
            },
            registerForSubmit: function(id) {
                var field = document.getElementById(id);
                if (field) {
                    var form = field.form;
                    if (form) {
                        form.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: id
                        })))
                    }
                }
            },
            setDiagram: function(diagram) {
                this.diagram = diagram;
                if (diagram) {
                    this.diagramId = diagram.get_element().id;
                    this.repaintDelegate = mflayer.createDelegate(this, this.refreshScales);
                    diagram.addEventListener(mdiag.Events.repaint, this.repaintDelegate);
                    diagram.addEventListener(mdiag.Events.repaint, mflayer.createDelegate(this, this.onDiagramPaint));
                    diagram.addEventListener("zoomChanged", mflayer.createDelegate(this, this.onResize));
                    mflayer.addHandlers(this.diagram.scrollElement(), {
                        scroll: this.repaintDelegate
                    });
                    this.mouseMoveDelegate = mflayer.createDelegate(this, this.onDiagramMouseMove);
                    mflayer.addHandlers(this.diagram.get_element(), {
                        mousemove: this.mouseMoveDelegate
                    });
                    this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                    mflayer.addHandlers(window, {
                        resize: this.resizeDelegate
                    });
                    this.init()
                }
            },
            preparePostback: function(sender, args) {
                var field = document.getElementById(args.id);
                if (field) {
                    field.value = this.toJson()
                }
            },
            fromJson: function(json) {
                if (json > "") {
                    var obj = mflayer.fromJson(json);
                    if (obj.diagramView) {
                        this.diagramId = obj.diagramView;
                        this.setUnit(obj.unit);
                        this.setBackColor(obj.backColor);
                        this.setForeColor(obj.foreColor);
                        this.setProjectionColor(obj.projectionColor);
                        this.setGuideColor(obj.guideColor);
                        this.setTextColor(obj.textColor);
                        this.setPointerColor(obj.pointerColor);
                        this.setEnableGuides(obj.enableGuides);
                        this.setNegatedX(obj.negatedX);
                        this.setNegatedY(obj.negatedY);
                        this.setProjectRotatedBounds(obj.projectRotatedBounds);
                        this.setHorizontalScaleVisible(obj.horizontalScaleVisible);
                        this.setVerticalScaleVisible(obj.verticalScaleVisible);
                        this.prepareScriptEvent(mdiag.Events.controlLoaded, obj.controlLoadedScript);
                        var thisObj = this;
                        setTimeout(function() {
                            return thisObj.prepare()
                        }, 100)
                    }
                }
            },
            prepare: function() {
                this.setDiagram(mdiag.Diagram.find(this.diagramId));
                this.diagram.invalidate();
                this.refreshScales()
            },
            toJson: function() {
                var json = {
                    id: this.get_element().id,
                    diagramView: this.diagramId,
                    unit: this.unit,
                    backColor: this.backColor,
                    foreColor: this.foreColor,
                    projectionColor: this.projectionColor,
                    guideColor: this.guideColor,
                    textColor: this.textColor,
                    pointerColor: this.pointerColor,
                    enableGuides: this.enableGuides,
                    negatedX: this.negatedX,
                    negatedY: this.negatedY,
                    projectRotatedBounds: this.projectRotatedBounds,
                    horizontalScaleVisible: this.horizontalScaleVisible,
                    verticalScaleVisible: this.verticalScaleVisible,
                };
                return mflayer.toJson(json)
            },
            init: function() {
                if (this.diagram == null) {
                    return
                }
                var grid = this.get_element();
                grid.style.backgroundColor = this.backColor;
                grid.style.overflow = "hidden";
                var horizontalScaleElement = document.createElement("canvas");
                horizontalScaleElement.id = this.diagram.get_element().id + "_horizontalScale";
                horizontalScaleElement.height = this.scaleSize;
                horizontalScaleElement.style.position = "absolute";
                horizontalScaleElement.style.zIndex = 9999;
                grid.insertBefore(horizontalScaleElement, grid.childNodes[0]);
                this.horizontalScale = new Scale(horizontalScaleElement, this, Orientation.Horizontal);
                var verticalScaleElement = document.createElement("canvas");
                verticalScaleElement.id = this.diagram.get_element().id + "_verticalScale";
                verticalScaleElement.width = this.scaleSize;
                verticalScaleElement.style.marginTop = this.scaleSize + "px";
                verticalScaleElement.style.position = "absolute";
                verticalScaleElement.style.zIndex = 9999;
                grid.insertBefore(verticalScaleElement, grid.childNodes[0]);
                this.verticalScale = new Scale(verticalScaleElement, this, Orientation.Vertical);
                this.updateScales();
                this.raiseEvent(mdiag.Events.controlLoaded)
            },
            updateScales: function() {
                var diagramView = document.getElementById(this.diagramId).parentNode;
                this.bounds = mflayer.getBounds(diagramView);
                if (this.horizontalScale) {
                    var element = this.horizontalScale.get_element();
                    if (this.horizontalScaleVisible) {
                        element.style.visibility = "visible";
                        diagramView.style.marginTop = this.scaleSize + "px"
                    } else {
                        element.style.visibility = "hidden";
                        diagramView.style.marginTop = "0px"
                    }
                    if (this.verticalScaleVisible) {
                        element.style.marginLeft = this.scaleSize + "px";
                        element.width = this.bounds.width - this.scaleSize
                    } else {
                        element.style.marginLeft = "0px";
                        element.width = this.bounds.width
                    }
                }
                if (this.verticalScale) {
                    var element = this.verticalScale.get_element();
                    if (this.verticalScaleVisible) {
                        element.style.visibility = "visible";
                        diagramView.style.marginLeft = this.scaleSize + "px"
                    } else {
                        element.style.visibility = "hidden";
                        diagramView.style.marginLeft = "0px"
                    }
                    if (this.horizontalScaleVisible) {
                        element.style.marginTop = this.scaleSize + "px";
                        element.height = this.bounds.height - this.scaleSize
                    } else {
                        element.style.marginTop = "0px";
                        element.height = this.bounds.height
                    }
                }
                this.refreshScales()
            },
            refreshScales: function() {
                if (this.horizontalScale != null) {
                    this.horizontalScale.invalidate()
                }
                if (this.verticalScale != null) {
                    this.verticalScale.invalidate()
                }
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler != null) {
                    handler(this, args)
                }
            },
            onDiagramMouseMove: function(e) {
                if (this.horizontalScale != null) {
                    this.horizontalScale.onDiagramMouseMove(e)
                }
                if (this.verticalScale != null) {
                    this.verticalScale.onDiagramMouseMove(e)
                }
            },
            onDiagramPaint: function(e) {
                if (this.horizontalScale != null) {
                    this.horizontalScale.onDiagramPaint(e)
                }
                if (this.verticalScale != null) {
                    this.verticalScale.onDiagramPaint(e)
                }
            },
            onResize: function(e) {
                this.updateScales()
            },
            prepareScriptEvent: function(eventName, script) {
                if (!script || script == "") {
                    return
                }
                var fn = new Function("sender", "args", "return " + script + "(sender, args)");
                this.addEventListener(eventName, fn)
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            },
            setUnit: function(value) {
                this.unit = value;
                if (this.horizontalScale) {
                    this.horizontalScale.unit = value
                }
                if (this.verticalScale) {
                    this.verticalScale.unit = value
                }
            },
            getUnit: function() {
                return this.unit
            },
            setBackColor: function(value) {
                this.backColor = value;
                this.get_element().style.backgroundColor = this.backColor;
                if (this.horizontalScale) {
                    this.horizontalScale.backColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.backColor = value
                }
            },
            getBackColor: function() {
                return this.backColor
            },
            setForeColor: function(value) {
                this.foreColor = value;
                if (this.horizontalScale) {
                    this.horizontalScale.foreColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.foreColor = value
                }
            },
            getForeColor: function() {
                return this.foreColor
            },
            setProjectionColor: function(value) {
                this.projectionColor = value;
                if (this.horizontalScale) {
                    this.horizontalScale.projectionColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.projectionColor = value
                }
            },
            getProjectionColor: function() {
                return this.projectionColor
            },
            setGuideColor: function(value) {
                this.guideColor = value;
                if (this.horizontalScale) {
                    this.horizontalScale.guideColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.guideColor = value
                }
            },
            getGuideColor: function() {
                return this.guideColor
            },
            setTextColor: function(value) {
                this.textColor = value;
                if (this.horizontalScale) {
                    this.horizontalScale.textColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.textColor = value
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setPointerColor: function(value) {
                this.pointerColor = value;
                if (this.horizontalScale) {
                    this.horizontalScale.pointerColor = value
                }
                if (this.verticalScale) {
                    this.verticalScale.pointerColor = value
                }
            },
            getPointerColor: function() {
                return this.pointerColor
            },
            setEnableGuides: function(value) {
                this.enableGuides = value;
                if (this.horizontalScale) {
                    this.horizontalScale.enableGuides = value
                }
                if (this.verticalScale) {
                    this.verticalScale.enableGuides = value
                }
            },
            getEnableGuides: function() {
                return this.enableGuides
            },
            setHorizontalScaleVisible: function(value) {
                this.horizontalScaleVisible = value;
                this.updateScales()
            },
            getHorizontalScaleVisible: function() {
                return this.horizontalScaleVisible
            },
            setVerticalScaleVisible: function(value) {
                this.verticalScaleVisible = value;
                this.updateScales()
            },
            getVerticalScaleVisible: function() {
                return this.verticalScaleVisible
            },
            setNegatedX: function(value) {
                if (this.negatedX != value) {
                    this.negatedX = value;
                    this.refreshScales()
                }
            },
            getNegatedX: function() {
                return this.negatedX
            },
            setNegatedY: function(value) {
                if (this.negatedY != value) {
                    this.negatedY = value;
                    this.refreshScales()
                }
            },
            getNegatedY: function() {
                return this.negatedY
            },
            setProjectRotatedBounds: function(value) {
                if (this.projectRotatedBounds != value) {
                    this.projectRotatedBounds = value;
                    this.refreshScales()
                }
            },
            getProjectRotatedBounds: function() {
                return this.projectRotatedBounds
            }
        };
        MindFusion.Diagramming.Ruler.create = function(element) {
            return mflayer.createControl(MindFusion.Diagramming.Ruler, null, null, null, element)
        };
        MindFusion.Diagramming.Ruler.find = function(element, parent) {
            return mflayer.findControl(element, parent)
        };
        MindFusion.registerClass(Ruler, "MindFusion.Diagramming.Ruler", "Control")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Path = MindFusion.Drawing.Path;
        var Rect = MindFusion.Drawing.Rect;
        var ScrollBar = mdiag.ScrollBar = function(node) {
            mflayer.initializeBase(ScrollBar, this, [node]);
            this.updateContent();
            this.updateLocation()
        };
        ScrollBar.prototype = {
            needsMouseMessages: function(mousePosition) {
                var thumbRect = this.getThumbRect(this.node);
                return thumbRect != null && thumbRect.containsPoint(mousePosition)
            },
            onMouseDown: function(mousePosition) {
                this.mouseDown = true
            },
            onMouseMove: function(mousePosition) {
                if (!this.mouseDown) {
                    return
                }
                this.node.setCurrScrollRow(this.calcScrollPos(mousePosition))
            },
            onMouseUp: function(mousePosition) {
                this.mouseDown = false
            },
            cancel: function() {
                this.mouseDown = false
            },
            updateLocation: function() {
                var iconRect = this.getRect();
                this.x = iconRect.x;
                this.y = iconRect.y
            },
            onClick: function(mousePosition) {
                var rect = this.getRotatedRect();
                if (!rect.containsPoint(mousePosition)) {
                    return
                }
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var ah = 4 * mm;
                var command = new mdiag.ScrollTableCommand(this, node);
                if (mousePosition.y < rect.y + ah) {
                    node.scrollUp()
                }
                if (mousePosition.y > rect.bottom() - ah) {
                    node.scrollDown()
                }
                if (node.parent.getUndoEnabled()) {
                    node.parent.undoManager.executeCommand(command)
                }
            },
            hitTest: function(mousePosition) {
                return this.getRotatedRect().containsPoint(mousePosition)
            },
            getRect: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var rect = node.bounds;
                var capHeight = node.getCaptionHeight();
                return new Rect(rect.right() - 5 * mm, rect.y + capHeight, 5 * mm, rect.height - capHeight)
            },
            getRotatedRect: function() {
                var rect = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var p = [];
                    p.push(rect.topLeft());
                    p.push(rect.topRight());
                    p.push(rect.bottomRight());
                    p.push(rect.bottomLeft());
                    mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                    var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                    var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                    var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                    return Rect.fromLTRB(minX, minY, maxX, maxY)
                }
                return rect
            },
            updateContent: function() {
                var node = this.node;
                var brush = this.background || MindFusion.Diagramming.Utils.rgbToString(200, 200, 200, 0.5);
                var pen = this.foreground || node.getEffectiveStroke();
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var ah = 4 * mm;
                var hm = 3 * mm / 4;
                var rect = this.getRect();
                rect.x = rect.y = 0;
                rect.brush = brush;
                rect.pen = undefined;
                this.content = [rect];
                var arrow = new Path();
                arrow.moveTo(rect.width / 2, hm);
                arrow.lineTo(rect.width - hm, ah - hm);
                arrow.lineTo(hm, ah - hm);
                arrow.close();
                arrow.done();
                arrow.setBrush(pen);
                this.content.push(arrow);
                var arrow = new Path();
                arrow.moveTo(rect.width / 2, rect.height - hm);
                arrow.lineTo(rect.width - hm, rect.height - ah + hm);
                arrow.lineTo(hm, rect.height - ah + hm);
                arrow.close();
                arrow.done();
                arrow.setBrush(pen);
                this.content.push(arrow);
                var thumbRect = this.getThumbRect(node, rect);
                if (thumbRect) {
                    thumbRect.pen = undefined;
                    thumbRect.brush = pen;
                    this.content.push(thumbRect)
                }
            },
            getThumbRect: function(node, rect) {
                if (!rect) {
                    rect = this.getRect()
                }
                if (node.rows.length > 0) {
                    var rowHeight = node.rows[0].height;
                    var allRowsHeight = rowHeight * node.rows.length;
                    if (allRowsHeight > rect.height) {
                        var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                        var ah = 4 * mm;
                        var range = rect.height - 2 * ah;
                        var thumbHeight = Math.max(4 * mm, range * rect.height / allRowsHeight);
                        range -= thumbHeight;
                        var pos = range * node.currentScrollRow / node.rows.length;
                        var thumbRect = rect.clone();
                        thumbRect.height = thumbHeight;
                        thumbRect.y += ah + pos;
                        return thumbRect
                    }
                }
                return null
            },
            calcScrollPos: function(mousePosition) {
                var node = this.node;
                if (node.rows.length > 0) {
                    var rowHeight = node.rows[0].height;
                    var allRowsHeight = rowHeight * node.rows.length;
                    var rect = this.getRect();
                    if (allRowsHeight > rect.height) {
                        var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                        var ah = 4 * mm;
                        var range = rect.height - 2 * ah;
                        var thumbHeight = Math.max(4 * mm, range * rect.height / allRowsHeight);
                        range -= thumbHeight;
                        var rellativeY = mousePosition.y - rect.y - ah;
                        var scrollPos = parseInt(node.rows.length * rellativeY / range);
                        scrollPos = Math.max(0, scrollPos);
                        scrollPos = Math.min(scrollPos, node.rows.length - 1);
                        return scrollPos
                    }
                }
                return 0
            }
        };
        MindFusion.registerClass(ScrollBar, "MindFusion.Diagramming.ScrollBar", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Path = MindFusion.Drawing.Path;
        var Rect = MindFusion.Drawing.Rect;
        var Scroller = mdiag.Scroller = function(node) {
            mflayer.initializeBase(Scroller, this, [node]);
            this.updateContent();
            this.updateLocation()
        };
        Scroller.prototype = {
            updateLocation: function() {
                var iconRect = this.getRect();
                this.x = iconRect.x;
                this.y = iconRect.y
            },
            onClick: function(mousePosition) {
                var rect = this.getRotatedRect();
                if (!rect.containsPoint(mousePosition)) {
                    return
                }
                var node = this.node;
                var command = new mdiag.ScrollTableCommand(this, node);
                if (mousePosition.y < rect.center().y) {
                    node.scrollUp()
                } else {
                    node.scrollDown()
                }
                if (node.parent.getUndoEnabled()) {
                    node.parent.undoManager.executeCommand(command)
                }
            },
            hitTest: function(mousePosition) {
                return this.getRotatedRect().containsPoint(mousePosition)
            },
            getRect: function() {
                var node = this.node;
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var rect = node.bounds.clone();
                return new Rect(rect.right() - 5 * mm, rect.y, 5 * mm, node.getCaptionHeight())
            },
            getRotatedRect: function() {
                var rect = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var p = [];
                    p.push(rect.topLeft());
                    p.push(rect.topRight());
                    p.push(rect.bottomRight());
                    p.push(rect.bottomLeft());
                    mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var minX = Math.min(p[0].x, Math.min(p[1].x, Math.min(p[2].x, p[3].x)));
                    var minY = Math.min(p[0].y, Math.min(p[1].y, Math.min(p[2].y, p[3].y)));
                    var maxX = Math.max(p[0].x, Math.max(p[1].x, Math.max(p[2].x, p[3].x)));
                    var maxY = Math.max(p[0].y, Math.max(p[1].y, Math.max(p[2].y, p[3].y)));
                    return Rect.fromLTRB(minX, minY, maxX, maxY)
                }
                return rect
            },
            updateContent: function() {
                var node = this.node;
                var pen = node.getEffectiveTextColor();
                var borderPen = node.getEffectiveStroke();
                var grayPen = MindFusion.Diagramming.Utils.rgbToString(100, 100, 100, 0.2);
                var mm = GraphicsUnit.getMillimeter(node.parent.measureUnit);
                var hm = 3 * mm / 4;
                var rect = this.getRect();
                rect.x = rect.y = 0;
                rect.pen = borderPen;
                this.content = [rect];
                var arrowRect = rect.clone();
                arrowRect.pen = pen;
                arrowRect.height = rect.height / 2;
                if (!node.canScrollUp()) {
                    arrowRect.brush = grayPen;
                    this.content.push(arrowRect)
                }
                var arrowRect = arrowRect.clone();
                arrowRect.pen = pen;
                arrowRect.y += rect.height / 2;
                if (!node.canScrollDown()) {
                    arrowRect.brush = grayPen;
                    this.content.push(arrowRect)
                }
                var arrowInterior = pen;
                var arrow = new Path();
                arrow.moveTo(rect.width / 2, hm);
                arrow.lineTo(rect.width - hm, rect.height / 2 - hm);
                arrow.lineTo(hm, rect.height / 2 - hm);
                arrow.close();
                arrow.done();
                arrow.setBrush(arrowInterior);
                this.content.push(arrow);
                var arrow = new Path();
                arrow.moveTo(rect.width / 2, rect.height - hm);
                arrow.lineTo(rect.width - hm, rect.height / 2 + hm);
                arrow.lineTo(hm, rect.height / 2 + hm);
                arrow.close();
                arrow.done();
                arrow.setBrush(arrowInterior);
                this.content.push(arrow)
            }
        };
        MindFusion.registerClass(Scroller, "MindFusion.Diagramming.Scroller", mdiag.Manipulator)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var SelectOnlyBehavior = mdiag.SelectOnlyBehavior = function(parent, nodeConstructor) {
            mflayer.initializeBase(SelectOnlyBehavior, this, [parent])
        };
        SelectOnlyBehavior.prototype = {
            createController: function(state) {
                return new mdiag.CreateSelectionController(this.diagram.selection)
            }
        };
        MindFusion.registerClass(SelectOnlyBehavior, "MindFusion.Diagramming.SelectOnlyBehavior", mdiag.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Rect = MindFusion.Drawing.Rect;
        var Dictionary = MindFusion.Collections.Dictionary;
        var ArrayList = MindFusion.Collections.ArrayList;
        var Selection = mdiag.Selection = function(parent) {
            mflayer.initializeBase(Selection, this, [parent]);
            this.items = [];
            this.nodes = [];
            this.links = [];
            this.allowMultipleSelection = true;
            this.bounds = new Rect(0, 0, 0, 0)
        };
        Selection.prototype = {
            startDrag: function(ist) {
                mflayer.callBaseMethod(Selection, this, "startDrag", [ist]);
                this.savedBounds = this.bounds.clone()
            },
            updateDrag: function(ist) {
                if (ist.action === mdiag.Action.Modify) {
                    var delta = mdiag.Utils.subtract(ist.currentPoint, ist.startPoint);
                    var point = this.savedBounds.topLeft().addVector(delta);
                    this.bounds.setLocation(point)
                }
            },
            endDrag: function(ist) {
                if (ist.action === mdiag.Action.Create) {
                    var selBounds = Rect.fromPoints(ist.startPoint, ist.currentPoint);
                    this.selectItemsInRect(selBounds);
                    this.parent.invalidate()
                } else {
                    if (ist.action === mdiag.Action.Modify) {
                        this.parent.raiseSelectionMoved()
                    }
                }
            },
            allowDrag: function(ist) {
                for (var i = 0, l = this.nodes.length; i < l; i++) {
                    var node = this.nodes[i];
                    if (!node.allowDrag(ist)) {
                        return false
                    }
                }
                return true
            },
            saveLocationState: function() {
                return {
                    bounds: this.bounds.clone()
                }
            },
            addItem: function(item) {
                if (!item) {
                    return
                }
                this.addItemInternal(item);
                this.parent.activeItem = item
            },
            addItemInternal: function(item) {
                if (item.getSelected()) {
                    return
                }
                this.items.push(item);
                item.setSelectedState(true);
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                    this.nodes.push(item);
                    item.updateAnchorVisibility4()
                } else {
                    this.links.push(item)
                }
                this.bounds = mdiag.Utils.unionRects(this.bounds, item.getRotatedBounds());
                this.parent.raiseSelected(item)
            },
            removeItem: function(item) {
                if (!this.removeItemInternal(item)) {
                    return false
                }
                if (!this.parent.activeItem.getSelected()) {
                    this.parent.activeItem = (this.items.length > 0) ? this.items[0] : null
                }
                return true
            },
            removeItemInternal: function(item) {
                if (this.itemInSelection(item)) {
                    ArrayList.remove(this.items, item);
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                        ArrayList.remove(this.nodes, item)
                    } else {
                        ArrayList.remove(this.links, item)
                    }
                    item.setSelectedState(false);
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, item)) {
                        item.updateAnchorVisibility4()
                    }
                    this.parent.raiseDeselected(item);
                    return true
                }
                return false
            },
            clear: function() {
                this.clearInternal();
                this.parent.activeItem = null
            },
            clearInternal: function() {
                for (var i = 0, l = this.items.length; i < l; i++) {
                    this.items[i].setSelectedState(false);
                    this.parent.raiseDeselected(this.items[i]);
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, this.items[i])) {
                        this.items[i].updateAnchorVisibility4()
                    }
                }
                this.items = [];
                this.nodes = [];
                this.links = []
            },
            selectSingle: function(item) {
                this.clearInternal();
                this.items.push(item);
                item.invalidate()
            },
            itemInSelection: function(item) {
                for (var i = 0; i < this.items.length; i++) {
                    if (this.items[i] === item) {
                        return true
                    }
                }
                return false
            },
            selectItemsInRect: function(rect) {
                this.clearInternal();
                var newSel = [];
                this.parent.getIntersectingItems(rect, newSel, this.allowMultipleSelection, true);
                for (var i = 0, l = newSel.length; i < l; i++) {
                    this.addItemInternal(newSel[i])
                }
                if (this.items.length === 0) {
                    this.parent.activeItem = null
                } else {
                    if (this.parent.activeItem == null || !this.parent.activeItem.getSelected()) {
                        this.parent.activeItem = this.items[0]
                    }
                }
            },
            onRemove: function() {},
            cloneNodes: function(idmap) {
                var result = [];
                for (var i = 0, l = this.items.length; i < l; i++) {
                    if (mflayer.isInstanceOfType(mdiag.DiagramNode, this.items[i])) {
                        var clone = this.items[i].clone();
                        if (this.items[i].container != null && idmap.contains(this.items[i].container)) {
                            clone.container = idmap.get(this.items[i].container)
                        }
                        if (this.items[i].masterNode != null && idmap.contains(this.items[i].masterNode)) {
                            clone.masterNode = idmap.get(this.items[i].masterNode)
                        }
                        idmap.set(this.items[i], clone);
                        result.push(clone)
                    }
                }
                return result
            },
            cloneLinks: function(idmap) {
                var result = [];
                for (var i = 0, l = this.items.length; i < l; i++) {
                    if (mflayer.isInstanceOfType(mdiag.DiagramLink, this.items[i])) {
                        var link = this.items[i];
                        var clone = link.clone();
                        if (this.items[i].origin != null && idmap.contains(this.items[i].origin)) {
                            clone.origin = idmap.get(this.items[i].origin)
                        } else {
                            clone.origin = null
                        }
                        if (this.items[i].destination != null && idmap.contains(this.items[i].destination)) {
                            clone.destination = idmap.get(this.items[i].destination)
                        } else {
                            clone.destination = null
                        }
                        clone.setupOriginConnection(link.originConnection.clone(clone, clone.origin == null ? new mdiag.DummyNode() : clone.origin));
                        clone.setupDestConnection(link.destinationConnection.clone(clone, clone.destination == null ? new mdiag.DummyNode() : clone.destination));
                        result.push(clone)
                    }
                }
                return result
            },
            toJson: function() {
                var result = [];
                var idmap = new Dictionary();
                var nodes = this.cloneNodes(idmap);
                var links = this.cloneLinks(idmap);
                var instanceId = 0;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    nodes[i].instanceId = instanceId++
                }
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var json = nodes[i].toJson();
                    result.push(json)
                }
                for (var i = 0, l = links.length; i < l; i++) {
                    var link = links[i];
                    link.instanceId = instanceId++;
                    var json = link.toJson();
                    result.push(json)
                }
                return mflayer.toJson({
                    items: result
                })
            },
            getHandlePosition: function(handle) {
                if (mflayer.isInstanceOfType(mdiag.DiagramNode, this.parent.activeItem)) {
                    return this.parent.activeItem.getHandlePosition(handle)
                }
                return this.bounds.topLeft()
            },
            handleAtPoint: function(point) {
                if (this.items.length <= 1) {
                    return null
                }
                var diagram = this.parent;
                var handle = diagram.getHandleAt(point, true);
                if (handle) {
                    if (diagram.allowMultipleResize && mflayer.isInstanceOfType(mdiag.DiagramNode, handle.item)) {
                        return handle
                    }
                    return {
                        item: this,
                        index: 8
                    }
                }
                var item = this.parent.getItemAt(point);
                if (item != null && item.getSelected()) {
                    return {
                        item: this,
                        index: 8
                    }
                }
                return null
            }
        };
        MindFusion.registerClass(Selection, "MindFusion.Diagramming.Selection", mdiag.DiagramItem)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Path = MindFusion.Drawing.Path;
        var Matrix = MindFusion.Drawing.Matrix;
        var Point = MindFusion.Drawing.Point;
        var ArrayList = MindFusion.Collections.ArrayList;
        var Shape = mdiag.Shape = function(params, dummy) {
            if (!params) {
                params = {}
            }
            this.params = params;
            if (!this.params.fillMode) {
                this.params.fillMode = "nonzero"
            }
            if (params.id) {
                this.id = params.id;
                if (dummy !== true) {
                    defaultShapes[params.id] = this
                }
            }
            if (dummy === true) {
                this.dummy = true
            }
        };
        var defaultShapes = Shape.shapes = [];
        defaultShapesDefined = false;
        Shape.loadFromLibPending = false;
        Shape.fromId = function(id) {
            if (Shape.loadFromLibPending) {
                return Shape.createDummyShape(id)
            }
            if (!defaultShapesDefined) {
                Shape.initializeDefault()
            }
            return defaultShapes[id]
        };
        Shape.createDummyShape = function(id) {
            return new Shape({
                id: id,
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0"
            }, true)
        };
        Shape.registerDefaultShape = function(shape) {
            if (!shape || !shape.id) {
                return
            }
            if (!defaultShapesDefined) {
                Shape.initializeDefault()
            }
            defaultShapes[shape.id] = shape
        };
        Shape.initializeDefault = function() {
            defaultShapesDefined = true;
            var params = {};
            var shapes = [];
            shapes.push(params = {
                id: "Actor",
                outline: "M50,20  A10, 10, 0, 0, 1, 50, 0 A10, 10, 0, 0, 1, 50, 20  L70,20  A5, 5, 0, 0, 1, 75, 25  L75,60 L68,60 L68,30 L64,30 L64,100 L52,100 L52,65 L48,65 L48,100 L36,100 L36,30 L32,30 L32,60 L25,60 L25,25  A5, 5, 0, 0, 1, 30, 20  L50,20"
            });
            shapes.push(params = {
                id: "Alternative",
                outline: "M0,100 L50,0 L100,100 L0,100"
            });
            shapes.push(params = {
                id: "Arrow",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,95 L50,0 L13,95"
            });
            shapes.push(params = {
                id: "Arrow1",
                outline: "M40,50 L0,0 L60,0 L100,50 L60,100 L0,100 L40,50"
            });
            shapes.push(params = {
                id: "Arrow2",
                outline: "M0,0 L25,0 L25,40 L60,40 L60,0 L100,50 L60,100 L60,60 L25,60 L25,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "Arrow3",
                outline: "M0,30 L60,30 L60,0 L100,50 L60,100 L60,70 L0,70 L0,30"
            });
            shapes.push(params = {
                id: "Arrow4",
                outline: "M0,30 L60,30 L60,0 L100,50 L60,100 L60,70 L0,70 L20,50 L0,30"
            });
            shapes.push(params = {
                id: "Arrow5",
                outline: "M30,30 L30,0 L0,50 L30,100 L30,70 L70,70 L70,100 L100,50 L70,0 L70,30 L30,30"
            });
            shapes.push(params = {
                id: "Arrow6",
                outline: "M0,100 C50,66,50,33,0,0 L100,50 L0,100"
            });
            shapes.push(params = {
                id: "Arrow7",
                outline: "M0,0 L70,0 L100,50 L70,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "Arrow8",
                outline: "M40,0 L40,35 L0,0 L0,100 L40,65 L40,100 L100,50 L40,0",
                decoration: "M40,35 L40,65"
            });
            shapes.push(params = {
                id: "Arrow9",
                outline: "M0,0 L30,50 L0,100 L100,50 L0,0"
            });
            shapes.push(params = {
                id: "BackSlash",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,-37 L87,37"
            });
            shapes.push(params = {
                id: "BeginLoop",
                outline: "M0,25 L0,25 L0,100 L100,100 L100,25 L75,0 L25,0 L0,25"
            });
            shapes.push(params = {
                id: "BowArrow",
                outline: "M50,0 L94,95 L60,75 L60,95 L40,95 L40,75 L6,95 L50,0"
            });
            shapes.push(params = {
                id: "BpmnComplex",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M20,45 L38,45 L25,32 L32,25 L45,38 L45,20 L55,20 L55,38 L68,25 L75,32 L62,45 L80,45 L80,55 L62,55 L75,68 L68,75 L55,62 L55,80 L45,80 L45,62 L32,75 L25,68 L38,55 L20,55 L20,45"
                }]
            });
            shapes.push(params = {
                id: "BpmnDataBasedXor",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M45,50 L33,26 L43,26 L50,40 L57,26 L67,26 L55,50 L67,74 L57,74 L50,60 L43,74 L33,74 L45,50"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndCancel",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M45,50 L23,28 L28,23 L50,45 L73,23 L78,28 L55,50 L78,73 L73,78 L50,55 L28,78 L23,73 L45,50"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndCompensation",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M14,50 L50,30 L50,70 L14,50"
                }, {
                    path: "M47,50 L83,30 L83,70 L47,50"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndError",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M77,23 L60,65 L43,45 L23,77 L40,35 L57,55 L77,23"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30",
                shapeDecorations: [{
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndMultiple",
                outline: "M100,50  A50, 50, 0, 1, 1, 99.2403876506104, 41.31759111665348 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEndTerminate",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999 "
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnEventBasedXor",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M70,50  A20, 20, 0, 0, 1, 30, 50 A20, 20, 0, 0, 1, 70, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M44,41 L50,32 L56,41 L66,41 L61,50 L66,59 L56,59 L50,68 L44,59 L34,59 L39,50 L34,41 L44,41"
                }]
            });
            shapes.push(params = {
                id: "BpmnInclusive",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  L70,50  A20, 20, 0, 0, 1, 30, 50 A20, 20, 0, 0, 1, 70, 49.99999999999999  L80,50",
                    fillMode: "evenodd"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateCancel",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M45,50 L23,28 L28,23 L50,45 L73,23 L78,28 L55,50 L78,73 L73,78 L50,55 L28,78 L23,73 L45,50"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateCompensation",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M14,50 L50,30 L50,70 L14,50"
                }, {
                    path: "M47,50 L83,30 L83,70 L47,50"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateError",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M77,23 L60,65 L43,45 L23,77 L40,35 L57,55 L77,23"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30"
            });
            shapes.push(params = {
                id: "BpmnIntermediateMultiple",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateRule",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M25,20 L75,20 L75,80 L25,80 L25,20",
                    brush: "#FFFFFF"
                }, {
                    path: "M45,30 L55,30 L55,31 L45,31 L45,30",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,47 L60,47 L60,48 L40,48 L40,47",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,65 L60,65 L60,66 L40,66 L40,65",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }]
            });
            shapes.push(params = {
                id: "BpmnIntermediateTimer",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M20,50 L30,50 M24,35 L30,39 M35,24 L39,30 M50,20 L50,30 M65,24 L61,30 M76,35 L70,39 M70,50 L80,50 M76,65 L70,61 M65,76 L61,70 M50,70 L50,80 M24,65 L30,61 M35,76 L39,70 M50,50 L53,24 M50,50 L67,50"
            });
            shapes.push(params = {
                id: "BpmnParallelFork",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M20,45 L45,45 L45,20 L55,20 L55,45 L80,45 L80,55 L55,55 L55,80 L45,80 L45,55 L20,55 L20,45"
                }]
            });
            shapes.push(params = {
                id: "BpmnStartLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }]
            });
            shapes.push(params = {
                id: "BpmnStartMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30"
            });
            shapes.push(params = {
                id: "BpmnStartMultiple",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }]
            });
            shapes.push(params = {
                id: "BpmnStartRule",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M25,20 L75,20 L75,80 L25,80 L25,20",
                    brush: "#FFFFFF"
                }, {
                    path: "M45,30 L55,30 L55,31 L45,31 L45,30",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,47 L60,47 L60,48 L40,48 L40,47",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,65 L60,65 L60,66 L40,66 L40,65",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }]
            });
            shapes.push(params = {
                id: "BpmnStartTimer",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M20,50 L30,50 M24,35 L30,39 M35,24 L39,30 M50,20 L50,30 M65,24 L61,30 M76,35 L70,39 M70,50 L80,50 M76,65 L70,61 M65,76 L61,70 M50,70 L50,80 M24,65 L30,61 M35,76 L39,70 M50,50 L53,24 M50,50 L67,50"
            });
            shapes.push(params = {
                id: "Circle",
                fillMode: "evenodd",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 "
            });
            shapes.push(params = {
                id: "Cloud",
                outline: "M67,0 C58,2,61,7,60,19 C49,11,51,8,43,14 C37,19,40,25,41,33 C35,24,27,13,13,21 C10,25,7,29,15,44 C5,47,0,50,0,63 C3,74,17,72,27,71 C21,77,14,93,27,100 C38,100,52,93,55,78 C70,93,81,87,88,80 C91,69,87,63,79,57 C90,52,100,43,100,24 C96,7,77,0,67,0"
            });
            shapes.push(params = {
                id: "Collate",
                outline: "M100,100 L0,100 L100,0 L0,0 L100,100"
            });
            shapes.push(params = {
                id: "ConeDown",
                outline: "M0,80 C6,94,30,100,50,100 C70,100,94,94,100,80 L50,0 L0,80",
                decoration: "M0,80 C10,65,30,60,50,60 C70,60,90,65,100,80"
            });
            shapes.push(params = {
                id: "ConeUp",
                outline: "M0,80 C6,94,30,100,50,100 C70,100,94,94,100,80 L50,0 L0,80"
            });
            shapes.push(params = {
                id: "ConnectedIssues",
                outline: "M0,10 L40,50 L0,90 L10,100 L50,60 L90,100 L100,90 L60,50 L100,10 L90,0 L50,40 L10,0 L0,10"
            });
            shapes.push(params = {
                id: "CreateRequest",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15 M0,85 L100,85"
            });
            shapes.push(params = {
                id: "Cross",
                outline: "M40,40 L40,0 L60,0 L60,40 L100,40 L100,60 L60,60 L60,100 L40,100 L40,60 L0,60 L0,40 L40,40"
            });
            shapes.push(params = {
                id: "Cube",
                outline: "M70,100 L70,100 L0,100 L0,30 L70,30 L0,30 L30,0 L100,0 L70,30 L100,0 L100,70 L70,100 L70,30 L70,100"
            });
            shapes.push(params = {
                id: "Cylinder",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20"
            });
            shapes.push(params = {
                id: "Database",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20 M100,30 C100,45,70,50,50,50 C30,50,0,45,0,30 M100,40 C100,55,70,60,50,60 C30,60,0,55,0,40"
            });
            shapes.push(params = {
                id: "DataTransmition",
                outline: "M15,100 L85,100 L100,50 L85,0 L15,0 L0,50 L15,100"
            });
            shapes.push(params = {
                id: "DDelay",
                outline: "M0,100 L67,100 C85,100,100,75,100,50 C100,25,85,0,67,0 L0,0 C15,0,33,25,33,50 C33,75,15,100,0,100"
            });
            shapes.push(params = {
                id: "Decision",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0"
            });
            shapes.push(params = {
                id: "Decision2",
                outline: "M0,50 L25,100 L75,100 L100,50 L75,0 L25,0 L0,50"
            });
            shapes.push(params = {
                id: "DefaultFlow",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,111 L87,37"
            });
            shapes.push(params = {
                id: "Delay",
                outline: "M0,0 L50,0 C80,0,100,30,100,50 C100,70,80,100,50,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "DInDelay",
                outline: "M0,100 L100,100 C85,100,67,75,67,50 C67,25,85,0,100,0 L0,0 C15,0,33,25,33,50 C33,75,15,100,0,100"
            });
            shapes.push(params = {
                id: "DirectAccessStorage",
                outline: "M10,0 L90,0 C95.52284749830794,0,100,22.38576250846033,100,50 C100,77.61423749153967,95.52284749830794,100,90,100 L10,100 C4.477152501692068,100,1.7763568394002505e-15,77.61423749153967,0,50.00000000000001 C0,22.38576250846034,4.477152501692064,7.105427357601002e-15,9.999999999999998,0",
                decoration: "M10,0 C15.522847498307934,0,20,22.38576250846033,20,50 C20,77.61423749153967,15.522847498307934,100,10,100"
            });
            shapes.push(params = {
                id: "DiskStorage",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20 M100,30 C100,45,70,50,50,50 C30,50,0,45,0,30"
            });
            shapes.push(params = {
                id: "Display",
                outline: "M40,100 C15,100,0,70,0,50 C0,30,15,0,40,0 L85,0 C100,20,100,30,100,50 C100,70,100,80,85,100 L40,100"
            });
            shapes.push(params = {
                id: "DividedEvent",
                outline: "M10,100 L90,100 C95,100,100,95,100,90 L100,10 C100,5,95,0,90,0 L10,0 C5,0,0,5,0,10 L0,90 C0,95,5,100,10,100",
                decoration: "M0,15 L100,15"
            });
            shapes.push(params = {
                id: "DividedProcess",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15"
            });
            shapes.push(params = {
                id: "Document",
                outline: "M0,90 L0,0 L100,0 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90"
            });
            shapes.push(params = {
                id: "DoubleArrow",
                outline: "M50,0 L87,95 L50,95 L87,190 L13,190 L50,95 L50,95 L13,95 L50,0"
            });
            shapes.push(params = {
                id: "DOutDelay",
                outline: "M33,100 L67,100 C80,100,100,75,100,50 C100,25,85,0,67,0 L33,0 C15,0,0,25,0,50 C0,75,15,100,33,100"
            });
            shapes.push(params = {
                id: "Ellipse",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 "
            });
            shapes.push(params = {
                id: "EndLoop",
                outline: "M100,75 L100,0 L0,0 L0,75 L25,100 L75,100 L100,75"
            });
            shapes.push(params = {
                id: "ExternalOrganization",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M10,0 L0,10 M90,0 L100,10 M90,100 L100,90 M0,90 L10,100"
            });
            shapes.push(params = {
                id: "ExternalProcess",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M40,10 L60,10 M40,90 L60,90 M10,40 L10,60 M90,40 L90,60"
            });
            shapes.push(params = {
                id: "File",
                outline: "M0,0 L0,100 L100,100 L100,30 L70,0 L0,0",
                decoration: "M70,0 L70,30 L100,30"
            });
            shapes.push(params = {
                id: "FramedRectangle",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M5,5 L95,5 L95,95 L5,95 L5,5"
            });
            shapes.push(params = {
                id: "Gate",
                outline: "M6.123233995736766e-15,0 C55.228474983079344,0,100,22.38576250846033,100,50 C100,77.61423749153967,55.228474983079344,100,6.123233995736766e-15,100 M0,100 C55,75,55,25,0,0"
            });
            shapes.push(params = {
                id: "Heart",
                outline: "M50,20 C50,5,65,0,75,0 C85,0,100,10,100,25 C100,50,67,75,50,100 C33,75,0,50,0,25 C0,10,15,0,25,0 C35,0,50,5,50,20"
            });
            shapes.push(params = {
                id: "Heptagon",
                outline: "M28,100 L0,70 L10,25 L50,0 L90,25 L100,70 L72,100 L28,100"
            });
            shapes.push(params = {
                id: "Hourglass",
                outline: "M0,0 L30,50 L0,100 L100,100 L70,50 L100,0 L0,0"
            });
            shapes.push(params = {
                id: "Input",
                outline: "M0,100 L0,100 L100,100 L100,0 L0,40 L0,100"
            });
            shapes.push(params = {
                id: "InternalStorage",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15 M15,0 L15,100"
            });
            shapes.push(params = {
                id: "Interrupt",
                outline: "M0,0 L0,100 L100,50 L100,100 L100,0 L100,50 L0,0"
            });
            shapes.push(params = {
                id: "Interrupt2",
                outline: "M0,0 L0,100 L80,50 L80,20 L100,0 L80,20 L80,80 L60,100 L80,80 L80,50 L0,0"
            });
            shapes.push(params = {
                id: "IsoProcess",
                outline: "M0,0 L75,0 L100,50 L75,100 L0,100 L25,50 L0,0"
            });
            shapes.push(params = {
                id: "Junction",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M15,15 L85,85 M85,15 L15,85"
            });
            shapes.push(params = {
                id: "Lightning",
                outline: "M30,0 L30,0 L15,40 L45,40 L30,100 L65,30 L33,27 L56,0 L30,0"
            });
            shapes.push(params = {
                id: "LinedDocument",
                outline: "M0,90 L0,0 L100,0 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90",
                decoration: "M15,0 L15,96"
            });
            shapes.push(params = {
                id: "ManualOperation",
                outline: "M100,0 L0,0 L20,100 L80,100 L100,0"
            });
            shapes.push(params = {
                id: "Merge",
                outline: "M0,0 L100,0 L50,100 L0,0"
            });
            shapes.push(params = {
                id: "MessageFromUser",
                outline: "M0,100 L100,100 L80,50 L100,0 L0,0 L0,100"
            });
            shapes.push(params = {
                id: "MessageToUser",
                outline: "M100,100 L20,100 L0,50 L20,0 L100,0 L100,100"
            });
            shapes.push(params = {
                id: "Microform",
                outline: "M0,90 L0,10 C16,20,33,20,50,10 C66,0,83,0,100,10 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90"
            });
            shapes.push(params = {
                id: "MicroformProcessing",
                outline: "M0,100 L50,74 L100,100 L100,0 L50,25 L0,0 L0,100"
            });
            shapes.push(params = {
                id: "MicroformRecording",
                outline: "M0,100 L80,75 L100,85 L100,15 L80,25 L0,0 L0,100"
            });
            shapes.push(params = {
                id: "MultiDocument",
                outline: "M0,92 L0,20 L10,20 L10,10 L20,10 L20,0 L100,0 L100,72 C95,69,90,69,90,69 L90,82 C85,79,80,79,80,79 L80,92 C66,84,53,84,39,92 C26,100,13,100,0,92",
                decoration: "M10,20 L80,20 L80,79 M20,10 L90,10 L90,69"
            });
            shapes.push(params = {
                id: "MultiProc",
                outline: "M0,100 L80,100 L80,90 L90,90 L90,80 L100,80 L100,0 L20,0 L20,10 L10,10 L10,20 L0,20 L0,100",
                decoration: "M10,20 L80,20 L80,90 M20,10 L90,10 L90,80"
            });
            shapes.push(params = {
                id: "Octagon",
                outline: "M33,100 L0,67 L0,33 L33,0 L67,0 L100,33 L100,67 L67,100 L33,100"
            });
            shapes.push(params = {
                id: "OfflineStorage",
                outline: "M0,0 L50,100 L100,0 L0,0",
                decoration: "M10,20 L90,20"
            });
            shapes.push(params = {
                id: "OffpageConnection",
                outline: "M0,0 L50,0 L100,50 L50,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "OffpageReference",
                outline: "M0,70 L0,0 L100,0 L100,70 L50,100 L0,70"
            });
            shapes.push(params = {
                id: "Or",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M50,0 L50,100 M0,50 L100,50"
            });
            shapes.push(params = {
                id: "Pentagon",
                outline: "M50,0 L0,50 L15,100 L85,100 L100,50 L50,0"
            });
            shapes.push(params = {
                id: "PentagonArrow",
                outline: "M50,0 L87,37 L87,95 L13,95 L13,37 L50,0"
            });
            shapes.push(params = {
                id: "PointerArrow",
                outline: "M50,0 L87,95 L50,60 L13,95 L50,0"
            });
            shapes.push(params = {
                id: "PrimitiveFromCall",
                outline: "M0,100 L100,100 L80,50 L100,0 L0,0 L0,100",
                decoration: "M15,0 L15,100"
            });
            shapes.push(params = {
                id: "PrimitiveToCall",
                outline: "M100,100 L20,100 L0,50 L20,0 L100,0 L100,100",
                decoration: "M85,0 L85,100"
            });
            shapes.push(params = {
                id: "Procedure",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M15,0 L15,100 M85,0 L85,100"
            });
            shapes.push(params = {
                id: "Process",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M15,0 L15,100"
            });
            shapes.push(params = {
                id: "Prysm",
                outline: "M50,0 L100,20 L100,80 L50,100 L50,100 L0,80 L0,20 L50,0",
                decoration: "M0,20 L50,40 L50,100 M50,40 L100,20"
            });
            shapes.push(params = {
                id: "PunchedCard",
                outline: "M0,100 L0,100 L0,30 L30,0 L100,0 L100,100 L0,100"
            });
            shapes.push(params = {
                id: "PyramidDown",
                outline: "M50,100 L100,80 L50,0 L0,80 L50,100",
                decoration: "M0,80 L50,60 M50,0 L50,60 M100,80 L50,60"
            });
            shapes.push(params = {
                id: "PyramidUp",
                outline: "M50,100 L100,80 L50,0 L0,80 L50,100",
                decoration: "M50,0 L50,100"
            });
            shapes.push(params = {
                id: "Quill",
                outline: "M50,0 L87,37 L87,95 L50,58 L13,95 L13,37 L50,0"
            });
            shapes.push(params = {
                id: "Rectangle",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "Reversed",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,0 L50,95 L13,0"
            });
            shapes.push(params = {
                id: "RevTriangle",
                outline: "M87,0 L50,95 L13,0 L87,0"
            });
            shapes.push(params = {
                id: "RevWithCirc",
                fillMode: "evenodd",
                outline: "M84,147  A37, 37, 0, 0, 1, 10, 147 A37, 37, 0, 0, 1, 84, 147 ",
                decoration: "M87,0 L50,95 L13,0"
            });
            shapes.push(params = {
                id: "RevWithLine",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,0 L50,95 L13,0 M13,110 L87,110"
            });
            shapes.push(params = {
                id: "Rhombus",
                outline: "M50,0 L83,55 L50,100 L17,55 L50,0"
            });
            shapes.push(params = {
                id: "RoundRect",
                outline: "U0,0,100,100,2.5"
            });
            shapes.push(params = {
                id: "RSave",
                outline: "M30,100 L100,100 L70,0 L0,0 L30,100"
            });
            shapes.push(params = {
                id: "Save",
                outline: "M0,100 L25,0 L100,0 L75,100 L0,100"
            });
            shapes.push(params = {
                id: "Slash",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,37 L87,-37"
            });
            shapes.push(params = {
                id: "Sort",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M0,50 L100,50"
            });
            shapes.push(params = {
                id: "Sphere",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M50,0 C25,25,25,75,50,100"
            });
            shapes.push(params = {
                id: "Star",
                outline: "M50,0 L50,0 L40,33 L0,30 L30,50 L15,100 L50,60 L85,100 L67,50 L100,30 L60,33 L50,0"
            });
            shapes.push(params = {
                id: "Start",
                outline: "M15,100 C5,100,0,75,0,50 C0,25,5,0,15,0 L85,0 C95,0,100,25,100,50 C100,75,95,100,85,100 L15,100",
                decoration: "M15,0 L15,100 M85,0 L85,100"
            });
            shapes.push(params = {
                id: "Tape",
                outline: "M50,100  A50, 50, 0, 1, 1, 74.99999999999998, 93.30127018922194  M75,93.30127 L100,93.30127 L100,100 L50,100"
            });
            shapes.push(params = {
                id: "Terminator",
                outline: "M20,100 L80,100 C90,100,100,75,100,50 C100,25,90,0,80,0 L20,0 C10,0,0,25,0,50 C0,75,10,100,20,100"
            });
            shapes.push(params = {
                id: "Tetragon",
                outline: "M50,0 L83,80 L50,100 L17,80 L50,0"
            });
            shapes.push(params = {
                id: "TransmittalTape",
                outline: "M60,90 L100,100 L100,0 L0,0 L0,90 L60,90"
            });
            shapes.push(params = {
                id: "Triangle",
                outline: "M50,0 L87,95 L13,95 L50,0"
            });
            shapes.push(params = {
                id: "RightTriangle",
                outline: "M0,0 L100,100 L0,100 L0,0"
            });
            shapes.push(params = {
                id: "Decagon",
                outline: "M100,50 L90.45085,80.9017 L65.45085,100 L34.54915,100 L9.54915,80.9017 L0,50 L9.54915,19.0983 L34.54915,0.000002414559 L65.45085,0.000002414559 L90.45085,19.0983 L100,50"
            });
            shapes.push(params = {
                id: "Trapezoid",
                outline: "M10,0 L90,0 L100,100 L0,100 L10,0"
            });
            shapes.push(params = {
                id: "Star4Pointed",
                outline: "M50,0 L64.14214,35.85786 L100,50 L64.14214,64.14214 L50,100 L35.85786,64.14214 L0,50 L35.85786,35.85786 L50,0"
            });
            shapes.push(params = {
                id: "Star5Pointed",
                outline: "M50,0 L60.58014,35.43769 L97.55283,34.54915 L67.11902,55.56231 L79.38926,90.45085 L50,68 L20.61074,90.45085 L32.88098,55.56231 L2.447174,34.54915 L39.41986,35.43769 L50,0"
            });
            shapes.push(params = {
                id: "Star6Pointed",
                outline: "M50,0 L58,36.14359 L93.30127,25 L66,50 L93.30127,75 L58,63.85641 L50,100 L42,63.85641 L6.69873,75 L34,50 L6.69873,25 L42,36.14359 L50,0"
            });
            shapes.push(params = {
                id: "Star7Pointed",
                outline: "M50,0 L56.94214,35.5845 L89.09158,18.82551 L65.59885,46.43967 L98.7464,61.12605 L62.5093,59.97584 L71.69418,95.04845 L50,66 L28.30581,95.04845 L37.4907,59.97584 L1.253604,61.12605 L34.40115,46.43967 L10.90843,18.82551 L43.05786,35.5845 L50,0"
            });
            shapes.push(params = {
                id: "Star16Pointed",
                outline: "M50,0 L57.80361,10.76859 L69.13417,3.806023 L72.22281,16.74121 L85.35534,14.64466 L83.25878,27.77719 L96.19398,30.86583 L89.23141,42.19639 L100,50 L89.23141,57.80361 L96.19398,69.13417 L83.25878,72.22281 L85.35534,85.35534 L72.22281,83.25878 L69.13417,96.19398 L57.80361,89.23141 L50,100 L42.19639,89.23141 L30.86583,96.19398 L27.77719,83.25878 L14.64466,85.35534 L16.74121,72.22281 L3.806023,69.13417 L10.76859,57.80361 L0,50 L10.76859,42.19639 L3.806023,30.86583 L16.74121,27.77719 L14.64466,14.64466 L27.77719,16.74121 L30.86583,3.806023 L42.19639,10.76859 L50,0"
            });
            shapes.push(params = {
                id: "Star24Pointed",
                outline: "M50,0 L55.22105,10.34221 L62.94095,1.703709 L65.30733,13.04482 L75,6.69873 L74.35046,18.26587 L85.35534,14.64466 L81.73413,25.64954 L93.30127,25 L86.95518,34.69266 L98.29629,37.05905 L89.65779,44.77895 L100,50 L89.65779,55.22105 L98.29629,62.94095 L86.95518,65.30733 L93.30127,75 L81.73413,74.35046 L85.35534,85.35534 L74.35046,81.73413 L75,93.30127 L65.30733,86.95518 L62.94095,98.29629 L55.22105,89.65779 L50,100 L44.77895,89.65779 L37.05905,98.29629 L34.69266,86.95518 L25,93.30127 L25.64954,81.73413 L14.64466,85.35534 L18.26587,74.35046 L6.69873,75 L13.04482,65.30733 L1.703709,62.94095 L10.34221,55.22105 L0,50 L10.34221,44.77895 L1.703709,37.05905 L13.04482,34.69266 L6.69873,25 L18.26587,25.64954 L14.64466,14.64466 L25.64954,18.26587 L25,6.69873 L34.69266,13.04482 L37.05905,1.703709 L44.77895,10.34221 L50,0"
            });
            shapes.push(params = {
                id: "Star32Pointed",
                outline: "M50,0 L53.92068,10.19261 L59.75452,0.960736 L61.61139,11.72239 L69.13417,3.806023 L68.85587,14.72315 L77.77851,8.426519 L75.37573,19.07958 L85.35534,14.64466 L80.92042,24.62427 L91.57348,22.22149 L85.27685,31.14413 L96.19398,30.86583 L88.27761,38.38861 L99.03926,40.24548 L89.80739,46.07932 L100,50 L89.80739,53.92068 L99.03926,59.75452 L88.27761,61.61139 L96.19398,69.13417 L85.27685,68.85587 L91.57348,77.77851 L80.92042,75.37573 L85.35534,85.35534 L75.37573,80.92042 L77.77851,91.57348 L68.85587,85.27685 L69.13417,96.19398 L61.61139,88.27761 L59.75452,99.03926 L53.92068,89.80739 L50,100 L46.07932,89.80739 L40.24548,99.03926 L38.38861,88.27761 L30.86583,96.19398 L31.14413,85.27685 L22.22149,91.57348 L24.62427,80.92042 L14.64466,85.35534 L19.07958,75.37573 L8.426519,77.77851 L14.72315,68.85587 L3.806023,69.13417 L11.72239,61.61139 L0.960736,59.75452 L10.19261,53.92068 L0,50 L10.19261,46.07932 L0.960736,40.24548 L11.72239,38.38861 L3.806023,30.86583 L14.72315,31.14413 L8.426519,22.22149 L19.07958,24.62427 L14.64466,14.64466 L24.62427,19.07958 L22.22149,8.426519 L31.14413,14.72315 L30.86583,3.806023 L38.38861,11.72239 L40.24548,0.960736 L46.07932,10.19261 L50,0"
            });
            shapes.push(params = {
                id: "Donut",
                fillMode: "evenodd",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  M74,50  A24, 24, 0, 0, 1, 26, 50.00000000000001 A24, 24, 0, 0, 1, 74, 50 "
            });
            shapes.push(params = {
                id: "Plaque",
                outline: "M10,0 L90,0  A10, 10, 0, 0, 0, 100, 10  L100,90  A10, 10, 0, 0, 0, 90, 100  L10,100  A10, 10, 0, 0, 0, 6.123233995736766e-16, 90  L0,10  A10, 10, 0, 0, 0, 10, 0 "
            });
            for (var i = 0; i < shapes.length; i++) {
                new Shape(shapes[i])
            }
        };
        Shape.prototype = {
            loadFromXml: function(xmlElement, context) {
                this.params = {};
                this.params.id = this.id = xmlElement.getAttribute("id");
                var fillMode = xmlElement.getAttribute("fill-mode");
                if (fillMode == "Alternate") {
                    this.params.fillMode = "evenodd"
                } else {
                    this.params.fillMode = "nonzero"
                }
                var outlineElement = context.selectSingleNode("outline", xmlElement);
                if (outlineElement) {
                    this.params.outline = this.xmlCollectionToPath(outlineElement, context)
                }
                var decorationsElement = context.selectSingleNode("decorations", xmlElement);
                if (decorationsElement) {
                    this.params.decoration = this.xmlCollectionToPath(decorationsElement, context)
                }
                var shapeDecorationsElement = context.selectSingleNode("shape-decorations", xmlElement);
                if (shapeDecorationsElement && shapeDecorationsElement.childNodes.length > 0) {
                    this.params.shapeDecorations = [];
                    for (var i = 0; i < shapeDecorationsElement.childNodes.length; i++) {
                        var shapeDecoration = shapeDecorationsElement.childNodes[i];
                        if (shapeDecoration.nodeType !== 1) {
                            continue
                        }
                        var decorationElement = context.selectSingleNode("decorations", shapeDecoration);
                        var sd = {};
                        sd.path = this.xmlCollectionToPath(decorationElement, context);
                        var brush = context.selectSingleNode("brush", shapeDecoration);
                        if (brush) {
                            sd.brush = context.readBrushContent(brush)
                        }
                        var pen = context.selectSingleNode("pen", shapeDecoration);
                        if (pen) {
                            sd.pen = context.readPen("pen", shapeDecoration)
                        }
                        sd.fillMode = "nonzero";
                        var decorationFillMode = context.selectSingleNode("fill-mode", shapeDecoration);
                        if (decorationFillMode && decorationFillMode.textContent == "0") {
                            sd.fillMode = "evenodd"
                        }
                        this.params.shapeDecorations.push(sd)
                    }
                }
            },
            xmlCollectionToPath: function(parentElement, context) {
                var objects = [];
                for (var i = 0; i < parentElement.childNodes.length; i++) {
                    var child = parentElement.childNodes[i];
                    if (child.nodeType !== 1) {
                        continue
                    }
                    var obj = this.xmlElementToPath(child);
                    if (Array.isArray(obj[0])) {
                        objects = objects.concat(obj)
                    } else {
                        if (obj[0] != "none") {
                            objects.push(obj)
                        }
                    }
                }
                this.pt = null;
                var pathString = "";
                for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    if (obj[0] instanceof Array) {
                        for (var j = 0; j < obj.length; j++) {
                            pathString += this.processPathString(obj[j]);
                            pathString += " "
                        }
                    } else {
                        pathString += this.processPathString(obj);
                        if (i == 0 && obj[0] == "bezier" && pathString.substring(0, 1) != "M") {
                            pathString = "M" + obj[1] + "," + obj[2] + " " + pathString
                        }
                        pathString += " "
                    }
                }
                return pathString.trim()
            },
            processPathString: function(obj) {
                var pathString = "";
                switch (obj[0]) {
                    case "arc":
                        if (this.pt == null || this.pt.x != obj[7] || this.pt.y != obj[8]) {
                            pathString += "M" + obj[7] + "," + obj[8] + " "
                        }
                        var sweep = obj[5] - obj[4];
                        pathString += "A" + obj[3] + "," + obj[3] + ",0," + (Math.abs(sweep) >= Math.PI ? 1 : 0) + "," + (sweep > 0 ? 1 : 0);
                        this.pt = this.getArcPoint(obj[1], obj[2], obj[3], obj[5]);
                        pathString += "," + this.pt.x + "," + this.pt.y;
                        break;
                    case "line":
                        if (this.pt == null || this.pt.x != obj[1] || this.pt.y != obj[2]) {
                            pathString += "M" + obj[1] + "," + obj[2] + " L" + obj[3] + "," + obj[4]
                        } else {
                            pathString += "L" + obj[3] + "," + obj[4]
                        }
                        this.pt = {
                            x: obj[3],
                            y: obj[4]
                        };
                        break;
                    case "bezier":
                        if (this.pt == null || this.pt.x != obj[1] || this.pt.y != obj[2]) {
                            pathString += "M" + obj[1] + "," + obj[2] + " "
                        }
                        pathString += "C" + obj[3] + "," + obj[4] + "," + obj[5] + "," + obj[6] + "," + obj[7] + "," + obj[8];
                        this.pt = {
                            x: obj[7],
                            y: obj[8]
                        };
                        break;
                    case "quad":
                        if (this.pt == null || this.pt.x != obj[1] || this.pt.y != obj[2]) {
                            pathString += "M" + obj[1] + "," + obj[2] + " "
                        }
                        pathString += "Q" + obj[3] + "," + obj[4] + "," + obj[5] + "," + obj[6];
                        this.pt = {
                            x: obj[5],
                            y: obj[6]
                        };
                        break;
                    case "roundRect":
                        if (this.pt == null || this.pt.x != obj[1] || this.pt.y != obj[2]) {
                            pathString += "M" + obj[1] + "," + obj[2] + " "
                        }
                        pathString += "U" + obj[1] + "," + obj[2] + "," + obj[3] + "," + obj[4] + "," + obj[5];
                        this.pt = {
                            x: obj[4],
                            y: obj[5]
                        };
                        break;
                    default:
                        break
                }
                return pathString
            },
            xmlElementToPath: function(element) {
                switch (element.tagName) {
                    case "arc":
                        var x = parseFloat(element.getAttribute("x"));
                        var y = parseInt(element.getAttribute("y"));
                        var w = parseFloat(element.getAttribute("arc-width"));
                        var h = parseFloat(element.getAttribute("arc-height"));
                        var a = parseFloat(element.getAttribute("start"));
                        var sw = parseFloat(element.getAttribute("sweep"));
                        if (sw == 360) {
                            return [this.addArc(x, y, w, h, a, 180), this.addArc(x, y, w, h, a + 180, 180)]
                        }
                        if (sw == -360) {
                            return [this.addArc(x, y, w, h, a, -180), this.addArc(x, y, w, h, a - 180, -180)]
                        }
                        return this.addArc(x, y, w, h, a, sw);
                    case "line":
                        var points = element.getElementsByTagName("point");
                        var x1 = parseFloat(points[0].getAttribute("x"));
                        var x2 = parseFloat(points[1].getAttribute("x"));
                        var y1 = parseFloat(points[0].getAttribute("y"));
                        var y2 = parseFloat(points[1].getAttribute("y"));
                        return ["line", x1, y1, x2, y2];
                    case "bezier":
                        var points = element.getElementsByTagName("point");
                        var x1 = parseFloat(points[0].getAttribute("x"));
                        var x2 = parseFloat(points[1].getAttribute("x"));
                        var x3 = parseFloat(points[2].getAttribute("x"));
                        var x4 = parseFloat(points[3].getAttribute("x"));
                        var y1 = parseFloat(points[0].getAttribute("y"));
                        var y2 = parseFloat(points[1].getAttribute("y"));
                        var y3 = parseFloat(points[2].getAttribute("y"));
                        var y4 = parseFloat(points[3].getAttribute("y"));
                        return ["bezier", x1, y1, x2, y2, x3, y3, x4, y4];
                    case "round-rectangle":
                        var x = parseFloat(element.getAttribute("x"));
                        var y = parseFloat(element.getAttribute("y"));
                        var w = parseFloat(element.getAttribute("w"));
                        var h = parseFloat(element.getAttribute("h"));
                        var r = parseFloat(element.getAttribute("r"));
                        return ["roundRect", x, y, x + w, y + h, r];
                    default:
                        return ["none"]
                }
            },
            addArc: function(x, y, w, h, a, sw) {
                var rx = w / 2;
                var ry = h / 2;
                if (rx == ry) {
                    var sp = this.getArcPoint(x + w / 2, y + h / 2, rx, mdiag.Utils.radians(a));
                    return ["arc", x + rx, y + ry, rx, mdiag.Utils.radians(a), mdiag.Utils.radians(a + sw), sw < 0 ? 1 : 0, sp.x, sp.y]
                }
                var points = mdiag.Utils.arcToBezierCurves(x, y, w, h, a, sw);
                var result = [];
                for (var i = 0, counter = 0; i < points.length; counter++) {
                    result.push(["bezier"]);
                    for (var j = 0; j < 4; j++) {
                        if (points[i + j] == null) {
                            continue
                        }
                        result[counter].push(points[i + j].x);
                        result[counter].push(points[i + j].y)
                    }
                    i += 4
                }
                return result
            },
            getArcPoint: function(x, y, r, a) {
                return {
                    x: Math.round(x + Math.cos(a) * r),
                    y: Math.round(y + Math.sin(a) * r)
                }
            },
            apply: function(item) {
                item.outlinePath = new Path(this.params.outline || "");
                item.outlinePath.setPen(this.params.outlinePen || "#000000");
                item.outlinePath.setBrush(this.params.outlineBrush || "#A9A9A9");
                item.decorationPath = new Path(this.params.decoration || "");
                item.decorationPath.setPen(this.params.decorationPen || "#000000");
                item.decorationPath.setBrush(this.params.decorationBrush || "transparent");
                item.shapeDecorationPath = new Path(this.params.shapeDecoration || "");
                item.shapeDecorationPath.setPen(this.params.shapeDecorationPen || "#000000");
                item.shapeDecorationPath.setBrush(this.params.shapeDecorationBrush || "#000000")
            },
            updateData: function(item, bounds, angle) {
                if (bounds.width === 0 || bounds.height === 0) {
                    return
                }
                var outlineBounds = this.defaultBounds;
                var x = bounds.width / outlineBounds.width;
                var y = bounds.height / outlineBounds.height;
                var matrix = new Matrix();
                matrix.translate(bounds.x - bounds.width / 2, bounds.y - bounds.height / 2);
                matrix.scale(x, y);
                matrix.translate(bounds.width / x - outlineBounds.x - outlineBounds.width / 2, bounds.height / y - outlineBounds.y - outlineBounds.height / 2);
                if (this.shapeOrientation > 0) {
                    matrix.rotateAt(this.shapeOrientation, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                if (angle !== 0) {
                    matrix.rotateAt(angle, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                item.outlinePath.transform = matrix.clone();
                item.decorationPath.transform = matrix.clone();
                item.shapeDecorationPath.transform = matrix.clone()
            },
            addCanvasElements: function(item, elements, index) {
                if (index != null) {
                    if (!item.outlinePath.empty()) {
                        ArrayList.insert(elements, index, item.outlinePath)
                    }
                    if (!item.decorationPath.empty()) {
                        ArrayList.insert(elements, index + 1, item.decorationPath)
                    }
                    if (!item.shapeDecorationPath.empty()) {
                        ArrayList.insert(elements, index + 2, item.shapeDecorationPath)
                    }
                } else {
                    if (!item.outlinePath.empty()) {
                        ArrayList.add(elements, item.outlinePath)
                    }
                    if (!item.decorationPath.empty()) {
                        ArrayList.add(elements, item.decorationPath)
                    }
                    if (!item.shapeDecorationPath.empty()) {
                        ArrayList.add(elements, item.shapeDecorationPath)
                    }
                }
            },
            removeCanvasElements: function(item, elements) {
                ArrayList.remove(elements, item.outlinePath);
                ArrayList.remove(elements, item.decorationPath);
                ArrayList.remove(elements, item.shapeDecorationPath)
            },
            clone: function() {
                var shape = new Shape();
                shape.id = this.id;
                shape.params = this.params;
                return shape
            },
            getId: function() {
                return this.id
            },
            isElliptic: function() {
                var path = new Path(this.params.outline);
                var p = path.builder;
                if (p[0] == "A") {
                    if (p[7] == 0 && p[9] == 6.28318530717959) {
                        return true
                    }
                }
                return false
            },
            isDummy: function() {
                return this.dummy === true
            },
            id: "",
            shapeOrientation: 0,
            defaultBounds: new MindFusion.Drawing.Rect(0, 0, 100, 100)
        };
        MindFusion.registerClass(Shape, "MindFusion.Diagramming.Shape")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Shape = MindFusion.Diagramming.Shape;
        var ArrayList = MindFusion.Collections.ArrayList;
        var ShapeLibrary = mdiag.ShapeLibrary = function(shapes) {
            this.shapes = [];
            if (shapes) {
                for (var shape in shapes) {
                    this.shapes.push(shape)
                }
            }
        };
        ShapeLibrary.onShapeLibraryLoaded = function() {
            if (!document) {
                return
            }
            var canvases = document.getElementsByTagName("CANVAS");
            if (!canvases) {
                return
            }
            ArrayList.forEach(canvases, function(element) {
                var control = MindFusion.find(element.id);
                if (control && control.onShapeLibraryLoaded) {
                    control.onShapeLibraryLoaded()
                }
            })
        };
        ShapeLibrary.prototype = {
            loadFromXml: function(fileUrl, onLoad, onError) {
                var library = this;
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        var doc = xhr.responseXML;
                        var context = new mdiag.XmlPersistContext(library, doc);
                        library.shapes = [];
                        var shapes = doc.getElementsByTagName("shapes")[0];
                        if (!shapes) {
                            return
                        }
                        var element = shapes.firstChild;
                        if (!element) {
                            return
                        }
                        while (element != null) {
                            if (element.nodeType == 1) {
                                var s = new Shape();
                                s.loadFromXml(element, context);
                                Shape.registerDefaultShape(s);
                                library.shapes.push(s)
                            }
                            element = element.nextSibling
                        }
                        ShapeLibrary.onShapeLibraryLoaded(true);
                        if (onLoad) {
                            onLoad(library)
                        }
                    } else {
                        if (console && console.log) {
                            console.log("Error while getting ShapeLibrary XML. " + xhr.status + " " + xhr.statusText)
                        }
                        ShapeLibrary.onShapeLibraryLoaded(false);
                        if (onError) {
                            onError(library)
                        }
                    }
                };
                xhr.onerror = function() {
                    if (console && console.log) {
                        console.log("Error while getting ShapeLibrary XML. " + xhr.status + " " + xhr.statusText)
                    }
                    ShapeLibrary.onShapeLibraryLoaded(false);
                    if (onError) {
                        onError(library)
                    }
                };
                xhr.open("GET", fileUrl);
                xhr.responseType = "document";
                xhr.send()
            },
            getShapes: function() {
                if (!this.shapes) {
                    this.shapes = []
                }
                return this.shapes
            }
        };
        MindFusion.registerClass(ShapeLibrary, "MindFusion.Diagramming.ShapeLibrary")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var FitSize = MindFusion.Diagramming.FitSize;
        var Text = MindFusion.Drawing.Text;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var Thickness = MindFusion.Drawing.Thickness;
        var ShapeNode = mdiag.ShapeNode = function(parent) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(ShapeNode, this, [parent]);
            this.rotationAngle = 0;
            if (mdiag.DiagramItem.useStyles === false) {
                this.setTextColor("black")
            }
            this.text.fitInBounds = true;
            this.imageLocation = "";
            this.image = null;
            this.imageAlign = MindFusion.Drawing.ImageAlign.Fit;
            this.rotateText = true;
            this.rotateImage = true;
            this.allowFlip = false;
            this.flipX = false;
            this.flipY = false;
            if (parent && mdiag.DiagramItem.useStyles === false) {
                this.pen = parent.shapePen;
                this.brush = parent.shapeBrush
            }
            this.setShape(parent && parent.defaultShape ? parent.defaultShape : "RoundRect");
            this.transparent = false;
            mdiag.Diagram.suppressSetDirty = false
        };
        ShapeNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(ShapeNode, this, "clone", []);
                copy.setShape(this.shape.id);
                copy.setImageLocation(this.imageLocation);
                copy.setTransparent(this.transparent);
                copy.setImageAlign(this.imageAlign);
                copy.imagePadding = this.imagePadding;
                copy.setRotateText(this.rotateText);
                copy.setRotateImage(this.rotateImage);
                copy.setImageContent(this.imageContent);
                copy.setEnableStyledText(this.getEnableStyledText());
                copy.setFlipX(this.getFlipX());
                copy.setFlipY(this.getFlipY());
                copy.setAllowFlip(this.getAllowFlip());
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(ShapeNode, this, "toJson", []);
                if (this.imageContent) {
                    if (this.parent.saveImage) {
                        json.imageIndex = this.parent.saveImage(this.imageContent)
                    } else {
                        json.imageData = this.imageContent
                    }
                }
                json.shape = this.shape.id;
                json.imageLocation = this.imageLocation || "";
                json.transparent = this.transparent;
                json.imageAlign = this.imageAlign;
                json.imagePadding = this.imagePadding;
                json.rotateText = this.rotateText;
                json.rotateImage = this.rotateImage;
                json.enableStyledText = this.getEnableStyledText();
                json.flipX = this.flipX;
                json.flipY = this.flipY;
                json.allowFlip = this.allowFlip;
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(ShapeNode, this, "fromJson", [json]);
                this.setShape(MindFusion.Diagramming.Shape.fromId(json.shape) || "RoundRect");
                if (json.imageIndex != undefined) {
                    this.setImageContent(this.parent.images[json.imageIndex])
                }
                if (json.imageData != undefined) {
                    this.setImageContent(json.imageData)
                }
                this.setImageLocation(json.imageLocation);
                this.setTransparent(json.transparent);
                this.setImageAlign(json.imageAlign);
                if (json.imagePadding) {
                    this.setImagePadding(Thickness.copy(json.imagePadding))
                }
                this.setRotateText(json.rotateText);
                this.setRotateImage(json.rotateImage);
                this.setEnableStyledText(json.enableStyledText);
                if (json.flipX != undefined) {
                    this.setFlipX(json.flipX)
                }
                if (json.flipY != undefined) {
                    this.setFlipY(json.flipY)
                }
                if (json.allowFlip != undefined) {
                    this.setAllowFlip(json.allowFlip)
                }
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(ShapeNode, this, "loadFromXml", [xmlElement, context]);
                this.setEnableStyledText(context.readBool("EnableStyledText", xmlElement));
                this.setShape(context.readShape("Shape", xmlElement));
                if (this.shape == null) {
                    this.setShape("Rectangle")
                }
                this.rotateText = context.readBool("RotateText", xmlElement, this.rotateText);
                var legacyTextFormat = context.readStringFormat("TextFormat", xmlElement);
                if (legacyTextFormat) {
                    this.setTextAlignment(legacyTextFormat.alignment);
                    this.setLineAlignment(legacyTextFormat.lineAlignment)
                } else {
                    this.setTextAlignment(context.readInt("TextAlignment", xmlElement));
                    this.setLineAlignment(context.readInt("TextVerticalAlignment", xmlElement))
                }
                this.imageAlign = context.readInt("ImageAlign", xmlElement);
                this.setImageContent(context.readImage("Image", xmlElement));
                this.rotateImage = context.readBool("RotateImage", xmlElement, this.rotateImage);
                var imagePaddingElement = context.selectNode(xmlElement, "ImagePadding");
                if (imagePaddingElement) {
                    this.imagePadding = context.readThickness("ImagePadding", xmlElement)
                }
                this.transparent = context.readBool("Transparent", xmlElement);
                this.flipX = context.readBool("FlipX", xmlElement, this.flipX);
                this.flipY = context.readBool("FlipY", xmlElement, this.flipY);
                this.allowFlip = context.readBool("AllowFlip", xmlElement, this.allowFlip)
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(ShapeNode, this, "saveToXml", [xmlElement, context]);
                context.writeBool(this.getEnableStyledText(), "EnableStyledText", xmlElement);
                context.writeShape(this.getShape(), "Shape", xmlElement);
                context.writeBool(this.rotateText, "RotateText", xmlElement);
                context.writeInt(this.getTextAlignment(), "TextAlignment", xmlElement);
                context.writeInt(this.getLineAlignment(), "TextVerticalAlignment", xmlElement);
                context.writeInt(this.imageAlign, "ImageAlign", xmlElement);
                context.writeImage(this.getImageContent(), "Image", xmlElement);
                context.writeBool(this.rotateImage, "RotateImage", xmlElement);
                if (this.imagePadding) {
                    context.writeThickness(this.imagePadding, "ImagePadding", xmlElement)
                }
                context.writeBool(this.transparent, "Transparent", xmlElement);
                context.writeBool(this.flipX, "FlipX", xmlElement);
                context.writeBool(this.flipY, "FlipY", xmlElement);
                context.writeBool(this.allowFlip, "AllowFlip", xmlElement)
            },
            setRotateText: function(value) {
                if (this.rotateText != value) {
                    this.rotateText = value;
                    this.invalidate()
                }
            },
            getRotateText: function() {
                return this.rotateText
            },
            setRotateImage: function(value) {
                if (this.rotateImage != value) {
                    this.rotateImage = value;
                    this.invalidate()
                }
            },
            getRotateImage: function() {
                return this.rotateImage
            },
            setImage: function(value) {
                if (!value) {
                    this.image = null
                } else {
                    this.image = new MindFusion.Drawing.Image(this.bounds);
                    this.image.image = value;
                    this.image.loaded = true
                }
                this.invalidate()
            },
            getImage: function() {
                if (!this.image) {
                    return null
                }
                return this.image.image
            },
            setImageAlign: function(value) {
                if (this.imageAlign != value) {
                    this.imageAlign = value;
                    if (this.image) {
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getImageAlign: function() {
                if (this.imageAlign === undefined) {
                    return MindFusion.Drawing.ImageAlign.Fit
                }
                return this.imageAlign
            },
            setImagePadding: function(value) {
                if (this.imagePadding !== value) {
                    this.imagePadding = value;
                    this.invalidate()
                }
            },
            getImagePadding: function() {
                return this.imagePadding
            },
            setTransparent: function(value) {
                if (this.transparent != value) {
                    this.transparent = value;
                    this.invalidate()
                }
            },
            getTransparent: function() {
                return this.transparent
            },
            setFlipX: function(value) {
                if (this.flipX != value) {
                    this.flipX = value;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                    this.invalidate()
                }
            },
            getFlipX: function() {
                return this.flipX
            },
            setFlipY: function(value) {
                if (this.flipY != value) {
                    this.flipY = value;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                    this.invalidate()
                }
            },
            getFlipY: function() {
                return this.flipY
            },
            setAllowFlip: function(value) {
                if (this.allowFlip != value) {
                    this.allowFlip = value;
                    this.invalidate()
                }
            },
            getAllowFlip: function() {
                return this.allowFlip
            },
            validateParams: function(params) {
                if (params.length === 0) {
                    return
                }
                this.parent = params[0]
            },
            getBaseType: function() {
                return this.constructor.__baseType.__typeName
            },
            containsPoint: function(point) {
                var bounds = this.getRotatedBounds();
                if (!bounds.containsPoint(point)) {
                    return false
                }
                if (mdiag.Utils.pointInPolygon(point, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(point)) {
                    return true
                }
                return false
            },
            onShapeLoaded: function() {
                this.graphicsContainer.invalidParent = this
            },
            updateCanvasElements: function() {
                var content = this.graphicsContainer.content = [];
                if (this.shape.isDummy() && !mdiag.Shape.loadFromLibPending) {
                    this.shape = mdiag.Shape.fromId(this.shape.id);
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setShape(this.shape)
                    }
                }
                var rect = this.bounds;
                if (!this.transparent) {
                    var brush = this.getEffectiveBrush();
                    var params = {
                        brush: brush,
                        phase: EffectPhase.BeforeFill
                    };
                    this.applyEffects(content, params);
                    if (params.brush) {
                        brush = params.brush
                    }
                }
                if (!this.shapeRenderer) {
                    this.shapeRenderer = new mdiag.ShapeRenderer(this.shape);
                    this.shapeRenderer.setFlip(this.flipX, this.flipY)
                }
                this.shapeRenderer.updateData(this.bounds, this.rotationAngle);
                if (!this.transparent) {
                    this.shapeRenderer.outlineBrush = this.getEffectiveBrush();
                    this.shapeRenderer.outlinePen = this.getEffectiveStroke();
                    this.shapeRenderer.decorationPen = this.shapeRenderer.outlinePen;
                    this.shapeRenderer.strokeThickness = this.getEffectiveStrokeThickness();
                    this.shapeRenderer.strokeDashStyle = this.getEffectiveStrokeDashStyle();
                    this.shapeRenderer.shadow = this.createShadow();
                    content.push(this.shapeRenderer)
                }
                var image = this.image;
                if (image && image.loaded) {
                    if (this.transparent) {
                        this.shapeRenderer.updateData(this.bounds, this.rotationAngle)
                    }
                    image.clipPath = this.shapeRenderer.getOutline();
                    var paddedRect = rect.clone();
                    if (this.imagePadding) {
                        this.imagePadding.applyTo(paddedRect)
                    }
                    image.setBounds(paddedRect, this.rotateImage ? this.rotationAngle : 0);
                    image.imageAlign = this.imageAlign;
                    content.push(image)
                }
                if (!this.transparent) {
                    this.applyEffects(content, {
                        phase: EffectPhase.AfterFill
                    })
                }
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.setBounds(rect, (this.rotateText) ? this.rotationAngle : 0);
                content.push(this.text);
                this.addManipulatorVisuals(content);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            updateDrag: function(ist) {
                mflayer.callBaseMethod(ShapeNode, this, "updateDrag", [ist]);
                var state = ist.originalStates.get(this);
                if (state == null) {
                    return
                }
                var i = ist.adjustmentHandle.index;
                if (this.allowFlip && i < 8) {
                    var oldFlipX = this.flipX;
                    var oldFlipY = this.flipY;
                    var delta = ist.delta();
                    if (delta.x != 0) {
                        if ((delta.x < 0 && (i == 1 || i == 2 || i == 5)) || (delta.x > 0 && (i == 0 || i == 3 || i == 7))) {
                            this.flipX = ist.startBounds.width - Math.abs(delta.x) < 0 ? !state.flipX : state.flipX
                        }
                    }
                    if (delta.y != 0) {
                        if ((delta.y < 0 && (i == 2 || i == 3 || i == 6)) || (delta.y > 0 && (i == 0 || i == 1 || i == 4))) {
                            this.flipY = ist.startBounds.height - Math.abs(delta.y) < 0 ? !state.flipY : state.flipY
                        }
                    }
                    if (this.shapeRenderer && (this.flipX != oldFlipX || this.flipY != oldFlipY)) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                }
            },
            setShape: function(value) {
                if (typeof value == "string") {
                    value = mdiag.Shape.fromId(value)
                }
                if (this.shape != value) {
                    this.shape = value;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setShape(this.shape)
                    }
                    this.invalidate()
                }
            },
            getShape: function() {
                return this.shape
            },
            setImageLocation: function(value) {
                if (this.imageLocation != value) {
                    this.imageLocation = value;
                    if (value) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.image.image.src = value
                    }
                    this.setDiagramDirty()
                }
            },
            getImageLocation: function() {
                return this.imageLocation
            },
            setImageContent: function(value) {
                if (this.imageContent != value) {
                    this.imageContent = value;
                    if (value) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        var url = "data:image/png;base64," + this.imageContent;
                        this.image.image.src = url
                    }
                    this.setDiagramDirty()
                }
            },
            getImageContent: function() {
                return this.imageContent
            },
            loadImage: function() {
                this.image.loaded = true;
                if (this.parent) {
                    this.invalidate()
                }
            },
            setEnableStyledText: function(value) {
                if (this.text.enableStyledText != value) {
                    this.text.enableStyledText = value;
                    this.invalidate()
                }
            },
            getEnableStyledText: function() {
                return this.text.enableStyledText
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var approximation = mdiag.Utils.getApproximatingContext();
                this.shapeRenderer.getOutline().addToContext(approximation);
                return approximation.transformAndGetPoints()
            },
            resolveInheritedStyle: function(check, theme) {
                var nodeStyle = theme.styles["std:ShapeNode"];
                if (nodeStyle) {
                    if (check.apply(nodeStyle)) {
                        return nodeStyle
                    }
                }
                return mflayer.callBaseMethod(ShapeNode, this, "resolveInheritedStyle", [check, theme])
            },
            resizeToFitText: function(fit) {
                if (this.text == undefined || this.text == "") {
                    return false
                }
                if (fit == undefined) {
                    fit = FitSize.KeepRatio
                }
                var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                var rc = this.bounds.clone();
                this.textPadding.applyTo(rc);
                var stepx = mdiag.Utils.getFitTextStep(this.parent.measureUnit);
                var stepy = stepx;
                var text = this.text.text;
                var font = this.getEffectiveFont();
                var styled = this.getEnableStyledText();
                if (fit == FitSize.KeepWidth) {
                    var size = this.parent.measureString(text, font, rc, styled);
                    rc.height = size.height;
                    this.textPadding.addToRect(rc);
                    this.setBounds(rc, true)
                } else {
                    if (fit == FitSize.KeepHeight) {
                        if (styled) {
                            rc.width = Number.MAX_VALUE;
                            var size = this.parent.measureString(text, font, rc, styled);
                            rc.width = size.width
                        } else {
                            var maxRect = rc.clone();
                            maxRect.width = Number.MAX_VALUE;
                            var maxSize = this.parent.measureString(text, font, maxRect, styled);
                            var size = this.parent.measureString(text, font, rc, styled);
                            var minWidth = Text.getMinWidth(text, font, this.parent.context, this.parent.scale);
                            if (rc.width < minWidth) {
                                var c = minWidth - rc.width;
                                rc.width = minWidth
                            }
                            if (size.height > rc.height) {
                                while (size.height > rc.height && rc.width < maxSize.width) {
                                    rc.width += stepx;
                                    size = this.parent.measureString(text, font, rc, styled);
                                    if (rc.width < minWidth) {
                                        break
                                    }
                                }
                            } else {
                                while (size.height < rc.height) {
                                    rc.width -= stepx;
                                    size = this.parent.measureString(text, font, rc, styled);
                                    if (rc.width < minWidth) {
                                        break
                                    }
                                }
                                rc.width += stepx
                            }
                        }
                        this.textPadding.addToRect(rc);
                        this.setBounds(rc, true)
                    } else {
                        if (fit == FitSize.KeepRatio) {
                            var hvratio = rc.width / rc.height;
                            var vhratio = rc.height / rc.width;
                            if (hvratio < vhratio) {
                                vhratio = 1 / hvratio;
                                hvratio = 1
                            } else {
                                hvratio = 1 / vhratio;
                                vhratio = 1
                            }
                            stepx = hvratio * stepx;
                            stepy = vhratio * stepy;
                            var cx = 0;
                            var cy = 0;
                            var b = this.bounds.clone();
                            var size = this.parent.measureString(text, font, rc, styled);
                            var minWidth = styled ? 20 * mm : Text.getMinWidth(text, font, this.parent.context, this.parent.scale);
                            if (b.width < minWidth) {
                                var c = minWidth - rc.width;
                                b.width = minWidth;
                                b.height = rc.height + c
                            }
                            if (size.height < rc.height) {
                                do {
                                    cx -= stepx;
                                    cy -= stepy;
                                    rc = b.clone();
                                    rc = mdiag.Utils.inflate(rc, cx, cy);
                                    size = this.parent.measureString(text, font, rc, styled);
                                    if (rc.width < minWidth) {
                                        break
                                    }
                                } while (size.height < rc.height);
                                cx += stepx;
                                cy += stepy;
                                rc = b.clone();
                                rc = mdiag.Utils.inflate(rc, cx, cy)
                            } else {
                                var size = this.parent.measureString(text, font, rc, styled);
                                while (size.height > rc.height) {
                                    cx += stepx;
                                    cy += stepy;
                                    rc = this.bounds.clone();
                                    rc = mdiag.Utils.inflate(rc, cx, cy);
                                    var size = this.parent.measureString(text, font, rc, styled);
                                    if (rc.width > mm * 1000) {
                                        break
                                    }
                                }
                            }
                            this.textPadding.addToRect(rc);
                            this.setBounds(rc, true)
                        }
                    }
                }
                this.invalidate();
                return true
            },
            saveLocationState: function() {
                var state = mflayer.callBaseMethod(ShapeNode, this, "saveLocationState", []);
                state.flipX = this.flipX;
                state.flipY = this.flipY;
                return state
            },
            restoreLocationState: function(ist) {
                var state = ist.originalStates.get(this);
                if (state != null) {
                    this.setFlipX(state.flipX);
                    this.setFlipY(state.flipY)
                }
                mflayer.callBaseMethod(ShapeNode, this, "restoreLocationState", [ist])
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(ShapeNode, this, "saveState", []);
                state.shape = this.shape;
                state.imageLocation = this.imageLocation;
                state.transparent = this.transparent;
                state.imageAlign = this.imageAlign;
                state.imagePadding = this.imagePadding;
                state.rotateText = this.rotateText;
                state.rotateImage = this.rotateImage;
                state.allowFlip = this.allowFlip;
                state.flipX = this.flipX;
                state.flipY = this.flipY;
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(ShapeNode, this, "restoreState", [state]);
                this.setShape(state.shape);
                this.setImageLocation(state.imageLocation);
                this.setTransparent(state.transparent);
                this.setImageAlign(state.imageAlign);
                this.imagePadding = state.imagePadding;
                this.setRotateText(state.rotateText);
                this.setRotateImage(state.rotateImage);
                this.allowFlip = state.allowFlip;
                this.setFlipX(state.flipX);
                this.setFlipY(state.flipY)
            },
            init: function() {
                if (!mdiag.ShapeNodeBuilder) {
                    mdiag.ShapeNodeBuilder = new MindFusion.Builder(ShapeNode.prototype, null, this)
                } else {
                    mdiag.ShapeNodeBuilder.setInstance(this)
                }
                return mdiag.ShapeNodeBuilder
            }
        };
        ShapeNode.With = function(diagram) {
            if (!mdiag.ShapeNodeBuilder) {
                mdiag.ShapeNodeBuilder = new MindFusion.Builder(ShapeNode.prototype, diagram)
            } else {
                mdiag.ShapeNodeBuilder.setInstance(null)
            }
            return mdiag.ShapeNodeBuilder
        };
        mdiag.ShapeNodeBuilder = null;
        MindFusion.registerClass(ShapeNode, "MindFusion.Diagramming.ShapeNode", mdiag.DiagramNode)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Shape = MindFusion.Diagramming.Shape;
        var Matrix = MindFusion.Drawing.Matrix;
        var PathParser = MindFusion.Drawing.PathParser;
        var Rect = MindFusion.Drawing.Rect;
        var Path = MindFusion.Drawing.Path;
        var ShapeRenderer = mdiag.ShapeRenderer = function(shape) {
            this.shape = shape;
            this.flipX = false;
            this.flipY = false;
            this.transform = null;
            this.outlinePen = "#000000";
            this.outlineBrush = "#A9A9A9";
            this.decorationPen = "#000000";
            this.decorationBrush = "transparent";
            this.shapeDecorationPen = "#000000";
            this.shapeDecorationBrush = "#000000";
            this.strokeDashStyle = undefined;
            this.strokeThickness = 0;
            this.lineJoin = "miter";
            this.currentPhase = RenderPhase.None;
            this.targetBounds = new Rect(0, 0, 100, 100);
            this.setShapeTransform = false;
            this.pathCopy = this.shape.params.outline;
            this.build()
        };
        ShapeRenderer.prototype = {
            build: function() {
                if (this.shape.params.outline) {
                    this.outlineBounds = this.getEmptyBounds();
                    this.outlineBuilder = []
                }
                if (this.shape.params.decoration) {
                    this.decorationBounds = this.getEmptyBounds();
                    this.decorationBuilder = []
                }
                if (this.shape.params.shapeDecorations) {
                    this.shapeDecorationBounds = [];
                    this.shapeDecorationBuilder = [];
                    for (var i = 0; i < this.shape.params.shapeDecorations.length; i++) {
                        this.shapeDecorationBounds.push(this.getEmptyBounds());
                        this.shapeDecorationBuilder.push([])
                    }
                }
                this.parseAll()
            },
            rebuild: function() {
                delete this.outlineBounds;
                delete this.outlineBuilder;
                delete this.decorationBounds;
                delete this.decorationBuilder;
                delete this.shapeDecorationBounds;
                delete this.shapeDecorationBuilder;
                this.build()
            },
            draw: function(context, drawShadow) {
                this.currentPhase = RenderPhase.None;
                if (this.shape.params.outline) {
                    this.currentPhase = RenderPhase.Outline;
                    context.save();
                    this.addToContext(context);
                    if (this.shadow && drawShadow != false) {
                        this.shadow.apply(context)
                    }
                    context.fillStyle = this.getOutlineBrush(context);
                    context.fill(this.shape.params.fillMode);
                    context.restore();
                    context.strokeStyle = this.getOutlinePen(context);
                    context.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / context._mf_scale;
                    MindFusion.Drawing.DashStyle.apply(context, this.strokeDashStyle);
                    context.lineJoin = this.lineJoin;
                    context.stroke()
                }
                if (this.shape.params.decoration) {
                    this.currentPhase = RenderPhase.Decoration;
                    context.save();
                    this.addToContext(context);
                    context.fillStyle = this.getDecorationBrush(context);
                    context.fill(this.shape.params.fillMode);
                    context.restore();
                    context.strokeStyle = this.getDecorationPen(context);
                    context.lineWidth = this.strokeThickness / context._mf_scale;
                    MindFusion.Drawing.DashStyle.apply(context, this.strokeDashStyle);
                    context.lineJoin = this.lineJoin;
                    context.stroke()
                }
                if (this.shape.params.shapeDecorations) {
                    for (var i = 0; i < this.shape.params.shapeDecorations.length; i++) {
                        var shapeDecoration = this.shape.params.shapeDecorations[i];
                        this.addShapeDecoration(shapeDecoration, context, i)
                    }
                }
                this.currentPhase = RenderPhase.None
            },
            addShapeDecoration: function(shapeDecoration, context, index) {
                this.currentPhase = RenderPhase.ShapeDecoration + index;
                context.save();
                this.addToContext(context);
                context.fillStyle = this.getShapeDecorationBrush(context, index);
                context.fill(shapeDecoration.fillMode || "nonzero");
                context.restore();
                context.strokeStyle = this.getShapeDecorationPen(context, index);
                context.lineWidth = this.strokeThickness / context._mf_scale;
                MindFusion.Drawing.DashStyle.apply(context, (shapeDecoration.pen ? shapeDecoration.pen.dashStyle : this.strokeDashStyle));
                context.lineJoin = this.lineJoin;
                context.stroke();
                this.currentPhase = RenderPhase.None
            },
            drawShadow: function(context) {
                if (this.shadow) {
                    context.save();
                    this.currentPhase = RenderPhase.Shadow;
                    this.addToContext(context);
                    this.shadow.apply(context);
                    context.fillStyle = this.shadow.color;
                    context.fill(this.shape.params.fillMode);
                    context.restore();
                    this.currentPhase = RenderPhase.None
                }
            },
            drawOutline: function(context) {
                this.getOutline().setBrush(this.outlineBrush);
                this.outlinePath.setPen(this.outlinePen);
                this.outlinePath.strokeThickness = this.strokeThickness;
                this.outlinePath.draw(context)
            },
            addToContext: function(context, addTransform) {
                if (addTransform == false) {
                    context.save()
                }
                if (this.transform) {
                    context.transform.apply(context, this.transform.matrix())
                }
                context.beginPath();
                var builder = this.getBuilder();
                if (builder) {
                    for (var i = 0; i < builder.length; i++) {
                        if (builder[i].func == "roundRect") {
                            this.drawRoundRect(context, builder[i])
                        } else {
                            context[builder[i].func].apply(context, builder[i].args)
                        }
                    }
                }
                if (addTransform == false) {
                    context.restore()
                }
            },
            drawRoundRect: function(context, builder) {
                context.save();
                context.transform.apply(context, this.shapeTransform.matrix());
                var bounds = this.targetBounds;
                var x = bounds.x + bounds.width * builder.args[0] / 100;
                var y = bounds.y + bounds.height * builder.args[1] / 100;
                var width = bounds.width * builder.args[2] / 100;
                var height = bounds.height * builder.args[3] / 100;
                var cornerRadius = builder.args[4];
                context.moveTo(x, y + cornerRadius);
                context.lineTo(x, y + height - cornerRadius);
                context.quadraticCurveTo(x, y + height, x + cornerRadius, y + height);
                context.lineTo(x + width - cornerRadius, y + height);
                context.quadraticCurveTo(x + width, y + height, x + width, y + height - cornerRadius);
                context.lineTo(x + width, y + cornerRadius);
                context.quadraticCurveTo(x + width, y, x + width - cornerRadius, y);
                context.lineTo(x + cornerRadius, y);
                context.quadraticCurveTo(x, y, x, y + cornerRadius);
                context.restore()
            },
            updateArrowHeadData: function(bounds, pos, dir) {
                if (bounds.width === 0 || bounds.height === 0) {
                    return
                }
                var outlineBounds = this.shape.defaultBounds;
                var dirVect = mdiag.Utils.subtract(pos, dir);
                var angle = 90 + mdiag.Utils.degrees(Math.atan2(dirVect.y, dirVect.x));
                var sizeScale = bounds.width / 100;
                var matrix = new Matrix();
                matrix.translate(pos.x, pos.y);
                matrix.scale(sizeScale, sizeScale);
                matrix.rotate(angle);
                matrix.translate(-50, 0);
                this.transform = matrix.clone();
                this.getOutline().transform = matrix.clone()
            },
            updateData: function(bounds, rotationAngle) {
                if (bounds.width === 0 || bounds.height === 0) {
                    return
                }
                var outlineBounds = this.shape.defaultBounds;
                var x = bounds.width / outlineBounds.width;
                var y = bounds.height / outlineBounds.height;
                var matrix = new Matrix();
                matrix.translate(bounds.x - bounds.width / 2, bounds.y - bounds.height / 2);
                matrix.scale(x, y);
                matrix.translate(bounds.width / x - outlineBounds.x - outlineBounds.width / 2, bounds.height / y - outlineBounds.y - outlineBounds.height / 2);
                if (this.shape.shapeOrientation > 0) {
                    matrix.rotateAt(this.shape.shapeOrientation, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                if (rotationAngle !== 0) {
                    matrix.rotateAt(rotationAngle, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                if (this.flipX || this.flipY) {
                    matrix.translate(outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2);
                    matrix.scale(this.flipX ? -1 : 1, this.flipY ? -1 : 1);
                    matrix.translate(-(outlineBounds.x + outlineBounds.width / 2), -(outlineBounds.y + outlineBounds.height / 2))
                }
                this.transform = matrix.clone();
                this.getOutline().transform = matrix.clone();
                if (this.setShapeTransform) {
                    var matrix = new Matrix();
                    matrix.scale(1 / x, 1 / y);
                    this.shapeTransform = matrix;
                    this.targetBounds = new Rect(0, 0, bounds.width, bounds.height)
                }
                this.shadow = null;
                this.outlinePen = this.outlinePen || this.shape.params.outlinePen || "#000000";
                this.outlineBrush = this.outlineBrush || this.shape.params.outlineBrush || "#A9A9A9";
                this.decorationPen = this.decorationPen || this.shape.params.decorationPen || "#000000";
                this.decorationBrush = this.decorationBrush || this.shape.params.decorationBrush || "transparent";
                this.shapeDecorationPen = this.shape.params.shapeDecorationPen || "#000000";
                this.shapeDecorationBrush = this.shape.params.shapeDecorationBrush || "#000000"
            },
            prepareCommands: function(pathString) {
                if (pathString != null) {
                    var separators = ["M", "L", "B", "Q", "A", "Z", "C", "E", "R", "U"];
                    var i = 0;
                    while (i < separators.length) {
                        var sep = separators[i];
                        pathString = pathString.replace(new RegExp(sep, "g"), ":" + sep);
                        i++
                    }
                    var cmdStrings = pathString.split(":");
                    return cmdStrings.filter(String)
                }
                return []
            },
            getOutline: function() {
                if (!this.outlinePath) {
                    this.updateOutline()
                }
                return this.outlinePath
            },
            updateOutline: function() {
                this.outlinePath = new Path(this.shape.params.outline || "")
            },
            getBounds: function(renderPhase) {
                var bounds;
                switch (renderPhase) {
                    case RenderPhase.None:
                        return null;
                    case RenderPhase.Shadow:
                    case RenderPhase.Outline:
                        bounds = this.outlineBounds;
                        break;
                    case RenderPhase.Decoration:
                        bounds = this.decorationBounds;
                        break;
                    default:
                        bounds = this.shapeDecorationBounds[renderPhase - RenderPhase.ShapeDecoration];
                        break
                }
                return new Rect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY)
            },
            getEmptyBounds: function() {
                return {
                    minX: Number.MAX_VALUE,
                    minY: Number.MAX_VALUE,
                    maxX: 0,
                    maxY: 0
                }
            },
            expandBounds: function(x, y) {
                var bounds = null;
                switch (this.currentPhase) {
                    case RenderPhase.None:
                        return;
                    case RenderPhase.Shadow:
                    case RenderPhase.Outline:
                        bounds = this.outlineBounds;
                        break;
                    case RenderPhase.Decoration:
                        bounds = this.decorationBounds;
                        break;
                    default:
                        var index = this.currentPhase - RenderPhase.ShapeDecoration;
                        bounds = this.shapeDecorationBounds[index];
                        break
                }
                if (!bounds) {
                    return
                }
                bounds.minX = Math.min(bounds.minX, x);
                bounds.minY = Math.min(bounds.minY, y);
                bounds.maxX = Math.max(bounds.maxX, x);
                bounds.maxY = Math.max(bounds.maxY, y)
            },
            getBuilder: function() {
                switch (this.currentPhase) {
                    case RenderPhase.None:
                        return null;
                    case RenderPhase.Shadow:
                    case RenderPhase.Outline:
                        return this.outlineBuilder;
                    case RenderPhase.Decoration:
                        return this.decorationBuilder;
                    default:
                        return this.shapeDecorationBuilder[this.currentPhase - RenderPhase.ShapeDecoration]
                }
            },
            getOutlineBrush: function(context) {
                return MindFusion.Diagramming.Utils.getBrush(context, this.outlineBrush || "#A9A9A9", this.getBounds(RenderPhase.Outline))
            },
            getOutlinePen: function(context) {
                return MindFusion.Diagramming.Utils.getBrush(context, this.outlinePen || "#000000", this.getBounds(RenderPhase.Outline), true)
            },
            getDecorationBrush: function(context) {
                return MindFusion.Diagramming.Utils.getBrush(context, this.decorationBrush || "transparent", this.getBounds(RenderPhase.Decoration))
            },
            getDecorationPen: function(context) {
                return MindFusion.Diagramming.Utils.getBrush(context, this.decorationPen || "#000000", this.getBounds(RenderPhase.Decoration), true)
            },
            getShapeDecorationBrush: function(context, index) {
                return MindFusion.Diagramming.Utils.getBrush(context, this.shape.params.shapeDecorations[index].brush || this.shapeDecorationBrush || "#000000", this.getBounds(RenderPhase.ShapeDecoration + index))
            },
            getShapeDecorationPen: function(context, index) {
                return MindFusion.Diagramming.Utils.getBrush(context, (this.shape.params.shapeDecorations[index].pen ? this.shape.params.shapeDecorations[index].pen.brush : (this.shapeDecorationPen || "#000000")), this.getBounds(RenderPhase.ShapeDecoration + index), true)
            },
            parseAll: function() {
                this.currentPhase = RenderPhase.None;
                if (this.shape.params.outline) {
                    this.currentPhase = RenderPhase.Outline;
                    this.parse(this.prepareCommands(this.shape.params.outline))
                }
                if (this.shape.params.decoration) {
                    this.currentPhase = RenderPhase.Decoration;
                    this.parse(this.prepareCommands(this.shape.params.decoration))
                }
                if (this.shape.params.shapeDecorations) {
                    for (var i = 0; i < this.shape.params.shapeDecorations.length; i++) {
                        this.currentPhase = RenderPhase.ShapeDecoration + i;
                        this.parse(this.prepareCommands(this.shape.params.shapeDecorations[i].path))
                    }
                }
            },
            setShape: function(shape) {
                this.shape = shape;
                this.rebuild();
                this.updateOutline()
            },
            setFlip: function(flipX, flipY) {
                this.flipX = flipX;
                this.flipY = flipY
            },
            parse: function(commands) {
                PathParser.parse(commands, this)
            },
            moveTo: function(x, y) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "moveTo",
                    args: [x, y]
                });
                this.expandBounds(x, y)
            },
            lineTo: function(x, y) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "lineTo",
                    args: [x, y]
                });
                this.expandBounds(x, y)
            },
            bezierTo: function(x1, y1, x2, y2, x3, y3) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "bezierCurveTo",
                    args: [x1, y1, x2, y2, x3, y3]
                });
                this.expandBounds(x1, y1);
                this.expandBounds(x2, y2);
                this.expandBounds(x3, y3)
            },
            arcTo: function(x, y, radius, startAngle, endAngle, anticlockwise) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "arc",
                    args: [x, y, radius, startAngle, endAngle, anticlockwise]
                });
                var r = +radius;
                this.expandBounds(+x - r, +y - r);
                this.expandBounds(+x + r, +y + r)
            },
            quadraticCurveTo: function(x1, y1, x, y) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "quadraticCurveTo",
                    args: [x1, y1, x, y]
                });
                this.expandBounds(x1, y1);
                this.expandBounds(x, y)
            },
            roundRect: function(x1, y1, x2, y2, cornerRadius) {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "roundRect",
                    args: [x1, y1, x2, y2, cornerRadius]
                });
                this.setShapeTransform = true;
                this.expandBounds(x1, y1);
                this.expandBounds(x2, y2)
            },
            close: function() {
                var builder = this.getBuilder();
                if (!builder) {
                    return
                }
                builder.push({
                    func: "closePath",
                    args: null
                })
            },
            createSvgElement: function(svgdoc) {
                var outline = this.shape.params.outline;
                var decoration = this.shape.params.decoration;
                var shapeDecorations = this.shape.params.shapeDecorations;
                var fillMode = this.shape.params.fillMode;
                var index = outline.search("U[0-9]");
                if (index != -1) {
                    var command = outline.substring(1);
                    var x1 = +command.split(",")[0];
                    var y1 = +command.split(",")[1];
                    var x2 = +command.split(",")[2];
                    var y2 = +command.split(",")[3];
                    var radius = +command.split(",")[4];
                    var width = x2 - x1;
                    var height = y2 - y1;
                    var element = svgdoc.createElementNS("http://www.w3.org/2000/svg", "rect");
                    element.setAttribute("x", x1);
                    element.setAttribute("y", y1);
                    element.setAttribute("width", width);
                    element.setAttribute("height", height);
                    element.setAttribute("rx", radius);
                    element.setAttribute("ry", radius);
                    if (this.transform) {
                        element.setAttribute("transform", this.transform.svgMatrix())
                    }
                    if (fillMode) {
                        element.setAttribute("fill-rule", fillMode)
                    }
                    element.setAttribute("stroke-width", this.strokeThickness ? this.strokeThickness : 1);
                    return element
                }
                var group = svgdoc.createElementNS("http://www.w3.org/2000/svg", "g");
                if (this.transform) {
                    group.setAttribute("transform", this.transform.svgMatrix())
                }
                if (outline) {
                    var outlineElement = svgdoc.createElementNS("http://www.w3.org/2000/svg", "path");
                    outlineElement.setAttribute("d", outline);
                    var outlineBrush = this.getOutlineBrush(null);
                    if (outlineBrush) {
                        outlineElement.setAttribute("fill", outlineBrush)
                    }
                    var outlinePen = this.getOutlinePen(null);
                    if (outlinePen) {
                        outlineElement.setAttribute("stroke", outlinePen)
                    }
                    group.appendChild(outlineElement)
                }
                if (decoration) {
                    var decorationElement = svgdoc.createElementNS("http://www.w3.org/2000/svg", "path");
                    decorationElement.setAttribute("d", decoration);
                    var decorationBrush = this.getDecorationBrush(null);
                    if (decorationBrush) {
                        decorationElement.setAttribute("fill", decorationBrush)
                    }
                    var decorationPen = this.getDecorationPen(null);
                    if (decorationPen) {
                        decorationElement.setAttribute("stroke", decorationPen)
                    }
                    group.appendChild(decorationElement)
                }
                if (shapeDecorations) {
                    if (shapeDecorations.length == 1) {
                        var shapeDecorationsElement = svgdoc.createElementNS("http://www.w3.org/2000/svg", "path");
                        shapeDecorationsElement.setAttribute("d", shapeDecorations[0].path);
                        if (shapeDecorations[0].fillMode) {
                            shapeDecorationsElement.setAttribute("fill-rule", shapeDecorations[0].fillMode)
                        }
                        var shapeDecorationsBrush = this.getShapeDecorationBrush(null, 0);
                        if (shapeDecorationsBrush) {
                            shapeDecorationsElement.setAttribute("fill", shapeDecorationsBrush)
                        }
                        var shapeDecorationsPen = this.getShapeDecorationPen(null, 0);
                        if (shapeDecorationsPen) {
                            shapeDecorationsElement.setAttribute("stroke", shapeDecorationsPen)
                        }
                        group.appendChild(shapeDecorationsElement)
                    } else {
                        var shapeDecorationsGroup = svgdoc.createElementNS("http://www.w3.org/2000/svg", "g");
                        for (var i = 0; i < shapeDecorations.length; i++) {
                            var shapeDecorationsElement = svgdoc.createElementNS("http://www.w3.org/2000/svg", "path");
                            shapeDecorationsElement.setAttribute("d", shapeDecorations[i].path);
                            if (shapeDecorations[i].fillMode) {
                                shapeDecorationsElement.setAttribute("fill-rule", shapeDecorations[i].fillMode)
                            }
                            var shapeDecorationsBrush = this.getShapeDecorationBrush(null, i);
                            var shapeDecorationsPen = this.getShapeDecorationPen(null, i);
                            if (shapeDecorationsBrush) {
                                shapeDecorationsElement.setAttribute("fill", shapeDecorationsBrush)
                            }
                            if (shapeDecorationsPen) {
                                shapeDecorationsElement.setAttribute("stroke", shapeDecorationsPen)
                            }
                            shapeDecorationsGroup.appendChild(shapeDecorationsElement)
                        }
                        group.appendChild(shapeDecorationsGroup)
                    }
                }
                if (fillMode) {
                    group.setAttribute("fill-rule", fillMode)
                }
                var shapeScale = 1;
                if (this.transform) {
                    var m = this.transform.matrix();
                    shapeScale = Math.sqrt(m[0] * m[0] + m[2] * m[2])
                }
                shapeScale *= 4;
                group.setAttribute("id", this.shape.params.id);
                group.setAttribute("stroke-width", this.strokeThickness ? this.strokeThickness / shapeScale : 1 / shapeScale);
                return group
            }
        };
        MindFusion.registerClass(ShapeRenderer, "MindFusion.Diagramming.ShapeRenderer");
        var RenderPhase = {
            None: -1,
            Shadow: 0,
            Outline: 1,
            Decoration: 2,
            ShapeDecoration: 3
        }
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Shapes = function() {};
    MindFusion.Diagramming.Shapes.Actor = function() {
        return MindFusion.Diagramming.Shape.fromId("Actor")
    };
    MindFusion.Diagramming.Shapes.Alternative = function() {
        return MindFusion.Diagramming.Shape.fromId("Alternative")
    };
    MindFusion.Diagramming.Shapes.Arrow = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow")
    };
    MindFusion.Diagramming.Shapes.Arrow1 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow1")
    };
    MindFusion.Diagramming.Shapes.Arrow2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow2")
    };
    MindFusion.Diagramming.Shapes.Arrow3 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow3")
    };
    MindFusion.Diagramming.Shapes.Arrow4 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow4")
    };
    MindFusion.Diagramming.Shapes.Arrow5 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow5")
    };
    MindFusion.Diagramming.Shapes.Arrow6 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow6")
    };
    MindFusion.Diagramming.Shapes.Arrow7 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow7")
    };
    MindFusion.Diagramming.Shapes.Arrow8 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow8")
    };
    MindFusion.Diagramming.Shapes.Arrow9 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow9")
    };
    MindFusion.Diagramming.Shapes.BackSlash = function() {
        return MindFusion.Diagramming.Shape.fromId("BackSlash")
    };
    MindFusion.Diagramming.Shapes.BeginLoop = function() {
        return MindFusion.Diagramming.Shape.fromId("BeginLoop")
    };
    MindFusion.Diagramming.Shapes.BowArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("BowArrow")
    };
    MindFusion.Diagramming.Shapes.BpmnComplex = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnComplex")
    };
    MindFusion.Diagramming.Shapes.BpmnDataBasedXor = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnDataBasedXor")
    };
    MindFusion.Diagramming.Shapes.BpmnEndCancel = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndCancel")
    };
    MindFusion.Diagramming.Shapes.BpmnEndCompensation = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndCompensation")
    };
    MindFusion.Diagramming.Shapes.BpmnEndError = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndError")
    };
    MindFusion.Diagramming.Shapes.BpmnEndLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndLink")
    };
    MindFusion.Diagramming.Shapes.BpmnEndMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnEndMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnEndTerminate = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndTerminate")
    };
    MindFusion.Diagramming.Shapes.BpmnEventBasedXor = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEventBasedXor")
    };
    MindFusion.Diagramming.Shapes.BpmnInclusive = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnInclusive")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateCancel = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateCancel")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateCompensation = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateCompensation")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateError = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateError")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateLink")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateRule = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateRule")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateTimer = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateTimer")
    };
    MindFusion.Diagramming.Shapes.BpmnParallelFork = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnParallelFork")
    };
    MindFusion.Diagramming.Shapes.BpmnStartLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartLink")
    };
    MindFusion.Diagramming.Shapes.BpmnStartMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnStartMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnStartRule = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartRule")
    };
    MindFusion.Diagramming.Shapes.BpmnStartTimer = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartTimer")
    };
    MindFusion.Diagramming.Shapes.Circle = function() {
        return MindFusion.Diagramming.Shape.fromId("Circle")
    };
    MindFusion.Diagramming.Shapes.Cloud = function() {
        return MindFusion.Diagramming.Shape.fromId("Cloud")
    };
    MindFusion.Diagramming.Shapes.Collate = function() {
        return MindFusion.Diagramming.Shape.fromId("Collate")
    };
    MindFusion.Diagramming.Shapes.ConeDown = function() {
        return MindFusion.Diagramming.Shape.fromId("ConeDown")
    };
    MindFusion.Diagramming.Shapes.ConeUp = function() {
        return MindFusion.Diagramming.Shape.fromId("ConeUp")
    };
    MindFusion.Diagramming.Shapes.ConnectedIssues = function() {
        return MindFusion.Diagramming.Shape.fromId("ConnectedIssues")
    };
    MindFusion.Diagramming.Shapes.CreateRequest = function() {
        return MindFusion.Diagramming.Shape.fromId("CreateRequest")
    };
    MindFusion.Diagramming.Shapes.Cross = function() {
        return MindFusion.Diagramming.Shape.fromId("Cross")
    };
    MindFusion.Diagramming.Shapes.Cube = function() {
        return MindFusion.Diagramming.Shape.fromId("Cube")
    };
    MindFusion.Diagramming.Shapes.Cylinder = function() {
        return MindFusion.Diagramming.Shape.fromId("Cylinder")
    };
    MindFusion.Diagramming.Shapes.Database = function() {
        return MindFusion.Diagramming.Shape.fromId("Database")
    };
    MindFusion.Diagramming.Shapes.DataTransmition = function() {
        return MindFusion.Diagramming.Shape.fromId("DataTransmition")
    };
    MindFusion.Diagramming.Shapes.DDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DDelay")
    };
    MindFusion.Diagramming.Shapes.Decision = function() {
        return MindFusion.Diagramming.Shape.fromId("Decision")
    };
    MindFusion.Diagramming.Shapes.Decision2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Decision2")
    };
    MindFusion.Diagramming.Shapes.DefaultFlow = function() {
        return MindFusion.Diagramming.Shape.fromId("DefaultFlow")
    };
    MindFusion.Diagramming.Shapes.Delay = function() {
        return MindFusion.Diagramming.Shape.fromId("Delay")
    };
    MindFusion.Diagramming.Shapes.DInDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DInDelay")
    };
    MindFusion.Diagramming.Shapes.DirectAccessStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("DirectAccessStorage")
    };
    MindFusion.Diagramming.Shapes.DiskStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("DiskStorage")
    };
    MindFusion.Diagramming.Shapes.Display = function() {
        return MindFusion.Diagramming.Shape.fromId("Display")
    };
    MindFusion.Diagramming.Shapes.DividedEvent = function() {
        return MindFusion.Diagramming.Shape.fromId("DividedEvent")
    };
    MindFusion.Diagramming.Shapes.DividedProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("DividedProcess")
    };
    MindFusion.Diagramming.Shapes.Document = function() {
        return MindFusion.Diagramming.Shape.fromId("Document")
    };
    MindFusion.Diagramming.Shapes.DoubleArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("DoubleArrow")
    };
    MindFusion.Diagramming.Shapes.DOutDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DOutDelay")
    };
    MindFusion.Diagramming.Shapes.Ellipse = function() {
        return MindFusion.Diagramming.Shape.fromId("Ellipse")
    };
    MindFusion.Diagramming.Shapes.EndLoop = function() {
        return MindFusion.Diagramming.Shape.fromId("EndLoop")
    };
    MindFusion.Diagramming.Shapes.ExternalOrganization = function() {
        return MindFusion.Diagramming.Shape.fromId("ExternalOrganization")
    };
    MindFusion.Diagramming.Shapes.ExternalProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("ExternalProcess")
    };
    MindFusion.Diagramming.Shapes.File = function() {
        return MindFusion.Diagramming.Shape.fromId("File")
    };
    MindFusion.Diagramming.Shapes.FramedRectangle = function() {
        return MindFusion.Diagramming.Shape.fromId("FramedRectangle")
    };
    MindFusion.Diagramming.Shapes.Gate = function() {
        return MindFusion.Diagramming.Shape.fromId("Gate")
    };
    MindFusion.Diagramming.Shapes.Heart = function() {
        return MindFusion.Diagramming.Shape.fromId("Heart")
    };
    MindFusion.Diagramming.Shapes.Heptagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Heptagon")
    };
    MindFusion.Diagramming.Shapes.Hourglass = function() {
        return MindFusion.Diagramming.Shape.fromId("Hourglass")
    };
    MindFusion.Diagramming.Shapes.Input = function() {
        return MindFusion.Diagramming.Shape.fromId("Input")
    };
    MindFusion.Diagramming.Shapes.InternalStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("InternalStorage")
    };
    MindFusion.Diagramming.Shapes.Interrupt = function() {
        return MindFusion.Diagramming.Shape.fromId("Interrupt")
    };
    MindFusion.Diagramming.Shapes.Interrupt2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Interrupt2")
    };
    MindFusion.Diagramming.Shapes.IsoProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("IsoProcess")
    };
    MindFusion.Diagramming.Shapes.Junction = function() {
        return MindFusion.Diagramming.Shape.fromId("Junction")
    };
    MindFusion.Diagramming.Shapes.Lightning = function() {
        return MindFusion.Diagramming.Shape.fromId("Lightning")
    };
    MindFusion.Diagramming.Shapes.LinedDocument = function() {
        return MindFusion.Diagramming.Shape.fromId("LinedDocument")
    };
    MindFusion.Diagramming.Shapes.ManualOperation = function() {
        return MindFusion.Diagramming.Shape.fromId("ManualOperation")
    };
    MindFusion.Diagramming.Shapes.Merge = function() {
        return MindFusion.Diagramming.Shape.fromId("Merge")
    };
    MindFusion.Diagramming.Shapes.MessageFromUser = function() {
        return MindFusion.Diagramming.Shape.fromId("MessageFromUser")
    };
    MindFusion.Diagramming.Shapes.MessageToUser = function() {
        return MindFusion.Diagramming.Shape.fromId("MessageToUser")
    };
    MindFusion.Diagramming.Shapes.Microform = function() {
        return MindFusion.Diagramming.Shape.fromId("Microform")
    };
    MindFusion.Diagramming.Shapes.MicroformProcessing = function() {
        return MindFusion.Diagramming.Shape.fromId("MicroformProcessing")
    };
    MindFusion.Diagramming.Shapes.MicroformRecording = function() {
        return MindFusion.Diagramming.Shape.fromId("MicroformRecording")
    };
    MindFusion.Diagramming.Shapes.MultiDocument = function() {
        return MindFusion.Diagramming.Shape.fromId("MultiDocument")
    };
    MindFusion.Diagramming.Shapes.MultiProc = function() {
        return MindFusion.Diagramming.Shape.fromId("MultiProc")
    };
    MindFusion.Diagramming.Shapes.Octagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Octagon")
    };
    MindFusion.Diagramming.Shapes.OfflineStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("OfflineStorage")
    };
    MindFusion.Diagramming.Shapes.OffpageConnection = function() {
        return MindFusion.Diagramming.Shape.fromId("OffpageConnection")
    };
    MindFusion.Diagramming.Shapes.OffpageReference = function() {
        return MindFusion.Diagramming.Shape.fromId("OffpageReference")
    };
    MindFusion.Diagramming.Shapes.Or = function() {
        return MindFusion.Diagramming.Shape.fromId("Or")
    };
    MindFusion.Diagramming.Shapes.Pentagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Pentagon")
    };
    MindFusion.Diagramming.Shapes.PentagonArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("PentagonArrow")
    };
    MindFusion.Diagramming.Shapes.PointerArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("PointerArrow")
    };
    MindFusion.Diagramming.Shapes.PrimitiveFromCall = function() {
        return MindFusion.Diagramming.Shape.fromId("PrimitiveFromCall")
    };
    MindFusion.Diagramming.Shapes.PrimitiveToCall = function() {
        return MindFusion.Diagramming.Shape.fromId("PrimitiveToCall")
    };
    MindFusion.Diagramming.Shapes.Procedure = function() {
        return MindFusion.Diagramming.Shape.fromId("Procedure")
    };
    MindFusion.Diagramming.Shapes.Process = function() {
        return MindFusion.Diagramming.Shape.fromId("Process")
    };
    MindFusion.Diagramming.Shapes.Prysm = function() {
        return MindFusion.Diagramming.Shape.fromId("Prysm")
    };
    MindFusion.Diagramming.Shapes.PunchedCard = function() {
        return MindFusion.Diagramming.Shape.fromId("PunchedCard")
    };
    MindFusion.Diagramming.Shapes.PyramidDown = function() {
        return MindFusion.Diagramming.Shape.fromId("PyramidDown")
    };
    MindFusion.Diagramming.Shapes.PyramidUp = function() {
        return MindFusion.Diagramming.Shape.fromId("PyramidUp")
    };
    MindFusion.Diagramming.Shapes.Quill = function() {
        return MindFusion.Diagramming.Shape.fromId("Quill")
    };
    MindFusion.Diagramming.Shapes.Rectangle = function() {
        return MindFusion.Diagramming.Shape.fromId("Rectangle")
    };
    MindFusion.Diagramming.Shapes.Reversed = function() {
        return MindFusion.Diagramming.Shape.fromId("Reversed")
    };
    MindFusion.Diagramming.Shapes.RevTriangle = function() {
        return MindFusion.Diagramming.Shape.fromId("RevTriangle")
    };
    MindFusion.Diagramming.Shapes.RevWithCirc = function() {
        return MindFusion.Diagramming.Shape.fromId("RevWithCirc")
    };
    MindFusion.Diagramming.Shapes.RevWithLine = function() {
        return MindFusion.Diagramming.Shape.fromId("RevWithLine")
    };
    MindFusion.Diagramming.Shapes.Rhombus = function() {
        return MindFusion.Diagramming.Shape.fromId("Rhombus")
    };
    MindFusion.Diagramming.Shapes.RoundRect = function() {
        return MindFusion.Diagramming.Shape.fromId("RoundRect")
    };
    MindFusion.Diagramming.Shapes.RSave = function() {
        return MindFusion.Diagramming.Shape.fromId("RSave")
    };
    MindFusion.Diagramming.Shapes.Save = function() {
        return MindFusion.Diagramming.Shape.fromId("Save")
    };
    MindFusion.Diagramming.Shapes.Slash = function() {
        return MindFusion.Diagramming.Shape.fromId("Slash")
    };
    MindFusion.Diagramming.Shapes.Sort = function() {
        return MindFusion.Diagramming.Shape.fromId("Sort")
    };
    MindFusion.Diagramming.Shapes.Sphere = function() {
        return MindFusion.Diagramming.Shape.fromId("Sphere")
    };
    MindFusion.Diagramming.Shapes.Star = function() {
        return MindFusion.Diagramming.Shape.fromId("Star")
    };
    MindFusion.Diagramming.Shapes.Start = function() {
        return MindFusion.Diagramming.Shape.fromId("Start")
    };
    MindFusion.Diagramming.Shapes.Tape = function() {
        return MindFusion.Diagramming.Shape.fromId("Tape")
    };
    MindFusion.Diagramming.Shapes.Terminator = function() {
        return MindFusion.Diagramming.Shape.fromId("Terminator")
    };
    MindFusion.Diagramming.Shapes.Tetragon = function() {
        return MindFusion.Diagramming.Shape.fromId("Tetragon")
    };
    MindFusion.Diagramming.Shapes.TransmittalTape = function() {
        return MindFusion.Diagramming.Shape.fromId("TransmittalTape")
    };
    MindFusion.Diagramming.Shapes.Triangle = function() {
        return MindFusion.Diagramming.Shape.fromId("Triangle")
    };
    MindFusion.Diagramming.Shapes.RightTriangle = function() {
        return MindFusion.Diagramming.Shape.fromId("RightTriangle")
    };
    MindFusion.Diagramming.Shapes.Decagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Decagon")
    };
    MindFusion.Diagramming.Shapes.Trapezoid = function() {
        return MindFusion.Diagramming.Shape.fromId("Trapezoid")
    };
    MindFusion.Diagramming.Shapes.Star4Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star4Pointed")
    };
    MindFusion.Diagramming.Shapes.Star5Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star5Pointed")
    };
    MindFusion.Diagramming.Shapes.Star6Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star6Pointed")
    };
    MindFusion.Diagramming.Shapes.Star7Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star7Pointed")
    };
    MindFusion.Diagramming.Shapes.Star16Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star16Pointed")
    };
    MindFusion.Diagramming.Shapes.Star24Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star24Pointed")
    };
    MindFusion.Diagramming.Shapes.Star32Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star32Pointed")
    };
    MindFusion.Diagramming.Shapes.Donut = function() {
        return MindFusion.Diagramming.Shape.fromId("Donut")
    };
    MindFusion.Diagramming.Shapes.Plaque = function() {
        return MindFusion.Diagramming.Shape.fromId("Plaque")
    };
    MindFusion.Diagramming.Shapes.prototype = {};
    MindFusion.registerClass(MindFusion.Diagramming.Shapes, "MindFusion.Diagramming.Shapes");
    (function(mdiag) {
        var Style = mdiag.Style = function(prototype) {
            mflayer.initializeBase(Style, this);
            if (prototype) {
                this.brush = prototype.brush;
                this.backBrush = prototype.backBrush;
                this.stroke = prototype.stroke;
                this.strokeThickness = prototype.strokeThickness;
                this.strokeDashStyle = prototype.strokeDashStyle;
                this.textColor = prototype.textColor;
                this.fontName = prototype.fontName;
                this.fontSize = prototype.fontSize;
                this.fontStyle = prototype.fontStyle;
                this.shadowColor = prototype.shadowColor;
                this.nodeEffects = [];
                if (prototype.nodeEffects) {
                    this.nodeEffects = prototype.nodeEffects.slice(0)
                }
                if (prototype.effects) {
                    for (var i = 0, l = prototype.effects.length; i < l; i++) {
                        if (prototype.effects[i] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var type = mflayer.parseType(prototype.effects[i].typeName);
                        if (type) {
                            var effect = new type(this);
                            effect.fromJson(prototype.effects[i]);
                            this.nodeEffects.push(effect)
                        }
                    }
                }
            }
        };
        Style.prototype = {
            getType: function() {
                return this.constructor.__typeName
            },
            fromJson: function(json) {
                this.brush = json.brush;
                this.backBrush = json.backBrush;
                this.stroke = json.stroke;
                this.strokeThickness = json.strokeThickness;
                this.strokeDashStyle = json.strokeDashStyle;
                this.textColor = json.textColor;
                this.fontName = json.fontName;
                this.fontSize = json.fontSize;
                this.fontStyle = json.fontStyle;
                this.shadowColor = json.shadowColor;
                this.nodeEffects = [];
                if (json.effects) {
                    for (var i = 0, l = json.effects.length; i < l; i++) {
                        if (json.effects[i] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var type = mflayer.parseType(json.effects[i].typeName);
                        if (type) {
                            var effect = new type(this);
                            effect.fromJson(json.effects[i]);
                            this.nodeEffects.push(effect)
                        }
                    }
                }
            },
            toJson: function() {
                var json = {
                    brush: this.brush,
                    backBrush: this.backBrush,
                    stroke: this.stroke,
                    strokeThickness: this.strokeThickness,
                    strokeDashStyle: this.strokeDashStyle,
                    textColor: this.textColor,
                    fontName: this.fontName,
                    fontSize: this.fontSize,
                    fontStyle: this.fontStyle,
                    shadowColor: this.shadowColor
                };
                var effects = [];
                if (this.nodeEffects) {
                    for (var i = 0, l = this.nodeEffects.length; i < l; i++) {
                        if (this.nodeEffects[i] == null) {
                            effects.push(null)
                        } else {
                            effects.push(this.nodeEffects[i].toJson())
                        }
                    }
                }
                json.effects = effects;
                return json
            },
            saveToXml: function(xmlElement, context) {
                if (this.hasFontName()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "FontFamily");
                    context.writeString(this.fontName, "Value", propertyElement).setAttribute("Type", "1")
                }
                if (this.hasFontSize()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "FontSize");
                    context.writeFloat(this.fontSize, "Value", propertyElement).setAttribute("Type", "6")
                }
                if (this.hasFontStyle()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "FontStyle");
                    context.writeInt(this.fontStyle, "Value", propertyElement).setAttribute("Type", "8")
                }
                if (this.hasBrush()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "Brush");
                    this.writeBrush(this.brush, propertyElement, context).setAttribute("Type", "100")
                }
                if (this.hasStroke()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "Stroke");
                    this.writeBrush(this.stroke, propertyElement, context).setAttribute("Type", "100")
                }
                if (this.hasStrokeThickness()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "StrokeThickness");
                    context.writeFloat(this.strokeThickness, "Value", propertyElement).setAttribute("Type", "6")
                }
                if (this.hasStrokeDashStyle()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "StrokeDashStyle");
                    context.writeInt(this.strokeDashStyle, "Value", propertyElement).setAttribute("Type", "8")
                }
                if (this.hasShadowColor()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "ShadowBrush");
                    this.writeBrush(this.shadowColor, propertyElement, context).setAttribute("Type", "100")
                }
                if (this.hasTextColor()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "TextBrush");
                    this.writeBrush(this.textColor, propertyElement, context).setAttribute("Type", "100")
                }
                if (this.hasNodeEffects()) {
                    var propertyElement = context.addChildElement("Property", xmlElement);
                    propertyElement.setAttribute("Name", "Effects");
                    this.writeEffects(propertyElement, context)
                }
            },
            loadFromXml: function(xmlElement, context) {
                var propertyElements = xmlElement.getElementsByTagName("Property");
                for (var i = 0; i < propertyElements.length; i++) {
                    var propertyElement = propertyElements[i];
                    var name = propertyElement.getAttribute("Name");
                    switch (name) {
                        case "FontFamily":
                            this.fontName = context.readString("Value", propertyElement);
                            break;
                        case "FontSize":
                            this.fontSize = context.readFloat("Value", propertyElement);
                            break;
                        case "FontStyle":
                            this.fontStyle = context.readInt("Value", propertyElement);
                            break;
                        case "Brush":
                            this.brush = this.readBrush(propertyElement, context);
                            break;
                        case "Stroke":
                            this.stroke = this.readBrush(propertyElement, context);
                            break;
                        case "StrokeThickness":
                            this.strokeThickness = context.readFloat("Value", propertyElement);
                            break;
                        case "StrokeDashStyle":
                            this.strokeDashStyle = context.readInt("Value", propertyElement);
                            break;
                        case "ShadowBrush":
                            this.shadowColor = this.readBrush(propertyElement, context);
                            break;
                        case "TextBrush":
                            this.textColor = this.readBrush(propertyElement, context);
                            break;
                        case "Effects":
                            this.readEffects(propertyElement, context);
                            break
                    }
                }
            },
            writeBrush: function(brush, xmlElement, context) {
                var valueElement = context.addChildElement("Value", xmlElement);
                context.writeBrush(brush, "Brush", valueElement);
                return valueElement
            },
            readBrush: function(xmlElement, context) {
                var valueElement = context.selectSingleNode("Value", xmlElement);
                return context.readBrush("Brush", valueElement)
            },
            writeEffects: function(xmlElement, context) {
                var element = context.addChildElement("Value", xmlElement);
                element.setAttribute("Type", "105");
                var listElement = context.addChildElement("List", element);
                for (var i = 0; i < this.nodeEffects.length; i++) {
                    var itemElement = context.addChildElement("Item", listElement);
                    var valueElement = context.addChildElement("Value", itemElement);
                    valueElement.setAttribute("Type", "103");
                    var nodeEffect = this.nodeEffects[i];
                    context.writeEffect(nodeEffect, "Effect", valueElement)
                }
            },
            readEffects: function(xmlElement, context) {
                this.nodeEffects = [];
                var element = context.selectSingleNode("Value", xmlElement);
                var effectElements = element.getElementsByTagName("Effect");
                for (var i = 0; i < effectElements.length; i++) {
                    var effectElement = effectElements[i];
                    this.nodeEffects.push(context.readEffect(effectElement))
                }
            },
            clone: function() {
                var copy = new this.constructor();
                copy.brush = this.brush;
                copy.backBrush = this.backBrush;
                copy.stroke = this.stroke;
                copy.strokeThickness = this.strokeThickness;
                copy.strokeDashStyle = this.strokeDashStyle;
                copy.textColor = this.textColor;
                copy.fontName = this.fontName;
                copy.fontSize = this.fontSize;
                copy.fontStyle = this.fontStyle;
                copy.shadowColor = this.shadowColor;
                if (this.nodeEffects) {
                    copy.nodeEffects = this.nodeEffects.slice(0)
                }
                return copy
            },
            getBrush: function() {
                return this.brush
            },
            setBrush: function(value) {
                this.brush = value
            },
            hasBrush: function() {
                return this.brush ? true : false
            },
            getBackBrush: function() {
                return this.backBrush
            },
            setBackBrush: function(value) {
                this.backBrush = value
            },
            hasBackBrush: function() {
                return this.backBrush ? true : false
            },
            getStroke: function() {
                return this.stroke
            },
            setStroke: function(value) {
                this.stroke = value
            },
            hasStroke: function() {
                return this.stroke ? true : false
            },
            getStrokeThickness: function() {
                return this.strokeThickness
            },
            setStrokeThickness: function(value) {
                this.strokeThickness = value
            },
            hasStrokeThickness: function() {
                return this.strokeThickness ? true : false
            },
            getStrokeDashStyle: function() {
                return this.strokeDashStyle
            },
            setStrokeDashStyle: function(value) {
                this.strokeDashStyle = value
            },
            hasStrokeDashStyle: function() {
                return this.strokeDashStyle !== undefined && this.strokeDashStyle !== null
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextColor: function(value) {
                this.textColor = value
            },
            hasTextColor: function() {
                return this.textColor ? true : false
            },
            getFontName: function() {
                return this.fontName
            },
            setFontName: function(value) {
                this.fontName = value
            },
            hasFontName: function() {
                return this.fontName ? true : false
            },
            getFontSize: function() {
                return this.fontSize
            },
            setFontSize: function(value) {
                this.fontSize = value
            },
            hasFontSize: function() {
                return this.fontSize ? true : false
            },
            getFontStyle: function() {
                return this.fontStyle
            },
            setFontStyle: function(value) {
                this.fontStyle = value
            },
            hasFontStyle: function() {
                return this.fontStyle !== undefined && this.fontStyle !== null
            },
            getShadowColor: function() {
                return this.shadowColor
            },
            setShadowColor: function(value) {
                this.shadowColor = value
            },
            hasShadowColor: function() {
                return this.shadowColor !== undefined ? true : false
            },
            getNodeEffects: function() {
                return this.nodeEffects
            },
            setNodeEffects: function(value) {
                this.nodeEffects = value
            },
            hasNodeEffects: function() {
                return this.nodeEffects ? true : false
            },
            init: function() {
                if (!mdiag.StyleBuilder) {
                    mdiag.StyleBuilder = new MindFusion.Builder(Style.prototype, null, this)
                } else {
                    mdiag.StyleBuilder.setInstance(this)
                }
                return mdiag.StyleBuilder
            }
        };
        Style.With = function(diagram) {
            if (!mdiag.StyleBuilder) {
                mdiag.StyleBuilder = new MindFusion.Builder(Style.prototype)
            } else {
                mdiag.StyleBuilder.setInstance(null)
            }
            return mdiag.StyleBuilder
        };
        mdiag.StyleBuilder = null;
        MindFusion.registerClass(Style, "MindFusion.Diagramming.Style")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var SvgExporter = mdiag.SvgExporter = function() {};
        SvgExporter.prototype = {
            exportElement: function(diagram, parentDoc) {
                if (!parentDoc) {
                    parentDoc = document
                }
                parentDoc._mf_context = diagram.context;
                var svgElement = parentDoc.createElementNS("http://www.w3.org/2000/svg", "svg");
                svgElement.setAttribute("version", "1.1");
                var db = diagram.getBounds();
                svgElement.setAttribute("width", parseInt(db.width * diagram.scale));
                svgElement.setAttribute("height", parseInt(db.height * diagram.scale));
                var viewbox = "";
                viewbox += db.x + " ";
                viewbox += db.y + " ";
                viewbox += db.width + " ";
                viewbox += db.height;
                svgElement.setAttribute("viewBox", viewbox);
                var defsElement = parentDoc.createElementNS("http://www.w3.org/2000/svg", "defs");
                svgElement.appendChild(defsElement);
                parentDoc._mf_defsElement = defsElement;
                parentDoc._mf_clipCounter = 0;
                var background = diagram.getBounds().clone();
                background.brush = diagram.getBackBrush();
                background.pen = null;
                backgroundElement = background.createSvgElement(parentDoc);
                if (backgroundElement) {
                    svgElement.appendChild(backgroundElement)
                }
                for (var i = 0; i < diagram.items.length; i++) {
                    var item = diagram.items[i];
                    var element = item.graphicsContainer.createSvgElement(parentDoc);
                    if (element != null) {
                        var shapeRenderer = item.shapeRenderer;
                        if (shapeRenderer) {
                            element.setAttribute("fill", shapeRenderer.outlineBrush);
                            element.setAttribute("stroke", shapeRenderer.outlinePen)
                        }
                        svgElement.appendChild(element)
                    }
                }
                delete parentDoc._mf_context;
                delete parentDoc._mf_defsElement;
                delete parentDoc._mf_clipCounter;
                return svgElement
            },
            exportString: function(diagram) {
                var svgdoc = document.implementation.createDocument("", "", null);
                var svgElement = this.exportElement(diagram, svgdoc);
                svgdoc.appendChild(svgElement);
                var xmlString = (new XMLSerializer()).serializeToString(svgdoc);
                return xmlString
            }
        };
        MindFusion.registerClass(SvgExporter, "MindFusion.Diagramming.SvgExporter")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Line = MindFusion.Drawing.Line;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Font = MindFusion.Drawing.Font;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var Utils = MindFusion.Diagramming.Utils;
        var SvgNode = mdiag.SvgNode = function(parent) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(SvgNode, this, [parent]);
            mdiag.Diagram.suppressSetDirty = false
        };
        SvgNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(SvgNode, this, "clone", []);
                copy.setContent(this.getContent());
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(SvgNode, this, "toJson", []);
                var content = this.getContent();
                if (content) {
                    if (content.svgString) {
                        if (this.parent.saveSVG) {
                            json.svgIndex = this.parent.saveSVG(content.svgString)
                        } else {
                            json.svgData = content.svgString
                        }
                    } else {
                        json.contentFile = content.fileName
                    }
                }
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(SvgNode, this, "fromJson", [json]);
                var content = new MindFusion.Diagramming.SvgContent();
                if (json.svgIndex != undefined) {
                    content.svgString = this.parent.svgs[json.svgIndex]
                } else {
                    if (json.contentFile) {
                        content.fileName = json.contentFile
                    } else {
                        if (json.svgData) {
                            content.svgString = json.svgData
                        }
                    }
                }
                this.setContent(content)
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(SvgNode, this, "loadFromXml", [xmlElement, context]);
                var content = new MindFusion.Diagramming.SvgContent();
                var svgData = context.readSvg("Content", xmlElement);
                if (svgData) {
                    content.svgString = Utils.Base64.encode(svgData)
                }
                var svgUrl = context.readString("SvgUrl", xmlElement);
                if (svgUrl) {
                    content.fileName = svgUrl
                }
                this.setContent(content)
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(SvgNode, this, "saveToXml", [xmlElement, context]);
                if (this.content.svgString) {
                    context.writeSvg(Utils.Base64.decode(this.content.svgString), "Content", xmlElement)
                }
                if (this.content.fileName) {
                    context.writeString(this.content.fileName, "SvgUrl", xmlElement)
                }
            },
            setContent: function(value) {
                if (this.content != value) {
                    this.content = value;
                    if (value) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        this.image.svg = true;
                        this.image.image.width = 100;
                        this.image.image.height = 100;
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        if (this.content.svgString) {
                            var url = "data:image/svg+xml;base64," + this.content.svgString;
                            this.image.image.src = url
                        } else {
                            if (this.content.fileName) {
                                this.image.image.src = this.content.fileName
                            }
                        }
                    }
                    this.setDiagramDirty()
                }
            },
            getContent: function() {
                return this.content
            },
            setImageLocation: function(value) {},
            getImageLocation: function() {
                return null
            },
            init: function() {
                if (!mdiag.SvgNodeBuilder) {
                    mdiag.SvgNodeBuilder = new MindFusion.Builder(SvgNode.prototype, null, this)
                } else {
                    mdiag.SvgNodeBuilder.setInstance(this)
                }
                return mdiag.SvgNodeBuilder
            }
        };
        SvgNode.With = function(diagram) {
            if (!mdiag.SvgNodeBuilder) {
                mdiag.SvgNodeBuilder = new MindFusion.Builder(SvgNode.prototype, diagram)
            } else {
                mdiag.SvgNodeBuilder.setInstance(null)
            }
            return mdiag.SvgNodeBuilder
        };
        mdiag.SvgNodeBuilder = null;
        MindFusion.registerClass(SvgNode, "MindFusion.Diagramming.SvgNode", mdiag.ShapeNode);
        var SvgContent = mdiag.SvgContent = function() {};
        SvgContent.prototype = {
            parse: function(value) {
                this.fileName = value
            },
            parseSvg: function(value) {
                this.svgString = value
            },
            fileName: null,
            svgString: null
        };
        MindFusion.registerClass(SvgContent, "MindFusion.Diagramming.SvgContent")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Point = MindFusion.Drawing.Point;
        var TableConnectionPoint = mdiag.TableConnectionPoint = function(node, link, incoming, row) {
            mflayer.initializeBase(TableConnectionPoint, this, [node, link, incoming]);
            this.type = this.constructor.__typeName;
            this.node = node;
            this.link = link;
            this.incoming = incoming;
            this.anchorPointDetails = {
                index: -1,
                point: new MindFusion.Drawing.Point(0, 0)
            };
            if (row === undefined) {
                row = -1
            }
            this.row = row;
            if (row > -1) {
                this.anchorPointDetails.row = node.getRow(row)
            }
        };
        TableConnectionPoint.prototype = {
            addLinkToNode: function() {
                if (!this.anchorPointDetails.row) {
                    if (this.incoming) {
                        this.node.addIncomingLink(this.link)
                    } else {
                        this.node.addOutgoingLink(this.link)
                    }
                } else {
                    if (this.incoming) {
                        this.node.addRowIncomingLink(this.row, this.link)
                    } else {
                        this.node.addRowOutgoingLink(this.row, this.link)
                    }
                }
            },
            removeLinkFromNode: function() {
                if (!this.anchorPointDetails.row) {
                    if (this.incoming) {
                        this.node.removeIncomingLink(this.link)
                    } else {
                        this.node.removeOutgoingLink(this.link)
                    }
                    return
                }
                if (this.incoming) {
                    this.node.removeRowIncomingLink(this.row, this.link)
                } else {
                    this.node.removeRowOutgoingLink(this.row, this.link)
                }
            },
            saveEndRelative: function() {
                var point = this.incoming ? this.link.getEndPoint() : this.link.getStartPoint();
                var angle = this.node.rotationAngle;
                if (angle !== 0) {
                    var pivot = mdiag.Utils.getCenter(this.node.bounds);
                    point = mdiag.Utils.rotatePointAt(point, pivot, -angle)
                }
                var rc = this.anchorPointDetails.row ? this.node.getRowRect(this.row) : this.node.bounds;
                this.relativePosition = mdiag.Utils.getRectPtPercent(point, rc)
            },
            getNearestBorderPoint: function(point) {
                var row = this.node.connectionStyle != mdiag.ConnectionStyle.Node ? this.node.rowFromPoint(point) : -1;
                if (row == -1) {
                    return mflayer.callBaseMethod(TableConnectionPoint, this, "getNearestBorderPoint", [point])
                }
                this.row = row;
                var rect = this.node.getRowRect(row);
                var cx = rect.x + rect.width / 2;
                var cy = rect.y + rect.height / 2;
                var pointDetails = {
                    row: this.node.getRow(row),
                    point: point.x > cx ? new Point(rect.right(), cy) : new Point(rect.left(), cy),
                    location: point.x > cx ? new Point(100, 50) : new Point(0, 50),
                    index: -1
                };
                return pointDetails
            },
            alignEndPointToBorder: function(point) {
                if (this.anchorPointDetails && this.anchorPointDetails.row) {
                    var bounds = this.node.getBounds();
                    var rowCenter = this.node.getRowRect(this.row).center();
                    if (point.x < rowCenter.x) {
                        this.anchorPointDetails.point = new Point(bounds.x, rowCenter.y)
                    } else {
                        this.anchorPointDetails.point = new Point(bounds.right(), rowCenter.y)
                    }
                } else {
                    mflayer.callBaseMethod(TableConnectionPoint, this, "alignEndPointToBorder", [point])
                }
            },
            linkChanges: function(item, point) {
                if (item == this.node) {
                    return this.node.rowFromPoint(point) != this.row
                }
                return mflayer.callBaseMethod(TableConnectionPoint, this, "linkChanges", [item, point])
            },
            rowObject: function() {
                if (this.anchorPointDetails && this.anchorPointDetails.row) {
                    return this.anchorPointDetails.row
                }
                return null
            },
            getInitialPoint: function() {
                return this.anchorPointDetails.row ? this.node.getRowRect(this.row).center() : mflayer.callBaseMethod(TableConnectionPoint, this, "getInitialPoint", [])
            },
            getIntersection: function(point1, point2) {
                var t = this.node;
                if (this.row != -1) {
                    return t.getRowIntersection(this.row, point1, point2)
                }
                return t.getIntersection(point1, point2)
            },
            getEndPoint: function() {
                var percentPoint = this.relativePosition;
                var rc = this.anchorPointDetails.row ? this.node.getRowRect(this.row) : this.node.bounds;
                var point = mdiag.Utils.rectPtFromPercent(percentPoint, rc);
                point.x = Math.min(point.x, this.node.bounds.right());
                point.y = Math.min(point.y, this.node.bounds.bottom());
                var angle = this.node.rotationAngle;
                if (angle !== 0) {
                    var pivot = mdiag.Utils.getCenter(this.node.bounds);
                    point = mdiag.Utils.rotatePointAt(point, pivot, angle)
                }
                return point
            },
            setRow: function(value, updateObjects) {
                if (this.row != value) {
                    if (updateObjects) {
                        this.removeLinkFromNode()
                    }
                    this.row = value;
                    this.anchorPointDetails.row = this.node.getRow(value);
                    if (updateObjects) {
                        this.addLinkToNode();
                        if (this.incoming) {
                            this.link.updateDestinationIntersection()
                        } else {
                            this.link.updateOriginIntersection()
                        }
                    }
                }
            }
        };
        MindFusion.registerClass(TableConnectionPoint, "MindFusion.Diagramming.TableConnectionPoint", mdiag.ConnectionPoint)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Line = MindFusion.Drawing.Line;
        var Border3D = MindFusion.Drawing.Border3D;
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var Font = MindFusion.Drawing.Font;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Path = MindFusion.Drawing.Path;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var Size = MindFusion.Drawing.Size;
        var FitSize = MindFusion.Diagramming.FitSize;
        var TableNode = mdiag.TableNode = function(parent) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(TableNode, this, [parent]);
            this.captionHeight = 6;
            this.text.fitInBounds = true;
            this.text.lineAlignment = mdiag.Alignment.Center;
            this.cells = new MindFusion.Collections.Grid(1, 1);
            this.rows = [this.createRow()];
            this.columns = [this.createColumn()];
            this.currentScrollRow = 0;
            this.connectionStyle = mdiag.ConnectionStyle.Rows;
            mdiag.Diagram.suppressSetDirty = false;
            this.cellFrameStyle = mdiag.CellFrameStyle.Simple;
            this.allowResizeColumns = false;
            this.allowResizeRows = false
        };
        TableNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(TableNode, this, "clone", []);
                copy.captionHeight = this.captionHeight;
                copy.currentScrollRow = this.currentScrollRow;
                copy.connectionStyle = this.connectionStyle;
                copy.captionBackBrush = this.captionBackBrush;
                copy.captionFont = this.captionFont;
                copy.setScrollable(this.getScrollable());
                copy.shape = this.shape;
                copy.cellFrameStyle = this.cellFrameStyle;
                copy.setEnableStyledText(this.getEnableStyledText());
                copy.allowResizeColumns = this.allowResizeColumns;
                copy.allowResizeRows = this.allowResizeRows;
                copy.cells = this.cells.clone();
                copy.rows = this.rows.slice(0);
                for (var r = 0; r < copy.rows.length; r++) {
                    var row = copy.rows[r];
                    if (row) {
                        copy.rows[r] = this.copyRow(row)
                    }
                }
                copy.columns = this.columns.slice(0);
                for (var c = 0; c < copy.columns.length; c++) {
                    var column = copy.columns[c];
                    if (column) {
                        copy.columns[c] = this.copyColumn(column)
                    }
                }
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(TableNode, this, "toJson", []);
                json.captionHeight = this.captionHeight;
                json.currentScrollRow = this.currentScrollRow;
                json.connectionStyle = this.connectionStyle;
                json.captionBackBrush = this.captionBackBrush;
                json.captionFont = this.captionFont;
                json.scrollable = this.getScrollable();
                json.cellFrameStyle = this.cellFrameStyle;
                json.enableStyledText = this.getEnableStyledText();
                json.allowResizeColumns = this.getAllowResizeColumns();
                json.allowResizeRows = this.getAllowResizeRows();
                json.shape = this.shape;
                json.rows = [];
                for (var r = 0; r < this.cells.rows; r++) {
                    var row = this.getRow(r);
                    json.rows[r] = {
                        height: row.height
                    }
                }
                json.columns = [];
                for (var c = 0; c < this.cells.columns; c++) {
                    var column = this.getColumn(c);
                    json.columns[c] = this.copyColumn(column)
                }
                json.cells = [];
                for (var r = 0; r < this.cells.rows; r++) {
                    for (var c = 0; c < this.cells.columns; c++) {
                        json.cells.push(this.getCell(c, r).toJson())
                    }
                }
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(TableNode, this, "fromJson", [json]);
                this.captionHeight = json.captionHeight;
                this.currentScrollRow = json.currentScrollRow;
                this.connectionStyle = json.connectionStyle;
                this.captionBackBrush = json.captionBackBrush;
                if (json.captionFont) {
                    this.captionFont = Font.copy(json.captionFont)
                }
                this.setScrollable(json.scrollable);
                if (json.cellFrameStyle !== undefined) {
                    this.cellFrameStyle = json.cellFrameStyle
                }
                this.setEnableStyledText(json.enableStyledText);
                if (json.allowResizeColumns) {
                    this.setAllowResizeColumns(json.allowResizeColumns)
                }
                if (json.allowResizeRows) {
                    this.setAllowResizeRows(json.allowResizeRows)
                }
                if (json.shape) {
                    this.setShape(json.shape)
                }
                this.rows = [];
                for (var r = 0; r < json.rows.length; r++) {
                    this.rows[r] = this.copyRow(json.rows[r])
                }
                this.columns = [];
                for (var c = 0; c < json.columns.length; c++) {
                    this.columns[c] = this.copyColumn(json.columns[c])
                }
                this.cells = new MindFusion.Collections.Grid(json.columns.length, json.rows.length);
                var cell = 0;
                for (var r = 0; r < this.cells.rows; r++) {
                    for (var c = 0; c < this.cells.columns; c++) {
                        this.getCell(c, r).fromJson(json.cells[cell++])
                    }
                }
            },
            loadFromXml: function(xmlElement, context) {
                mflayer.callBaseMethod(TableNode, this, "loadFromXml", [xmlElement, context]);
                if (this.getText() == "") {
                    this.setText(context.readString("Caption", xmlElement))
                }
                this.setEnableStyledText(context.readBool("EnableStyledText", xmlElement));
                this.captionHeight = context.readFloat("CaptionHeight", xmlElement);
                this.captionBackBrush = context.readBrush("CaptionBackBrush", xmlElement);
                var legacyCaptionFormat = context.readStringFormat("CaptionFormat", xmlElement);
                if (legacyCaptionFormat) {
                    this.setTextAlignment(legacyCaptionFormat.alignment);
                    this.setLineAlignment(legacyCaptionFormat.lineAlignment)
                } else {
                    this.setTextAlignment(context.readInt("TextAlignment", xmlElement));
                    this.setLineAlignment(context.readInt("TextVerticalAlignment", xmlElement))
                }
                this.shape = context.readInt("Shape", xmlElement, mdiag.SimpleShape.Rectangle);
                this.connectionStyle = context.readInt("ConnectionStyle", xmlElement, this.connectionStyle);
                this.cellFrameStyle = context.readInt("CellFrameStyle", xmlElement, this.cellFrameStyle);
                this.currentScrollRow = context.readInt("CurrentScrollRow", xmlElement);
                this.setScrollable(context.readBool("Scrollable", xmlElement));
                this.setAllowResizeColumns(context.readBool("AllowResizeColumns", xmlElement));
                this.setAllowResizeRows(context.readBool("AllowResizeRows", xmlElement));
                var rowElements = xmlElement.getElementsByTagName("Row");
                var columnElements = xmlElement.getElementsByTagName("Column");
                var cellElements = xmlElement.getElementsByTagName("Cell");
                if (rowElements.length * columnElements.length != cellElements.length) {
                    throw new Exception("The number of cell elements does not match the number of rows and columns in the table.")
                }
                this.redimTable(columnElements.length, rowElements.length);
                for (var i = 0; i < rowElements.length; ++i) {
                    this.getRow(i).height = context.readFloat("Height", rowElements[i])
                }
                for (var i = 0; i < columnElements.length; ++i) {
                    this.getColumn(i).width = context.readFloat("Width", columnElements[i]);
                    this.getColumn(i).columnStyle = context.readInt("ColumnStyle", columnElements[i])
                }
                var c = 0;
                for (var i = 0; i < rowElements.length; ++i) {
                    for (var j = 0; j < columnElements.length; ++j) {
                        var cell = this.getCell(j, i);
                        cell.loadFromXml(cellElements[c++], context)
                    }
                }
            },
            saveToXml: function(xmlElement, context) {
                mflayer.callBaseMethod(TableNode, this, "saveToXml", [xmlElement, context]);
                context.writeBool(this.getEnableStyledText(), "EnableStyledText", xmlElement);
                context.writeFloat(this.captionHeight, "CaptionHeight", xmlElement);
                context.writeBrush(this.captionBackBrush, "CaptionBackBrush", xmlElement);
                context.writeInt(this.getTextAlignment(), "TextAlignment", xmlElement);
                context.writeInt(this.getLineAlignment(), "TextVerticalAlignment", xmlElement);
                context.writeInt(this.shape, "Shape", xmlElement);
                context.writeInt(this.connectionStyle, "ConnectionStyle", xmlElement);
                context.writeInt(this.cellFrameStyle, "CellFrameStyle", xmlElement);
                context.writeInt(this.currentScrollRow, "CurrentScrollRow", xmlElement);
                context.writeBool(this.getScrollable(), "Scrollable", xmlElement);
                context.writeBool(this.getAllowResizeColumns(), "AllowResizeColumns", xmlElement);
                context.writeBool(this.getAllowResizeRows(), "AllowResizeRows", xmlElement);
                var cellsElement = context.addChildElement("Cells", xmlElement);
                for (var i = 0; i < this.rows.length; i++) {
                    for (var j = 0; j < this.columns.length; j++) {
                        var cellElement = context.addChildElement("Cell", cellsElement);
                        var cell = this.getCell(j, i);
                        cell.saveToXml(cellElement, context)
                    }
                }
                var rowsElement = context.addChildElement("Rows", xmlElement);
                for (var i = 0; i < this.rows.length; i++) {
                    var rowElement = context.addChildElement("Row", rowsElement);
                    var row = this.getRow(i);
                    context.writeFloat(row.height, "Height", rowElement)
                }
                var columnsElement = context.addChildElement("Columns", xmlElement);
                for (var i = 0; i < this.columns.length; i++) {
                    var columnElement = context.addChildElement("Column", columnsElement);
                    var column = this.getColumn(i);
                    context.writeFloat(column.width, "Width", columnElement);
                    context.writeInt(column.columnStyle, "ColumnStyle", columnElement)
                }
            },
            getCell: function(col, row) {
                var cell = this.cells.get(col, row);
                if (!cell) {
                    cell = this.createCell();
                    this.cells.set(col, row, cell)
                }
                return cell
            },
            createCell: function() {
                var cell = new mdiag.Cell();
                cell.parent = this;
                return cell
            },
            getRow: function(row) {
                if (row >= this.rows.length) {
                    return undefined
                }
                var rowObj = this.rows[row];
                if (!rowObj) {
                    rowObj = this.createRow();
                    this.rows[row] = rowObj
                }
                return rowObj
            },
            setRowHeight: function(row, value) {
                var rowIndex;
                if (typeof row === "number") {
                    rowIndex = row;
                    row = this.getRow(row)
                }
                if (row.height == value) {
                    return
                }
                row.height = value;
                this.updateLinksPos(rowIndex || ArrayList.indexOf(this.rows, row));
                this.invalidate()
            },
            createRow: function() {
                return {
                    height: 6,
                    incomingLinks: [],
                    outgoingLinks: []
                }
            },
            copyRow: function(row) {
                return {
                    height: row.height,
                    incomingLinks: [],
                    outgoingLinks: []
                }
            },
            getColumn: function(col) {
                var colObj = this.columns[col];
                if (!colObj) {
                    colObj = this.createColumn();
                    this.columns[col] = colObj
                }
                return colObj
            },
            setColumnWidth: function(col, value) {
                if (typeof col === "number") {
                    col = this.getColumn(col)
                }
                if (col.width == value) {
                    return
                }
                col.width = value;
                this.calcAutoWidths();
                this.invalidate()
            },
            setColumnStyle: function(col, value) {
                if (typeof col === "number") {
                    col = this.getColumn(col)
                }
                if (col.columnStyle == value) {
                    return
                }
                col.columnStyle = value;
                this.calcAutoWidths();
                this.invalidate()
            },
            createColumn: function() {
                return {
                    width: 18,
                    columnStyle: mdiag.ColumnStyle.FixedWidth
                }
            },
            copyColumn: function(column) {
                return {
                    width: column.width,
                    columnStyle: column.columnStyle
                }
            },
            setParent: function(value) {
                this.parent = value;
                for (var r = 0; r < this.cells.rows; r++) {
                    for (var c = 0; c < this.cells.columns; c++) {
                        this.getCell(c, r).parent.parent = value
                    }
                }
            },
            containsPoint: function(point) {
                var bounds = this.getRotatedBounds();
                if (!bounds.containsPoint(point)) {
                    return false
                }
                if (mdiag.Utils.pointInPolygon(point, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(point)) {
                    return true
                }
                return false
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var p = [];
                p.push(this.bounds.topLeft());
                p.push(this.bounds.topRight());
                p.push(this.bounds.bottomRight());
                p.push(this.bounds.bottomLeft());
                mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.bounds), this.rotationAngle);
                return p
            },
            updateCanvasElements: function() {
                if (this.updateScrollerContent) {
                    this.updateScrollerContent = false;
                    if (this.scroller) {
                        this.scroller.updateContent()
                    }
                }
                var content = this.graphicsContainer.content = [];
                var stroke = this.getEffectiveStroke();
                var thickness = this.getEffectiveStrokeThickness();
                var dashStyle = this.getEffectiveStrokeDashStyle();
                var brush = this.getEffectiveBrush();
                var params = {
                    brush: brush,
                    phase: EffectPhase.BeforeFill
                };
                this.applyEffects(content, params);
                if (params.brush) {
                    brush = params.brush
                }
                this.graphicsContainer.rotationAngle = this.rotationAngle;
                this.graphicsContainer.pivot = this.bounds.center();
                var rect = this.bounds.clone();
                var frame = rect;
                if (this.shape == mdiag.SimpleShape.RoundedRectangle) {
                    var mm = GraphicsUnit.getMillimeter(this.parent.measureUnit);
                    var cornerRadius = mm * 2.5;
                    frame = new Path();
                    frame.addRoundRect(rect, cornerRadius);
                    frame.done()
                }
                var back = frame.clone();
                back.pen = null;
                back.brush = brush;
                back.shadow = this.createShadow();
                content.push(back);
                rect = rect.clone();
                rect.height = this.captionHeight;
                if (this.captionBackBrush) {
                    var captionFill = rect.clone();
                    captionFill.brush = this.captionBackBrush;
                    captionFill.pen = null;
                    if (this.shape == mdiag.SimpleShape.RoundedRectangle) {
                        var clipped = new MindFusion.Drawing.Container();
                        clipped.clip = frame;
                        clipped.content.push(captionFill);
                        content.push(clipped)
                    } else {
                        content.push(captionFill)
                    }
                }
                this.applyEffects(content, {
                    phase: EffectPhase.AfterFill
                });
                this.text.setBounds(rect, 0);
                this.text.font = this.captionFont ? this.captionFont : this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.ignoreTransform = this.rotationAngle != 0;
                content.push(this.text);
                var body = new MindFusion.Drawing.Container();
                body.clip = frame;
                content.push(body);
                var rows = this.cells.rows;
                var cols = this.cells.columns;
                var y = rect.bottom();
                var spansMarked = false;
                var styled = this.getEnableStyledText();
                this.calcAutoWidths();
                for (var r = this.currentScrollRow; r < rows; r++) {
                    var rowHeight = this.getRow(r).height;
                    var lastRow = r == rows - 1 || y + rowHeight > this.bounds.bottom();
                    var x = rect.x;
                    for (var c = 0; c < cols; c++) {
                        var lastColumn = c == cols - 1;
                        var cell = this.getCell(c, r);
                        var colWidth = this.getColumn(c).width;
                        if (colWidth <= 0) {
                            continue
                        }
                        var spanningCell = cell.columnSpan > 1 || cell.rowSpan > 1;
                        if (spanningCell && !spansMarked) {
                            this.markCoveredCells();
                            spansMarked = true
                        }
                        if (lastColumn) {
                            colWidth += rect.right() - (x + colWidth)
                        }
                        var cellRect = new Rect(x, y, colWidth, rowHeight);
                        if (spanningCell) {
                            var cellSize = this.getSpanningCellSize(c, r);
                            cellRect.width = cellSize.width;
                            cellRect.height = cellSize.height
                        }
                        x += colWidth;
                        var renderCell = !(spansMarked && cell.covered);
                        if (renderCell) {
                            if (cell.brush) {
                                var cellFill = cellRect.clone();
                                cellFill.pen = null;
                                cellFill.brush = cell.brush;
                                body.content.push(cellFill)
                            }
                            var image = cell.image;
                            if (image) {
                                var paddedRect = cellRect.clone();
                                if (cell.imagePadding) {
                                    cell.imagePadding.applyTo(paddedRect)
                                }
                                image.setBounds(paddedRect, 0);
                                image.imageAlign = cell.getImageAlign();
                                body.content.push(image)
                            }
                            if (cell.text) {
                                cell.text.setBounds(cellRect);
                                cell.text.font = cell.font ? cell.font : this.getEffectiveFont();
                                cell.text.fitInBounds = true;
                                cell.text.pen = cell.textColor ? cell.textColor : this.getEffectiveTextColor();
                                cell.text.stroke = this.getEffectiveTextStroke();
                                cell.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                                cell.text.ignoreTransform = this.rotationAngle != 0;
                                cell.text.enableStyledText = styled;
                                cell.text.clipToBounds = styled;
                                body.content.push(cell.text)
                            }
                            if (this.cellFrameStyle == mdiag.CellFrameStyle.Simple) {
                                if (!lastColumn) {
                                    var vBorder = new Line(cellRect.right(), cellRect.y, cellRect.right(), cellRect.bottom());
                                    vBorder.setPen(stroke);
                                    vBorder.strokeDashStyle = dashStyle;
                                    body.content.push(vBorder)
                                }
                                var hBorder = new Line(cellRect.x, cellRect.bottom(), cellRect.right(), cellRect.bottom());
                                hBorder.setPen(stroke);
                                hBorder.strokeDashStyle = dashStyle;
                                body.content.push(hBorder)
                            }
                            if (this.cellFrameStyle == mdiag.CellFrameStyle.System3D) {
                                var border = new Border3D(cellRect);
                                body.content.push(border)
                            }
                        }
                        if (x > rect.right()) {
                            break
                        }
                    }
                    y += rowHeight;
                    if (y > this.bounds.bottom()) {
                        break
                    }
                }
                frame.pen = stroke;
                frame.strokeThickness = thickness;
                frame.strokeDashStyle = dashStyle;
                frame.brush = null;
                content.push(frame);
                rect = this.bounds;
                if (this.captionHeight > 0 && this.captionHeight < rect.height) {
                    var y = rect.y + this.captionHeight;
                    var line = new Line(rect.x, y, rect.right(), y);
                    line.setPen(stroke);
                    line.strokeThickness = thickness;
                    line.strokeDashStyle = dashStyle;
                    if (this.shape == mdiag.SimpleShape.RoundedRectangle && (y < cornerRadius || y > rect.height - cornerRadius)) {
                        line.clipPath = frame
                    }
                    content.push(line)
                }
                this.addManipulatorVisuals(content);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            setShape: function(value) {
                if (this.shape != value) {
                    this.shape = value;
                    this.invalidate()
                }
            },
            getShape: function() {
                if (this.shape === undefined) {
                    return mdiag.SimpleShape.Rectangle
                }
                return this.shape
            },
            setCaptionHeight: function(value) {
                if (this.captionHeight != value) {
                    this.captionHeight = value;
                    this.invalidate()
                }
            },
            getCaptionHeight: function() {
                return this.captionHeight
            },
            setCellFrameStyle: function(value) {
                if (this.cellFrameStyle != value) {
                    this.cellFrameStyle = value;
                    this.invalidate()
                }
            },
            getCellFrameStyle: function() {
                return this.cellFrameStyle
            },
            setConnectionStyle: function(value) {
                if (this.connectionStyle != value) {
                    this.connectionStyle = value;
                    this.invalidate()
                }
            },
            getConnectionStyle: function() {
                return this.connectionStyle
            },
            redimTable: function(columns, rows) {
                if (rows < this.rows.length) {
                    this.deleteRowLinks(rows, this.rows.length - 1)
                }
                this.cells.resize(columns, rows);
                this.rows.length = rows;
                this.columns.length = columns;
                this.updateScrollerContent = true;
                this.invalidate()
            },
            getRowCount: function() {
                return this.cells.rows
            },
            setRowCount: function(value) {
                if (value < 0) {
                    return
                }
                if (this.cells.rows == value) {
                    return
                }
                var oldCols = this.cells.columns;
                this.redimTable(oldCols, value)
            },
            getColumnCount: function() {
                return this.cells.columns
            },
            setColumnCount: function(value) {
                if (value < 0) {
                    return
                }
                if (this.cells.columns == value) {
                    return
                }
                var oldRows = this.cells.rows;
                this.redimTable(value, oldRows)
            },
            deleteColumn: function(col) {
                this.cells.deleteColumn(col);
                this.columns.splice(col, 1);
                this.invalidate()
            },
            insertColumn: function(col) {
                var newColumn = this.createColumn();
                this.cells.insertColumn(col);
                this.columns.splice(col, 0, newColumn);
                this.invalidate();
                return newColumn
            },
            deleteRow: function(row) {
                if (row >= this.rows.length) {
                    return
                }
                this.deleteRowLinks(row, row);
                this.cells.deleteRow(row);
                this.rows.splice(row, 1);
                this.updateLinksIndices(row);
                this.updateLinksPos(row);
                this.invalidate()
            },
            insertRow: function(row) {
                var newRow = this.createRow();
                this.cells.insertRow(row);
                this.rows.splice(row, 0, newRow);
                this.updateLinksIndices(row);
                this.updateLinksPos(row);
                this.updateScrollerContent = true;
                this.invalidate();
                return newRow
            },
            addColumn: function() {
                return this.insertColumn(this.cells.columns)
            },
            addRow: function() {
                return this.insertRow(this.cells.rows)
            },
            deleteRowLinks: function(from, to) {
                if (this.parent) {
                    var links = [];
                    for (var r = from; r <= to; r++) {
                        var row = this.rows[r];
                        if (!row) {
                            continue
                        }
                        this.copyLinks(row.incomingLinks, links);
                        this.copyLinks(row.outgoingLinks, links)
                    }
                    var parent = this.parent;
                    ArrayList.forEach(links, function(link) {
                        parent.removeItem(link)
                    })
                }
            },
            getScrollable: function() {
                return this.scroller ? true : false
            },
            setScrollable: function(value) {
                var scrollable = this.getScrollable();
                if (scrollable == value) {
                    return
                }
                if (value) {
                    this.scroller = this.useScrollBars ? new mdiag.ScrollBar(this) : new mdiag.Scroller(this);
                    this.addManipulator(this.scroller)
                } else {
                    this.removeManipulator(this.scroller);
                    delete this.scroller
                }
                this.invalidate()
            },
            canScrollUp: function() {
                return this.currentScrollRow > 0
            },
            canScrollDown: function() {
                return this.currentScrollRow < this.cells.rows - 1
            },
            onUpdateBounds: function() {
                mflayer.callBaseMethod(TableNode, this, "onUpdateBounds", []);
                if (this.scroller) {
                    this.scroller.updateContent()
                }
            },
            createConnectionPoint: function(link, point, incoming, ignoreRows) {
                var row = ignoreRows ? undefined : this.rowFromPoint(point);
                var cp = new mdiag.TableConnectionPoint(this, link, incoming, row);
                if (cp.anchorPointDetails.row) {
                    cp.saveEndRelative()
                } else {
                    cp.anchorPointDetails.anchorPattern = this.anchorPattern;
                    cp.anchorPointDetails.point = point
                }
                return cp
            },
            addRowIncomingLink: function(row, link) {
                var rowObj = this.getRow(row);
                if (!rowObj) {
                    return
                }
                var links = rowObj.incomingLinks;
                if (!ArrayList.contains(links, link)) {
                    links.push(link)
                }
            },
            addRowOutgoingLink: function(row, link) {
                var rowObj = this.getRow(row);
                if (!rowObj) {
                    return
                }
                var links = rowObj.outgoingLinks;
                if (!ArrayList.contains(links, link)) {
                    links.push(link)
                }
            },
            removeRowIncomingLink: function(row, link) {
                var rowObj = this.getRow(row);
                if (!rowObj) {
                    return
                }
                var links = rowObj.incomingLinks;
                ArrayList.remove(links, link)
            },
            removeRowOutgoingLink: function(row, link) {
                var rowObj = this.getRow(row);
                if (!rowObj) {
                    return
                }
                var links = rowObj.outgoingLinks;
                ArrayList.remove(links, link)
            },
            copyLinks: function(src, dest) {
                ArrayList.forEach(src, function(link) {
                    if (!ArrayList.contains(dest, link)) {
                        dest.push(link)
                    }
                })
            },
            getAllIncomingLinks: function(links) {
                mflayer.callBaseMethod(TableNode, this, "getAllIncomingLinks", [links]);
                for (var i = 0; i < this.rows.length; i++) {
                    var row = this.getRow(i);
                    this.copyLinks(row.incomingLinks, links)
                }
            },
            getAllOutgoingLinks: function(links) {
                mflayer.callBaseMethod(TableNode, this, "getAllOutgoingLinks", [links]);
                for (var i = 0; i < this.rows.length; i++) {
                    var row = this.getRow(i);
                    this.copyLinks(row.outgoingLinks, links)
                }
            },
            getRowRect: function(row) {
                var rc = this.bounds.clone();
                if (row < this.currentScrollRow) {
                    rc.height = this.captionHeight;
                    return rc
                }
                var rowY = this.bounds.y;
                rowY += this.captionHeight;
                for (var i = this.currentScrollRow; i < row; i++) {
                    rowY += this.getRow(i).height
                }
                return new Rect(rc.x, rowY, rc.width, this.getRow(row).height)
            },
            rowFromPoint: function(point) {
                var y = point.y - this.bounds.y;
                if (this.bounds.height < y || this.rows.length == 0) {
                    return -1
                }
                var h = this.captionHeight;
                if (y < this.captionHeight) {
                    return this.currentScrollRow
                }
                for (var i = this.currentScrollRow; i < this.rows.length; ++i) {
                    h += this.getRow(i).height;
                    if (y < h) {
                        return i
                    }
                }
                return this.rows.length - 1
            },
            getRowIntersection: function(nRow, org, end) {
                var pt = this.getRowRect(nRow).center();
                var mid = new Point((end.x + org.x) / 2, (end.y + org.y) / 2);
                pt.x = pt.x < mid.x ? this.bounds.right() : this.bounds.left();
                return pt
            },
            updateLinksPos: function(firstRow) {
                for (var r = firstRow; r < this.rows.length; ++r) {
                    var row = this.getRow(r);
                    ArrayList.forEach(row.incomingLinks, function(link) {
                        link.updatePosFromOrgAndDest();
                        if (link.autoRoute) {
                            link.route()
                        }
                    });
                    ArrayList.forEach(row.outgoingLinks, function(link) {
                        link.updatePosFromOrgAndDest();
                        if (link.autoRoute) {
                            link.route()
                        }
                    })
                }
            },
            updateLinksIndices: function(start) {
                for (var r = start; r < this.rows.length; ++r) {
                    var row = this.getRow(r);
                    ArrayList.forEach(row.incomingLinks, function(link) {
                        link.destinationConnection.row = r
                    });
                    ArrayList.forEach(row.outgoingLinks, function(link) {
                        link.originConnection.row = r
                    })
                }
            },
            setCurrScrollRow: function(row) {
                if (row < 0) {
                    return
                }
                if (row >= this.rows.length) {
                    return
                }
                this.currentScrollRow = row;
                if (this.scroller) {
                    this.scroller.updateContent()
                }
                this.updateLinksPos(0);
                this.updateScrollerContent = true;
                this.invalidate()
            },
            scrollDown: function() {
                this.setCurrScrollRow(this.currentScrollRow + 1);
                this.invalidate()
            },
            scrollUp: function() {
                this.setCurrScrollRow(this.currentScrollRow - 1);
                this.invalidate(this)
            },
            calcAutoWidths: function() {
                var autoColumns = 0;
                var fixedSpace = 0;
                for (var c = 0; c < this.columns.length; c++) {
                    var column = this.getColumn(c);
                    var style = column.columnStyle;
                    if (style == mdiag.ColumnStyle.AutoWidth) {
                        autoColumns++
                    } else {
                        fixedSpace += column.width
                    }
                }
                if (autoColumns == 0) {
                    return
                }
                var autoWidth = (this.bounds.width - fixedSpace) / autoColumns;
                for (var c = 0; c < this.columns.length; c++) {
                    var column = this.getColumn(c);
                    if (column.columnStyle == mdiag.ColumnStyle.AutoWidth) {
                        column.width = autoWidth
                    }
                }
            },
            markCoveredCells: function() {
                var cols = this.cells.columns;
                var rows = this.cells.rows;
                for (var r = rows - 1; r >= 0; r--) {
                    for (var c = cols - 1; c >= 0; c--) {
                        var cell = this.getCell(c, r);
                        var colSpan = cell.columnSpan;
                        if (!colSpan) {
                            colSpan = 1
                        }
                        var rowSpan = cell.rowSpan;
                        if (!rowSpan) {
                            rowSpan = 1
                        }
                        cell.covered = false;
                        if (colSpan <= 1 && rowSpan <= 1) {
                            continue
                        }
                        for (var rr = r; rr < r + rowSpan; rr++) {
                            for (var cc = c; cc < c + colSpan; cc++) {
                                if (r == rr && c == cc) {
                                    continue
                                }
                                var cell2 = this.getCell(cc, rr);
                                cell2.covered = true
                            }
                        }
                    }
                }
            },
            getSpanningCellSize: function(col, row) {
                var cell = this.getCell(col, row);
                var columnSpan = cell.columnSpan;
                if (!columnSpan) {
                    columnSpan = 1
                }
                var width = 0;
                for (var c = col; c < col + columnSpan; c++) {
                    width += this.getColumn(c).width
                }
                if (c == this.cells.columns) {
                    var total = 0;
                    for (var c = 0; c < this.cells.columns; c++) {
                        total += this.getColumn(c).width
                    }
                    width += this.bounds.width - total
                }
                var rowSpan = cell.rowSpan;
                if (!rowSpan) {
                    rowSpan = 1
                }
                var height = 0;
                for (var r = row; r < row + rowSpan; r++) {
                    height += this.getRow(r).height
                }
                return {
                    width: width,
                    height: height
                }
            },
            cellFromPoint: function(point) {
                point = this.removeRotation(point);
                var rect = this.bounds.clone();
                rect.height = this.captionHeight;
                var rows = this.cells.rows;
                var cols = this.cells.columns;
                var y = rect.bottom();
                var spansMarked = false;
                this.calcAutoWidths();
                for (var r = this.currentScrollRow; r < rows; r++) {
                    var rowHeight = this.getRow(r).height;
                    var lastRow = r == rows - 1 || y + rowHeight > this.bounds.bottom();
                    var x = rect.x;
                    for (var c = 0; c < cols; c++) {
                        var lastColumn = c == cols - 1;
                        var cell = this.getCell(c, r);
                        var colWidth = this.getColumn(c).width;
                        if (colWidth <= 0) {
                            continue
                        }
                        var spanningCell = cell.columnSpan > 1 || cell.rowSpan > 1;
                        if (spanningCell && !spansMarked) {
                            this.markCoveredCells();
                            spansMarked = true
                        }
                        if (lastColumn) {
                            colWidth += rect.right() - (x + colWidth)
                        }
                        var cellRect = new Rect(x, y, colWidth, rowHeight);
                        if (spanningCell) {
                            var cellSize = this.getSpanningCellSize(c, r);
                            cellRect.width = cellSize.width;
                            cellRect.height = cellSize.height
                        }
                        x += colWidth;
                        if (cellRect.containsPoint(point)) {
                            return {
                                cell: cell,
                                cellRect: cellRect,
                                column: c,
                                row: r
                            }
                        }
                        if (x > rect.right()) {
                            break
                        }
                    }
                    y += rowHeight;
                    if (y > this.bounds.bottom()) {
                        break
                    }
                }
                return null
            },
            getObjectToEdit: function(point) {
                var cellInfo = this.cellFromPoint(point);
                if (cellInfo) {
                    return new mdiag.CellEditor(this, cellInfo)
                }
                return this
            },
            getEditRect: function(point) {
                var rect = this.bounds.clone();
                rect.height = this.captionHeight;
                if (this.rotationAngle == 0) {
                    return rect
                } else {
                    var matrix = this.rotateRect(this.bounds.clone());
                    return matrix.transformRect(rect)
                }
            },
            setCaptionBackBrush: function(value) {
                if (this.captionBackBrush !== value) {
                    this.captionBackBrush = value;
                    this.invalidate()
                }
            },
            getCaptionBackBrush: function() {
                return this.captionBackBrush
            },
            setCaptionFont: function(value) {
                if (this.captionFont !== value) {
                    this.captionFont = value;
                    this.invalidate()
                }
            },
            getCaptionFont: function() {
                return this.captionFont
            },
            setEnableStyledText: function(value) {
                if (this.text.enableStyledText != value) {
                    this.text.enableStyledText = value;
                    this.invalidate()
                }
            },
            getEnableStyledText: function() {
                return this.text.enableStyledText
            },
            resolveInheritedStyle: function(check, theme) {
                var nodeStyle = theme.styles["std:TableNode"];
                if (nodeStyle) {
                    if (check.apply(nodeStyle)) {
                        return nodeStyle
                    }
                }
                return mflayer.callBaseMethod(TableNode, this, "resolveInheritedStyle", [check, theme])
            },
            getColumnRect: function(col) {
                var rc = this.bounds.clone();
                if (col >= this.columns.length) {
                    return rc
                }
                var w = rc.left();
                for (var i = 0; i < col; ++i) {
                    var c = this.getColumn(i);
                    w += c.width
                }
                rc.x = w;
                rc.width = this.getColumn(col).width;
                return rc
            },
            hitTestManipulators: function(mousePosition) {
                var manipulator = mflayer.callBaseMethod(TableNode, this, "hitTestManipulators", [mousePosition]);
                if (manipulator != null) {
                    return manipulator
                }
                var rc = mdiag.Utils.normalizeRect(this.bounds);
                var resizerSize = GraphicsUnit.getMillimeter(this.parent.measureUnit) * (this.cellFrameStyle == mdiag.CellFrameStyle.System3D ? 2 : 1);
                if (this.getRotationAngle() != 0) {
                    mousePosition = mdiag.Utils.rotatePointAt(mousePosition, this.bounds.center(), -this.getRotationAngle())
                }
                if (this.allowResizeColumns) {
                    for (var i = 0; i < this.cells.columns - 1; i++) {
                        var colRect = this.getColumnRect(i);
                        if (colRect.left() >= rc.right()) {
                            break
                        }
                        var resizerRect = colRect.clone();
                        resizerRect.width = resizerSize;
                        resizerRect.x = colRect.right() - resizerRect.width / 2;
                        resizerRect.y += this.getCaptionHeight();
                        var h = 0;
                        for (var j = this.rows.length - 1; j >= 0; j--) {
                            h = this.getRowRect(j).bottom();
                            if (h != 0) {
                                break
                            }
                        }
                        if (h != 0) {
                            resizerRect.height = Math.min(colRect.bottom(), h) - resizerRect.y
                        }
                        if (resizerRect.containsPoint(mousePosition)) {
                            return new mdiag.ColumnResizer(this, i)
                        }
                    }
                }
                if (this.allowResizeRows) {
                    for (var i = this.currentScrollRow; i < this.cells.rows; i++) {
                        var rowRect = this.getRowRect(i);
                        if (rowRect.top() >= rc.bottom()) {
                            break
                        }
                        var resizerRect = rowRect.clone();
                        resizerRect.height = resizerSize;
                        resizerRect.y = rowRect.bottom() - resizerRect.height / 2;
                        if (resizerRect.containsPoint(mousePosition)) {
                            return new mdiag.RowResizer(this, i)
                        }
                    }
                }
                return null
            },
            getAllowResizeColumns: function() {
                return this.allowResizeColumns
            },
            setAllowResizeColumns: function(value) {
                if (value != this.allowResizeColumns) {
                    this.allowResizeColumns = value
                }
            },
            getAllowResizeRows: function() {
                return this.allowResizeRows
            },
            setAllowResizeRows: function(value) {
                if (value != this.allowResizeRows) {
                    this.allowResizeRows = value
                }
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(TableNode, this, "saveState", []);
                state.captionHeight = this.captionHeight;
                state.currentScrollRow = this.currentScrollRow;
                state.connectionStyle = this.connectionStyle;
                state.captionBackBrush = this.captionBackBrush;
                state.captionFont = this.captionFont;
                state.scrollable = this.getScrollable();
                state.allowResizeColumns = this.allowResizeColumns;
                state.allowResizeRows = this.allowResizeRows;
                state.cells = this.cells.clone();
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(TableNode, this, "restoreState", [state]);
                this.captionHeight = state.captionHeight;
                this.currentScrollRow = state.currentScrollRow;
                this.connectionStyle = state.connectionStyle;
                this.captionBackBrush = state.captionBackBrush;
                this.captionFont = state.captionFont;
                this.setScrollable(state.scrollable);
                this.setAllowResizeColumns(state.allowResizeColumns);
                this.setAllowResizeRows(state.allowResizeRows);
                this.cells = state.cells
            },
            useScrollBars: false,
            init: function() {
                if (!mdiag.TableNodeBuilder) {
                    mdiag.TableNodeBuilder = new MindFusion.Builder(TableNode.prototype, null, this)
                } else {
                    mdiag.TableNodeBuilder.setInstance(this)
                }
                return mdiag.TableNodeBuilder
            },
            resizeToFitText: function(ignoreCaption, keepCellWidth) {
                if (this.cells.columns === 0 || this.cells.rows === 0) {
                    return
                }
                var text;
                var font = this.getEffectiveFont();
                var styled;
                var rc;
                var cellSizes = [];
                for (var column = 0; column < this.cells.columns; ++column) {
                    cellSizes.push([]);
                    for (var row = 0; row < this.cells.rows; ++row) {
                        text = this.getCell(column, row).getText();
                        rc = new Rect(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
                        var tsize = this.parent.measureString(text, font, rc, styled);
                        if (this.getCell(column, row).getColumnSpan() == 1) {
                            if (tsize.width != 0) {
                                this.getCell(column, row).text.padding.addToRect(tsize);
                                tsize.width += this.getCell(column, row).text.padding.right + 1
                            }
                            cellSizes[column].push(new Size(tsize.width, tsize.height))
                        }
                    }
                }
                var tableWidth = 0;
                var AllColumnWidths = [];
                for (var column = 0; column < this.columns.length; ++column) {
                    var maxWidth = 0;
                    for (var row = 0; row < this.rows.length; ++row) {
                        if (cellSizes[column][row]) {
                            if (maxWidth < cellSizes[column][row].width) {
                                maxWidth = cellSizes[column][row].width
                            }
                        }
                    }
                    AllColumnWidths.push(maxWidth);
                    this.getColumn(column).width = maxWidth;
                    tableWidth += maxWidth
                }
                for (var column = 0; column < this.columns.length; ++column) {
                    for (var row = 0; row < this.rows.length; ++row) {
                        if (this.getCell(column, row).getColumnSpan() > 1) {
                            var sizeOfColumnSpan = 0;
                            var n = this.getCell(column, row).getColumnSpan();
                            for (var c = column; c <= column + n - 1; c++) {
                                sizeOfColumnSpan += AllColumnWidths[c];
                                this.getCell(c, row).text.padding
                            }
                            text = this.getCell(column, row).getText();
                            var tsize = this.parent.measureString(text, font, undefined, styled);
                            this.getCell(column, row).text.padding.addToRect(tsize);
                            if (sizeOfColumnSpan < tsize.width) {
                                var oldWidth = AllColumnWidths[column + n - 1];
                                tableWidth -= oldWidth;
                                AllColumnWidths[column + n - 1] = tsize.width - (sizeOfColumnSpan - oldWidth) + this.getCell(column, row).text.padding.left + this.getCell(column, row).text.padding.right + 1;
                                tableWidth += AllColumnWidths[column + n - 1];
                                this.getColumn(column + n - 1).width = AllColumnWidths[column + n - 1]
                            }
                        }
                    }
                }
                var tableHeight = 0;
                for (var row = 0; row < this.rows.length; ++row) {
                    var maxHeight = 0;
                    for (var column = 0; column < this.cells.columns; ++column) {
                        if (maxHeight < this.rows[0].height) {
                            maxHeight = this.rows[0].height
                        }
                    }
                    this.rows.height = maxHeight;
                    tableHeight += maxHeight
                }
                if (!ignoreCaption) {}
                tableHeight += this.getCaptionHeight();
                this.bounds = new Rect(this.bounds.x, this.bounds.y, tableWidth, tableHeight);
                if (this.scroller) {
                    this.scroller.updateContent()
                }
                this.updateCanvasElements()
            }
        };
        TableNode.With = function(diagram) {
            if (!mdiag.TableNodeBuilder) {
                mdiag.TableNodeBuilder = new MindFusion.Builder(TableNode.prototype, diagram)
            } else {
                mdiag.TableNodeBuilder.setInstance(null)
            }
            return mdiag.TableNodeBuilder
        };
        mdiag.TableNodeBuilder = null;
        MindFusion.registerClass(TableNode, "MindFusion.Diagramming.TableNode", mdiag.DiagramNode)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Dictionary = MindFusion.Collections.Dictionary;
        var Theme = mdiag.Theme = function() {
            mflayer.initializeBase(Theme, this);
            this.styles = {}
        };
        Theme.prototype = {
            fromJson: function(json) {
                if (json.linkStyle) {
                    var linkStyle = new mdiag.Style(json.linkStyle);
                    this.styles["std:DiagramLink"] = linkStyle
                }
                if (json.nodeStyle) {
                    var nodeStyle = new mdiag.Style(json.nodeStyle);
                    this.styles["std:DiagramNode"] = nodeStyle
                }
                if (json.containerStyle) {
                    var containerStyle = new mdiag.Style(json.containerStyle);
                    this.styles["std:ContainerNode"] = containerStyle
                }
                if (json.shapeStyle) {
                    var shapeStyle = new mdiag.Style(json.shapeStyle);
                    this.styles["std:ShapeNode"] = shapeStyle
                }
                if (json.tableStyle) {
                    var tableStyle = new mdiag.Style(json.tableStyle);
                    this.styles["std:TableNode"] = tableStyle
                }
                if (json.freeformStyle) {
                    var freeformStyle = new mdiag.Style(json.freeformStyle);
                    this.styles["std:FreeFormNode"] = freeformStyle
                }
                if (json.diagramStyle) {
                    var diagramStyle = new mdiag.Style(json.diagramStyle);
                    this.styles["std:Diagram"] = diagramStyle
                }
            },
            toJson: function() {
                return {
                    linkStyle: this.styles["std:DiagramLink"] ? this.styles["std:DiagramLink"].toJson() : null,
                    nodeStyle: this.styles["std:DiagramNode"] ? this.styles["std:DiagramNode"].toJson() : null,
                    containerStyle: this.styles["std:ContainerNode"] ? this.styles["std:ContainerNode"].toJson() : null,
                    shapeStyle: this.styles["std:ShapeNode"] ? this.styles["std:ShapeNode"].toJson() : null,
                    tableStyle: this.styles["std:TableNode"] ? this.styles["std:TableNode"].toJson() : null,
                    freeformStyle: this.styles["std:FreeFormNode"] ? this.styles["std:FreeFormNode"].toJson() : null,
                    diagramStyle: this.styles["std:Diagram"] ? this.styles["std:Diagram"].toJson() : null
                }
            },
            saveToXml: function(element, context) {
                for (var classId in this.styles) {
                    if (this.styles.hasOwnProperty(classId)) {
                        var styleElement = context.addChildElement("Style", element);
                        styleElement.setAttribute("TargetType", classId);
                        context.writeStyleContent(styleElement, this.styles[classId], classId + "Style")
                    }
                }
            },
            loadFromXml: function(element, context) {
                this.styles = {};
                for (var i = 0; i < element.childNodes.length; i++) {
                    var styleElement = element.childNodes[i];
                    if (styleElement.nodeType !== 1) {
                        continue
                    }
                    var targetType = styleElement.getAttribute("TargetType");
                    var style = context.readStyleContent(styleElement);
                    this.styles[targetType] = style
                }
            }
        };
        (function initDefault() {
            Theme.Default = new Theme();
            var defaultStyles = Theme.Default.styles;
            var whiteBrush = "white";
            var blackBrush = "black";
            var shapeBrush = "rgb(220, 220, 255)";
            var tableBrush = "rgb(180, 160, 160)";
            var diagBrush = "rgb(170, 170, 200)";
            var baseStyle = new mdiag.Style();
            baseStyle.setBrush(whiteBrush);
            baseStyle.setStroke(blackBrush);
            baseStyle.setStrokeThickness(0);
            baseStyle.setTextColor(blackBrush);
            baseStyle.setFontName("sans-serif");
            baseStyle.setFontSize(4);
            baseStyle.setShadowColor("gray");
            var linkStyle = new mdiag.Style(baseStyle);
            defaultStyles["std:DiagramLink"] = linkStyle;
            var nodeStyle = new mdiag.Style(baseStyle);
            defaultStyles["std:DiagramNode"] = nodeStyle;
            var containerStyle = new mdiag.Style(baseStyle);
            defaultStyles["std:ContainerNode"] = containerStyle;
            var shapeStyle = new mdiag.Style(baseStyle);
            shapeStyle.setBrush(shapeBrush);
            defaultStyles["std:ShapeNode"] = shapeStyle;
            var freeformStyle = new mdiag.Style(baseStyle);
            freeformStyle.setBrush(shapeBrush);
            defaultStyles["std:FreeFormNode"] = freeformStyle;
            var tableStyle = new mdiag.Style(baseStyle);
            tableStyle.setBrush(tableBrush);
            defaultStyles["std:TableNode"] = tableStyle;
            var diagramStyle = new mdiag.Style(baseStyle);
            diagramStyle.setBackBrush(diagBrush);
            defaultStyles["std:Diagram"] = diagramStyle
        })();
        MindFusion.registerClass(Theme, "MindFusion.Diagramming.Theme")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Point = MindFusion.Drawing.Point;
        var Rect = MindFusion.Drawing.Rect;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Font = MindFusion.Drawing.Font;
        var Thickness = MindFusion.Drawing.Thickness;
        var Size = MindFusion.Drawing.Size;
        var Dictionary = MindFusion.Collections.Dictionary;
        var XmlPersistContext = mdiag.XmlPersistContext = function(diagram, document) {
            this.diagram = diagram;
            this.document = document;
            this.items = [];
            this.brushes = [];
            this.images = [];
            this.styles = [];
            this.svgs = [];
            this.effects = [];
            this.brushesMap = new Dictionary();
            this.imagesMap = new Dictionary();
            this.stylesMap = new Dictionary();
            this.svgsMap = new Dictionary();
            this.effectsMap = new Dictionary()
        };
        XmlPersistContext.prototype = {
            saveItemToXml: function(item, collectionElement, elementName) {
                var element = this.document.createElement(elementName);
                collectionElement.appendChild(element);
                var classDesc = item.constructor.xmlInfo;
                if (classDesc != null) {
                    element.setAttribute("Class", classDesc.classId);
                    element.setAttribute("Id", item.instanceId.toString());
                    element.setAttribute("Version", classDesc.classVersion.toString());
                    item.saveToXml(element, this)
                } else {
                    throw new Error("Item cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            saveHeaderToXml: function(header, collectionElement, elementName) {
                var element = this.document.createElement(elementName);
                collectionElement.appendChild(element);
                var classDesc = header.constructor.xmlInfo;
                if (classDesc != null) {
                    element.setAttribute("Class", classDesc.classId);
                    element.setAttribute("Version", classDesc.classVersion.toString());
                    header.saveToXml(element, this)
                } else {
                    throw new Error("Header cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            addChildElement: function(elementName, parentElement, innerText) {
                var element = this.document.createElement(elementName);
                parentElement.appendChild(element);
                if (hasValue(innerText)) {
                    element.appendChild(this.document.createTextNode(innerText))
                }
                return element
            },
            instantiateItem: function(classId, element) {
                var type = mdiag.Diagram.xmlClassMap[classId];
                if (!type) {
                    throw new Error("Item classId [" + classId + "] is not registered.")
                }
                if (mflayer.inheritsFrom(type, mdiag.DiagramNode)) {
                    var item = new type(this.diagram)
                } else {
                    if (type == mdiag.DiagramLink || mflayer.inheritsFrom(type, mdiag.DiagramLink)) {
                        var originElement = element.getElementsByTagName("Origin")[0];
                        var destElement = element.getElementsByTagName("Destination")[0];
                        var origin = this.items[parseInt(originElement.getAttribute("Id"))];
                        var dest = this.items[parseInt(destElement.getAttribute("Id"))];
                        var item = new type(this.diagram, origin, dest)
                    }
                }
                item.setParent(this.diagram);
                return item
            },
            instantiateObject: function(classId) {
                switch (classId) {
                    case "std:Header":
                        return new mdiag.Lanes.Header();
                    default:
                        return null
                }
            },
            instantiateEffect: function(classId) {
                switch (classId) {
                    case "std:GlassEffect":
                        var effect = new mdiag.GlassEffect();
                        break;
                    case "std:AeroEffect":
                        var effect = new mdiag.AeroEffect();
                        break;
                    default:
                        return null
                }
                return effect
            },
            loadItemFromXml: function(itemElement) {
                var classId = itemElement.getAttribute("Class");
                var id = parseInt(itemElement.getAttribute("Id"));
                var version = parseInt(itemElement.getAttribute("Version"));
                if (this.items[id] !== undefined) {
                    var item = this.items[id]
                } else {
                    var item = this.instantiateItem(classId, itemElement);
                    this.items[id] = item
                }
                this.classVersion = version;
                item.loadFromXml(itemElement, this);
                return item
            },
            loadHeaderFromXml: function(headerElement) {
                var header = null;
                if (!headerElement.hasAttribute("Class")) {
                    header = new mdiag.Lanes.Header()
                } else {
                    var classId = headerElement.getAttribute("Class");
                    var version = 1;
                    if (headerElement.hasAttribute("Version")) {
                        varsion = parseInt(headerElement.getAttribute("Version"))
                    }
                    header = this.instantiateObject(classId);
                    this.classVersion = version
                }
                header.loadFromXml(headerElement, this);
                return header
            },
            writeItemReference: function(item, elementName, parentElement) {
                if (item == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                element.setAttribute("Id", item.instanceId.toString());
                var classDesc = item.constructor.xmlInfo;
                element.setAttribute("ClassId", classDesc.classId);
                element.setAttribute("Version", classDesc.classVersion.toString());
                return element
            },
            readItemReference: function(itemElement) {
                var id = parseInt(itemElement.getAttribute("Id"));
                var item = this.items[id];
                if (item) {
                    return item
                }
                var classId = itemElement.getAttribute("ClassId");
                var item = this.instantiateItem(classId, itemElement);
                this.items[id] = item;
                return item
            },
            writeResources: function(parentElement) {
                if (!this.inplaceResources) {
                    var element = this.addChildElement("Resources", parentElement);
                    this.writeBrushes(element);
                    this.writeImages(element);
                    this.writeEffects(element);
                    this.writeStyles(element);
                    this.writeSvgs(element)
                }
            },
            readResources: function(parentElement) {
                var resources = selectSingleNode("Resources", parentElement);
                if (resources) {
                    this.readBrushes(resources);
                    this.readImages(resources);
                    this.readEffects(resources);
                    this.readStyles(resources);
                    this.readSvgs(resources)
                }
            },
            writeResource: function(resObject, elementName, parentElement, contentWriter, resMap) {
                if (resObject == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                if (this.inplaceResources) {
                    contentWriter.apply(this, [element, resObject]);
                    return element
                }
                var index = resMap.getCount();
                if (resMap.contains(resObject)) {
                    index = resMap.get(resObject)
                } else {
                    resMap.set(resObject, index)
                }
                element.setAttribute("Id", index.toString());
                return element
            },
            writeBrushes: function(parentElement) {
                if (this.inplaceResources) {
                    return
                }
                var element = this.addChildElement("Brushes", parentElement);
                this.brushesMap.forEach(function(brush, index) {
                    var brushElement = this.addChildElement("Brush", element);
                    brushElement.setAttribute("Index", index);
                    this.writeBrushContent(brushElement, brush)
                }, this)
            },
            readBrushes: function(parentElement) {
                var element = selectSingleNode("Brushes", parentElement);
                if (!element) {
                    throw new Error("Brushes section not found.")
                }
                var brushElements = element.getElementsByTagName("Brush");
                for (var i = 0; i < brushElements.length; i++) {
                    var brushElement = brushElements[i];
                    var index = parseInt(brushElement.getAttribute("Index"));
                    var brush = this.readBrushContent(brushElement);
                    this.brushes[index] = brush
                }
            },
            writeBrush: function(brush, elementName, parentElement) {
                return this.writeResource(brush, elementName, parentElement, this.writeBrushContent, this.brushesMap)
            },
            readBrush: function(elementName, parentElement, defaultValue) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                if (!element.hasAttribute("Id") || this.inplaceResources) {
                    return this.readBrushContent(element)
                }
                var index = parseInt(element.getAttribute("Id"));
                return this.brushes[index]
            },
            writeBrushContent: function(brushElement, brush) {
                if (brush.type === "SolidBrush" || typeof brush === "string") {
                    brushElement.setAttribute("Type", "Solid");
                    this.writeColor(brush.type === "SolidBrush" ? brush.color : brush, "Color", brushElement)
                } else {
                    if (brush.type === "LinearGradientBrush") {
                        brushElement.setAttribute("Type", "Gradient");
                        this.writeFloat(brush.angle, "Angle", brushElement);
                        if (brush.colorStops.length == 2) {
                            this.writeColor(brush.colorStops[0].color, "Color1", brushElement);
                            this.writeColor(brush.colorStops[1].color, "Color2", brushElement)
                        } else {
                            var colorsElement = this.addChildElement("ColorBlend", brushElement);
                            var colors = [],
                                positions = [];
                            for (var i = 0; i < brush.colorStops.length; i++) {
                                position[i] = brush.colorStops[i].position;
                                colors[i] = brush.colorStops[i].color
                            }
                            this.writeFloatArray(positions, "Positions", "Pos", colorsElement);
                            this.writeColorArray(colors, "Colors", "Color", colorsElement)
                        }
                    }
                }
            },
            readBrushContent: function(brushElement) {
                var brush = "rgba(255, 0, 0, 0.4)";
                var type = brushElement.getAttribute("Type");
                switch (type) {
                    case "Solid":
                        brush = this.readColor("Color", brushElement);
                        break;
                    case "Gradient":
                        brush = {
                            type: "LinearGradientBrush",
                            colorStops: []
                        };
                        brush.angle = this.readFloat("Angle", brushElement);
                        var colorsElement = selectSingleNode("ColorBlend", brushElement);
                        if (colorsElement) {
                            var positions = this.readFloatArray("Positions", "Pos", colorsElement);
                            var colors = this.readColorArray("Colors", "Color", colorsElement);
                            if (positions && colors) {
                                for (var i = 0; i < positions.length; i++) {
                                    brush.colorStops.push({
                                        position: positions[i],
                                        color: colors[i]
                                    })
                                }
                            }
                        } else {
                            var c1 = this.readColor("Color1", brushElement);
                            var c2 = this.readColor("Color2", brushElement);
                            brush.colorStops.push({
                                position: 0,
                                color: c1
                            });
                            brush.colorStops.push({
                                position: 1,
                                color: c2
                            })
                        }
                        break
                }
                return brush
            },
            writeImages: function(parentElement) {
                if (this.inplaceResources) {
                    return
                }
                var element = this.addChildElement("Images", parentElement);
                element.setAttribute("Count", this.imagesMap.getCount());
                this.imagesMap.forEach(function(imageContent, index) {
                    var imageElement = this.addChildElement("Image", element, imageContent);
                    imageElement.setAttribute("Index", index.toString())
                }, this)
            },
            readImages: function(parentElement) {
                var element = selectSingleNode("Images", parentElement);
                if (!element) {
                    throw new Error("Images section not found.")
                }
                var imageElements = element.getElementsByTagName("Image");
                for (var i = 0; i < imageElements.length; i++) {
                    var imageElement = imageElements[i];
                    var index = parseInt(imageElement.getAttribute("Index"));
                    var image = this.innerText(imageElement);
                    if (image) {
                        this.images[index] = image
                    }
                }
            },
            writeImage: function(image, elementName, parentElement) {
                return this.writeResource(image, elementName, parentElement, this.writeImageContent, this.imagesMap)
            },
            readImage: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var index = parseInt(element.getAttribute("Id"));
                return this.images[index]
            },
            writeStyles: function(parentElement) {
                if (this.inplaceResources) {
                    return
                }
                var element = this.addChildElement("Styles", parentElement);
                this.stylesMap.forEach(function(style, index) {
                    var styleElement = this.addChildElement("Style", element);
                    if (index >= 0) {
                        styleElement.setAttribute("Index", index.toString())
                    }
                    this.writeStyleContent(styleElement, style)
                }, this)
            },
            readStyles: function(parentElement) {
                var element = selectSingleNode("Styles", parentElement);
                if (!element) {
                    return
                }
                var styleElements = element.getElementsByTagName("Style");
                for (var i = 0; i < styleElements.length; i++) {
                    var styleElement = styleElements[i];
                    var index = parseInt(styleElement.getAttribute("Index"));
                    var style = new mdiag.Style();
                    style.loadFromXml(styleElement, this);
                    this.styles[index] = style
                }
            },
            writeStyle: function(style, elementName, parentElement, classId) {
                if (style != null) {
                    style.classId = classId
                }
                return this.writeResource(style, elementName, parentElement, this.writeStyleContent, this.stylesMap)
            },
            readStyle: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var index = parseInt(element.getAttribute("Id"));
                return this.styles[index]
            },
            writeStyleContent: function(styleElement, style, classId) {
                if (!classId) {
                    classId = style.classId
                }
                styleElement.setAttribute("Class", classId);
                styleElement.setAttribute("Version", "1");
                style.saveToXml(styleElement, this)
            },
            readStyleContent: function(styleElement) {
                var style = new mdiag.Style();
                style.loadFromXml(styleElement, this);
                return style
            },
            writeEffects: function(parentElement) {
                if (this.inplaceResources) {
                    return
                }
                var element = this.addChildElement("Effects", parentElement);
                this.effectsMap.forEach(function(effect, index) {
                    var effectElement = this.addChildElement("Effect", element);
                    if (index >= 0) {
                        effectElement.setAttribute("Index", index.toString())
                    }
                    this.writeEffectContent(effectElement, effect)
                }, this)
            },
            readEffects: function(parentElement) {
                var element = selectSingleNode("Effects", parentElement);
                if (!element) {
                    return
                }
                var effectElements = element.getElementsByTagName("Effect");
                for (var i = 0; i < effectElements.length; i++) {
                    var effectElement = effectElements[i];
                    var index = parseInt(effectElement.getAttribute("Index"));
                    var effect = this.readEffectContent(effectElement);
                    if (effect) {
                        this.effects[index] = effect
                    }
                }
            },
            writeEffect: function(effect, elementName, parentElement) {
                if (effect == null) {
                    return this.addChildElement(elementName, parentElement)
                }
                return this.writeResource(effect, elementName, parentElement, this.writeEffectContent, this.effectsMap)
            },
            readEffect: function(element) {
                if (!element.hasAttribute("Id") || this.inplaceResources) {
                    return this.readEffectContent(element)
                }
                var index = parseInt(element.getAttribute("Id"));
                if (this.effects.length <= index) {
                    return null
                }
                return this.effects[index]
            },
            writeEffectContent: function(effectElement, effect) {
                var classDesc = effect.constructor.xmlInfo;
                if (classDesc) {
                    effectElement.setAttribute("Class", classDesc.classId);
                    effectElement.setAttribute("Version", classDesc.classVersion);
                    effect.saveToXml(effectElement, this)
                } else {
                    throw new Error("Effect cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            readEffectContent: function(effectElement) {
                if (!effectElement.hasAttribute("Class")) {
                    return null
                }
                var classId = effectElement.getAttribute("Class");
                var effect = this.instantiateEffect(classId);
                if (!effect) {
                    return null
                }
                effect.loadFromXml(effectElement, this);
                return effect
            },
            readPen: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var brush = this.readBrush("Brush", element);
                if (!brush) {
                    brush = this.readColor("Color", element)
                }
                var dashStyle = this.readInt("DashStyle", element);
                var width = this.readFloat("Width", element);
                return {
                    brush: brush,
                    dashStyle: dashStyle,
                    width: width
                }
            },
            writePen: function(pen, elementName, parentElement) {
                var penElement = this.addChildElement(elementName, parentElement);
                if (pen) {
                    if (typeof pen == "string") {
                        this.writeBrush(pen, "Color", penElement)
                    } else {
                        if (pen.brush) {
                            this.writeBrush(pen.brush, "Brush", penElement)
                        }
                        if (pen.dashStyle) {
                            this.writeInt(pen.dashStyle, "DashStyle", penElement)
                        }
                        if (pen.width) {
                            this.writeFloat(pen.width, "Width", penElement)
                        }
                    }
                }
                return penElement
            },
            writeSvgs: function(parentElement) {
                if (this.inplaceResources) {
                    return
                }
                var element = this.addChildElement("Svgs", parentElement);
                element.setAttribute("Count", this.svgsMap.getCount());
                this.svgsMap.forEach(function(svg, index) {
                    var svgElement = this.addChildElement("Svg", element);
                    if (index >= 0) {
                        svgElement.setAttibute("Index", index.toString())
                    }
                    this.writeSvgContent(svgElement, svg)
                }, this)
            },
            readSvgs: function(parentElement) {
                var element = selectSingleNode("Svgs", parentElement);
                if (!element) {
                    return
                }
                var svgElements = element.getElementsByTagName("Svg");
                for (var i = 0; i < svgElements.length; i++) {
                    var svgElement = svgElements[i];
                    var index = parseInt(svgElement.getAttribute("Index"));
                    var svg = this.readSvgContent(svgElement);
                    this.svgs[index] = svg
                }
            },
            writeSvgContent: function(svgElement, svg) {
                svgElement.appendChild(this.document.importNode(svg.svgElement, true))
            },
            readSvgContent: function(element) {
                if (element.children.length == 0) {
                    return null
                }
                return element.innerHTML
            },
            readStringFormat: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var alignment = this.readInt("Alignment", element);
                var lineAlignment = this.readInt("LineAlignment", element);
                return {
                    alignment: alignment,
                    lineAlignment: lineAlignment
                }
            },
            writeStringFormat: function(stringFormat, elementName, parentElement) {
                var element = this.addChildElement(elementName, parentElement);
                if (stringFormat) {
                    if (stringFormat.alignment) {
                        this.writeInt(stringFormat.alignment, "Alignment", element)
                    }
                    if (stringFormat.lineAlignment) {
                        this.writeInt(stringFormat.lineAlignment, "LineAlignment", element)
                    }
                }
                return element
            },
            writeString: function(stringValue, elementName, parentElement) {
                return this.addChildElement(elementName, parentElement, stringValue)
            },
            readString: function(elementName, parentElement, defaultValue) {
                if (defaultValue === undefined) {
                    defaultValue = ""
                }
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                return this.innerText(element)
            },
            writeFloat: function(floatValue, elementName, parentElement) {
                return this.addChildElement(elementName, parentElement, floatValue.toString())
            },
            readFloat: function(elementName, parentElement, defaultValue) {
                if (defaultValue === undefined) {
                    defaultValue = 0
                }
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                return parseFloat(this.innerText(element))
            },
            writeInt: function(intValue, elementName, parentElement) {
                var innerText = intValue.toString();
                if (innerText.indexOf(".") != -1) {
                    innerText = Math.round(intValue).toString()
                }
                return this.addChildElement(elementName, parentElement, innerText)
            },
            readInt: function(elementName, parentElement, defaultValue) {
                if (defaultValue === undefined) {
                    defaultValue = 0
                }
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                return parseInt(this.innerText(element))
            },
            writeBool: function(boolValue, elementName, parentElement) {
                if (typeof boolValue === "undefined" || boolValue === null) {
                    boolValue = false
                }
                return this.addChildElement(elementName, parentElement, boolValue.toString())
            },
            readBool: function(elementName, parentElement, defaultValue) {
                if (defaultValue === undefined) {
                    defaultValue = false
                }
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                return this.innerText(element).toLowerCase() == "true"
            },
            writeFloatArray: function(floatArray, elementName, subElementName, parentElement) {
                if (floatArray == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                for (var i = 0; i < floatArray.length; i++) {
                    this.writeFloat(floatArray[i], subElementName, element)
                }
                return element
            },
            readFloatArray: function(elementName, subElementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var itemElements = element.getElementsByTagName(subElementName);
                var array = [];
                for (var i = 0; i < itemElements.length; i++) {
                    array[i] = parseFloat(this.innerText(itemElements[i]))
                }
                return array
            },
            writeColorArray: function(colorArray, elementName, subElementName, parentElement) {
                if (colorArray == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                for (var i = 0; i < colorArray.length; i++) {
                    this.writeColor(colorArray[i], subElementName, element)
                }
                return element
            },
            readColorArray: function(elementName, subElementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var itemElements = element.getElementsByTagName(subElementName);
                var array = [];
                for (var i = 0; i < itemElements.length; i++) {
                    array[i] = this.readColorValue(itemElements[i], "white")
                }
                return array
            },
            writeColor: function(colorValue, elementName, parentElement) {
                return this.addChildElement(elementName, parentElement, mdiag.Utils.colorStringToHex(colorValue))
            },
            readColor: function(elementName, parentElement, defaultValue) {
                if (defaultValue === undefined) {
                    defaultValue = "black"
                }
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return defaultValue
                }
                return this.readColorValue(element, defaultValue)
            },
            readColorValue: function(element, defaultValue) {
                var s = this.innerText(element);
                if (s.length != 9) {
                    return defaultValue
                }
                if (s[0] != "#") {
                    return defaultValue
                }
                var aHex = s.substring(1, 3);
                if (aHex == "FF") {
                    return "#" + s.substring(3)
                }
                var a = parseInt(aHex, 16) / 256;
                var r = parseInt(s.substring(3, 5), 16);
                var g = parseInt(s.substring(5, 7), 16);
                var b = parseInt(s.substring(7, 9), 16);
                return mdiag.Utils.rgbToString(r, g, b, a)
            },
            writeFont: function(font, elementName, parentElement) {
                var fontElement = this.addChildElement(elementName, parentElement);
                if (font) {
                    this.writeString(font.name, "Name", fontElement);
                    this.writeFloat(font.size, "Size", fontElement);
                    this.writeBool(font.bold, "Bold", fontElement);
                    this.writeBool(font.italic, "Italic", fontElement);
                    this.writeBool(font.underline, "Underline", fontElement)
                }
                return fontElement
            },
            readFont: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var name = this.readString("Name", element);
                if (name == "") {
                    return undefined
                }
                var size = this.readFloat("Size", element);
                var unit = this.readInt("Unit", element);
                if (unit != 0) {
                    size = GraphicsUnit.convert(size, unit, this.diagram.measureUnit)
                }
                var bold = this.readBool("Bold", element);
                var italic = this.readBool("Italic", element);
                var underline = this.readBool("Underline", element);
                return new Font(name, size, bold, italic, underline)
            },
            writeAnchorPattern: function(anchorPattern, elementName, parentElement) {
                if (anchorPattern == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                element.setAttribute("Id", (typeof anchorPattern.patternId == "string") ? anchorPattern.patternId : "");
                if (!anchorPattern.patternId) {
                    var pointsElement = this.addChildElement("Points", element);
                    pointsElement.setAttribute("Count", anchorPattern.points.length);
                    for (var i = 0; i < anchorPattern.points.length; i++) {
                        var point = anchorPattern.points[i];
                        var pointElement = this.addChildElement("AnchorPoint", pointsElement);
                        var classDesc = point.constructor.xmlInfo;
                        if (classDesc) {
                            pointElement.setAttribute("Class", classDesc.classId);
                            pointElement.setAttribute("Version", classDesc.classVersion)
                        }
                        point.saveToXml(pointElement, this)
                    }
                }
            },
            readAnchorPattern: function(elementName, parentElement, standalone) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var anchorId = element.getAttribute("Id");
                if (anchorId == "" || standalone) {
                    var pattern = new mdiag.AnchorPattern();
                    var pointsElement = selectSingleNode("Points", element);
                    if (!pointsElement) {
                        return null
                    }
                    var pointElements = pointsElement.getElementsByTagName("AnchorPoint");
                    for (var i = 0; i < pointElements.length; i++) {
                        var pointElement = pointElements[i];
                        var point = new mdiag.AnchorPoint(0, 0);
                        point.allowIncoming = this.readBool("AllowIncoming", pointElement);
                        point.allowOutgoing = this.readBool("AllowOutgoing", pointElement);
                        point.color = this.readColor("Color", pointElement);
                        point.col = this.readInt("Column", pointElement);
                        point.markStyle = this.readInt("MarkStyle", pointElement);
                        point.tag = this.readTag(point, "Tag", pointElement);
                        point.x = this.readFloat("X", pointElement);
                        point.y = this.readFloat("Y", pointElement);
                        pattern.points.push(point)
                    }
                    return pattern
                } else {
                    return mdiag.AnchorPattern.fromId(anchorId)
                }
            },
            writeShape: function(shape, elementName, parentElement) {
                if (shape == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                element.setAttribute("Id", shape.id ? shape.id : "Rectangle");
                return element
            },
            readShape: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                return element.attributes.getNamedItem("Id").value || "RoundRect"
            },
            readArrowheadV13: function(elementName, parentElement) {
                var headShapes = ["None", "Arrow", "Triangle", "Circle", "Tetragon", "Rhombus", "BowArrow", "PointerArrow", "PentagonArrow", "DoubleArrow", "Reversed", "RevTriangle", "Quill", "RevWithLine", "RevWithCirc", "BackSlash", "Slash", "DefaultFlow"];
                var id = this.readInt(elementName, parentElement);
                return headShapes[id]
            },
            innerText: function(element) {
                if (element.childNodes.length == 0) {
                    return ""
                }
                return element.childNodes[0].nodeValue
            },
            writeSizeF: function(size, elementName, parentElement) {
                var innerText = size.width.toString() + ", " + size.height.toString();
                return this.addChildElement(elementName, parentElement, innerText)
            },
            readSizeF: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var value = this.innerText(element);
                var coords = value.split(",");
                return new Size(parseFloat(coords[0]), parseFloat(coords[1]))
            },
            writeRectangleF: function(rectangle, elementName, parentElement) {
                var innerText = "0, 0, 1, 1";
                if (rectangle) {
                    innerText = rectangle.x.toString() + ", " + rectangle.y.toString() + ", " + rectangle.width.toString() + ", " + rectangle.height.toString()
                }
                return this.addChildElement(elementName, parentElement, innerText)
            },
            readRectangleF: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return undefined
                }
                var value = this.innerText(element);
                var coords = value.split(",");
                for (var i = 0; i < coords.length; i++) {
                    coords[i] = parseFloat(coords[i])
                }
                return Rect.fromArgs(coords)
            },
            writeThickness: function(thickness, elementName, parentElement) {
                var innerText = "0, 0, 0, 0";
                if (thickness) {
                    innerText = thickness.left.toString() + ", " + thickness.top.toString() + ", " + thickness.right.toString() + ", " + thickness.bottom.toString()
                }
                return this.addChildElement(elementName, parentElement, innerText)
            },
            readThickness: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return new Thickness(0, 0, 0, 0)
                }
                var value = this.innerText(element);
                var coords = value.split(",");
                for (var i = 0; i < coords.length; i++) {
                    coords[i] = parseFloat(coords[i])
                }
                return new Thickness(coords[0], coords[1], coords[2], coords[3])
            },
            writePointF: function(point, elementName, parentElement) {
                var innerText = "0, 0";
                if (point) {
                    innerText = point.x.toString() + ", " + point.y.toString()
                }
                return this.addChildElement(elementName, parentElement, innerText)
            },
            readPointValue: function(element) {
                var value = element.childNodes[0].nodeValue;
                var coords = value.split(",");
                for (var i = 0; i < coords.length; i++) {
                    coords[i] = parseFloat(coords[i])
                }
                return new Point(coords[0], coords[1])
            },
            writePointCollection: function(points, elementName, parentElement) {
                if (points == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                for (var i = 0; i < points.length; i++) {
                    this.writePointF(points[i], "Point", element)
                }
                return element
            },
            readPoints: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return []
                }
                var children = element.getElementsByTagName("Point");
                var points = [];
                for (var i = 0; i < children.length; i++) {
                    points.push(this.readPointValue(children[i]))
                }
                return points
            },
            writeTheme: function(theme, elementName, parentElement) {
                if (theme == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                this.writeThemeContent(element, theme);
                return element
            },
            writeThemeContent: function(themeElement, theme) {
                theme.saveToXml(themeElement, this)
            },
            readTheme: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (element == null) {
                    return null
                }
                return this.readThemeContent(element)
            },
            readThemeContent: function(element) {
                var theme = new mdiag.Theme();
                theme.loadFromXml(element, this);
                return theme
            },
            selectNode: function(parentElement, name) {
                return selectSingleNode(name, parentElement)
            },
            selectNodes: function(path, parentElement) {
                var elements = [];
                if (this.document.evaluate) {
                    var iter = this.document.evaluate(path, parentElement, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                    var thisNode = iter.iterateNext();
                    while (thisNode) {
                        elements.push(thisNode);
                        thisNode = iter.iterateNext()
                    }
                } else {
                    for (var i = 0; i < parentElement.childNodes.length; i++) {
                        if (parentElement.childNodes[i].tagName == path) {
                            elements.push(parentElement.childNodes[i])
                        }
                    }
                }
                return elements
            },
            writeGroup: function(group, elementName, parentElement) {
                if (!group == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                this.writeItemReference(group.mainItem, "MainItem", element);

                function saveAsDotnetAttachment(list, ctx, attachmentsElement, trait) {
                    if (!list) {
                        return
                    }
                    for (var i = 0; i < list.length; i++) {
                        var attachedNode = list[i];
                        var attachmentElement = ctx.addChildElement("Attachment", attachmentsElement);
                        ctx.writeItemReference(attachedNode, "Item", attachmentElement);
                        ctx.writeInt(0, "Type", attachmentElement);
                        ctx.writeInt(0, "Data", attachmentElement);
                        ctx.writeString("0, 0, 0, 0", "Percents", attachmentElement);
                        if (trait) {
                            var traitsElement = ctx.addChildElement("Traits", attachmentElement);
                            var pairElement = ctx.addChildElement("Pair", traitsElement);
                            pairElement.setAttribute("IsTraits", "1");
                            ctx.addChildElement("Key", pairElement, "std:ContainmentKeys:InContainer");
                            ctx.addChildElement("Value", pairElement, "True").setAttribute("Type", "2")
                        }
                    }
                }
                var attachmentsElement = this.addChildElement("Attachments", element);
                saveAsDotnetAttachment(group.attachedNodes, this, attachmentsElement, false);
                saveAsDotnetAttachment(group.children, this, attachmentsElement, true);
                this.writeBool(true, "Visible", element);
                this.writeRectangleF(group.mainItem.getBounds(), "PrevRect", element);
                return element
            },
            readGroup: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var attachmentsElement = selectSingleNode("Attachments", element);
                if (!element) {
                    return null
                }
                var group = {
                    children: [],
                    attachedNodes: []
                };
                var attachmentElements = element.getElementsByTagName("Attachment");
                for (var i = 0; i < attachmentElements.length; i++) {
                    var attachmentElement = attachmentElements[i];
                    var itemElement = selectSingleNode("Item", attachmentElement);
                    if (itemElement) {
                        var item = this.readItemReference(itemElement);
                        var traitsElement = selectSingleNode("Traits", attachmentElement);
                        var list = traitsElement ? group.children : group.attachedNodes;
                        list.push(item)
                    }
                }
                return group
            },
            writeObject: function(object, elementName, parentElement, raiseIfNotSerializable) {
                if (object == null) {
                    return null
                }
                var typeId = 0;
                var element = null;
                if (typeof object === "string") {
                    if (object.length === 1) {
                        typeId = 4
                    } else {
                        typeId = 1
                    }
                    element = this.writeString(object, elementName, parentElement)
                } else {
                    if (typeof object === "boolean") {
                        typeId = 2;
                        element = this.writeBool(object, elementName, parentElement)
                    } else {
                        if (typeof object === "number") {
                            if (mdiag.Utils.isFloat(object)) {
                                typeId = 6;
                                element = this.writeFloat(object, elementName, parentElement)
                            } else {
                                typeId = 9;
                                element = this.writeInt(object, elementName, parentElement)
                            }
                        }
                    }
                }
                if (element != null) {
                    element.setAttribute("Type", typeId)
                }
                return element
            },
            readObject: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var typeId = parseInt(element.getAttribute("Type"));
                if (typeId == 1) {
                    return this.readString(elementName, parentElement)
                }
                if (typeId == 2) {
                    return this.readBool(elementName, parentElement)
                }
                if (typeId == 3) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 4) {
                    return this.readString(elementName, parentElement)
                }
                if (typeId == 5) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 6) {
                    return this.readFloat(elementName, parentElement)
                }
                if (typeId == 7) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 8) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 9) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 10) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 11) {
                    return this.readFloat(elementName, parentElement)
                }
                if (typeId == 12) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 13) {
                    return this.readInt(elementName, parentElement)
                }
                if (typeId == 14) {
                    return this.readInt(elementName, parentElement)
                }
                return null
            },
            writeTag: function(item, tagValue, elementName, parentElement) {
                if (tagValue == null) {
                    return null
                }
                var element = this.addChildElement(elementName, parentElement);
                var serialized = false;
                if (this.diagram) {
                    serialized = this.diagram.raiseSerializeTag({
                        item: item,
                        tag: tagValue,
                        propertyName: elementName,
                        element: element,
                        context: this
                    })
                }
                if (!serialized) {
                    parentElement.removeChild(element);
                    this.writeObject(tagValue, elementName, parentElement, false)
                }
                return element
            },
            readTag: function(item, elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var params = {
                    item: item,
                    tag: null,
                    propertyName: elementName,
                    element: element,
                    context: this
                };
                var serialized = this.diagram.raiseDeserializeTag(params);
                if (!serialized) {
                    return this.readObject(elementName, parentElement)
                }
                return params.tag
            },
            readSvg: function(elementName, parentElement) {
                var element = selectSingleNode(elementName, parentElement);
                if (!element) {
                    return null
                }
                var index = parseInt(element.getAttribute("Id"));
                return this.svgs[index]
            },
            selectSingleNode: selectSingleNode
        };

        function selectSingleNode(elementName, parentElement) {
            var children = parentElement.getElementsByTagName(elementName);
            if (children.length < 1) {
                return null
            }
            if (children[0].parentNode != parentElement) {
                return null
            }
            return children[0]
        }

        function hasValue(value) {
            return (typeof value != "undefined") && value !== null
        }
        MindFusion.registerClass(XmlPersistContext, "MindFusion.Diagramming.XmlPersistContext")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Rect = MindFusion.Drawing.Rect;
        var Font = MindFusion.Drawing.Font;
        var Thickness = MindFusion.Drawing.Thickness;
        var Cell = mdiag.Cell = function() {
            this.text = new MindFusion.Drawing.Text("", new Rect(0, 0, 1, 1));
            this.text.lineAlignment = mdiag.Alignment.Center
        };
        Cell.prototype = {
            clone: function() {
                var copy = new this.constructor();
                copy.parent = this.parent;
                copy.text = this.text.clone();
                copy.font = this.font;
                copy.brush = this.brush;
                copy.textColor = this.textColor;
                copy.rowSpan = this.rowSpan;
                copy.columnSpan = this.columnSpan;
                copy.imageLocation = this.imageLocation;
                copy.setImageContent(this.imageContent);
                copy.imageAlign = this.imageAlign;
                if (this.image) {
                    copy.setImage(this.getImage())
                }
                copy.imagePadding = this.imagePadding;
                copy.setTag(this.getTag());
                return copy
            },
            toJson: function() {
                var json = {
                    text: this.getText(),
                    textAlignment: this.getTextAlignment(),
                    lineAlignment: this.getLineAlignment(),
                    imageLocation: this.getImageLocation(),
                    imageAlign: this.getImageAlign(),
                    imagePadding: this.imagePadding,
                    brush: this.brush,
                    textColor: this.textColor,
                    rowSpan: this.rowSpan,
                    columnSpan: this.columnSpan,
                    font: this.font,
                    tag: this.tag || null
                };
                if (this.imageContent) {
                    if (this.parent.parent.saveImage) {
                        json.imageIndex = this.parent.parent.saveImage(this.imageContent)
                    } else {
                        json.imageData = this.imageContent
                    }
                }
                return json
            },
            fromJson: function(json) {
                this.setText(json.text);
                this.setTextAlignment(json.textAlignment);
                this.setLineAlignment(json.lineAlignment);
                this.setImageLocation(json.imageLocation);
                this.setImageAlign(json.imageAlign);
                if (json.imagePadding) {
                    this.setImagePadding(Thickness.copy(json.imagePadding))
                }
                this.brush = json.brush;
                this.textColor = json.textColor;
                this.rowSpan = json.rowSpan;
                this.columnSpan = json.columnSpan;
                if (json.font) {
                    this.font = Font.copy(json.font)
                }
                if (json.imageIndex != undefined) {
                    this.setImageContent(this.parent.parent.images[json.imageIndex])
                }
                if (json.imageData != undefined) {
                    this.setImageContent(json.imageData)
                }
                this.setTag(json.tag)
            },
            loadFromXml: function(xmlElement, context) {
                this.font = context.readFont("Font", xmlElement);
                this.textColor = context.readBrush("TextBrush", xmlElement);
                this.setText(context.readString("Text", xmlElement));
                this.columnSpan = context.readInt("ColumnSpan", xmlElement);
                this.rowSpan = context.readInt("RowSpan", xmlElement);
                var legacyTextFormat = context.readStringFormat("TextFormat", xmlElement);
                if (legacyTextFormat) {
                    this.setTextAlignment(legacyTextFormat.alignment);
                    this.setLineAlignment(legacyTextFormat.lineAlignment)
                } else {
                    this.setTextAlignment(context.readInt("TextAlignment", xmlElement));
                    this.setLineAlignment(context.readInt("TextVerticalAlignment", xmlElement))
                }
                this.imageAlign = context.readInt("ImageAlign", xmlElement);
                this.setImageContent(context.readImage("Image", xmlElement));
                var imagePaddingElement = context.selectNode(xmlElement, "ImagePadding");
                if (imagePaddingElement) {
                    this.imagePadding = context.readThickness("ImagePadding", xmlElement)
                }
            },
            saveToXml: function(xmlElement, context) {
                context.writeFont(this.font, "Font", xmlElement);
                context.writeBrush(this.textColor, "TextBrush", xmlElement);
                context.writeString(this.getText(), "Text", xmlElement);
                context.writeInt(this.getColumnSpan(), "ColumnSpan", xmlElement);
                context.writeInt(this.getRowSpan(), "RowSpan", xmlElement);
                context.writeInt(this.getTextAlignment(), "TextAlignment", xmlElement);
                context.writeInt(this.getLineAlignment(), "TextVerticalAlignment", xmlElement);
                context.writeInt(this.getImageAlign(), "ImageAlign", xmlElement);
                context.writeImage(this.getImageContent(), "Image", xmlElement);
                if (this.imagePadding) {
                    context.writeThickness(this.imagePadding, "ImagePadding", xmlElement)
                }
            },
            setText: mdiag.DiagramItem.prototype.setText,
            getText: mdiag.DiagramItem.prototype.getText,
            setTextAlignment: mdiag.DiagramItem.prototype.setTextAlignment,
            getTextAlignment: mdiag.DiagramItem.prototype.getTextAlignment,
            setLineAlignment: mdiag.DiagramItem.prototype.setLineAlignment,
            getLineAlignment: mdiag.DiagramItem.prototype.getLineAlignment,
            setImage: mdiag.ShapeNode.prototype.setImage,
            getImage: mdiag.ShapeNode.prototype.getImage,
            setImageLocation: mdiag.ShapeNode.prototype.setImageLocation,
            getImageLocation: mdiag.ShapeNode.prototype.getImageLocation,
            setImageContent: mdiag.ShapeNode.prototype.setImageContent,
            getImageContent: mdiag.ShapeNode.prototype.getImageContent,
            loadImage: mdiag.ShapeNode.prototype.loadImage,
            setImageAlign: mdiag.ShapeNode.prototype.setImageAlign,
            getImageAlign: mdiag.ShapeNode.prototype.getImageAlign,
            setImagePadding: mdiag.ShapeNode.prototype.setImagePadding,
            getImagePadding: mdiag.ShapeNode.prototype.getImagePadding,
            setFont: function(value) {
                if (this.font !== value) {
                    this.font = value;
                    this.invalidate()
                }
            },
            getFont: function() {
                return this.font
            },
            setBrush: function(value) {
                if (this.brush !== value) {
                    this.brush = value;
                    this.invalidate()
                }
            },
            getBrush: function() {
                return this.brush
            },
            setTextColor: function(value) {
                if (this.textColor !== value) {
                    this.textColor = value;
                    this.invalidate()
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setColumnSpan: function(value) {
                if (this.columnSpan != value) {
                    this.columnSpan = value;
                    this.invalidate()
                }
            },
            getColumnSpan: function() {
                if (this.columnSpan === undefined) {
                    return 1
                }
                return this.columnSpan
            },
            setRowSpan: function(value) {
                if (this.rowSpan != value) {
                    this.rowSpan = value;
                    this.invalidate()
                }
            },
            getRowSpan: function() {
                if (this.rowSpan === undefined) {
                    return 1
                }
                return this.rowSpan
            },
            setTag: function(value) {
                if (this.tag !== value) {
                    this.tag = value
                }
            },
            getTag: function() {
                return this.tag
            },
            invalidate: function() {
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            setDiagramDirty: function() {
                if (this.parent) {
                    this.parent.setDiagramDirty()
                }
            }
        };
        MindFusion.registerClass(Cell, "MindFusion.Diagramming.Cell")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Path = MindFusion.Drawing.Path;
        var Matrix = MindFusion.Drawing.Matrix;
        var Rect = MindFusion.Drawing.Rect;
        var Utils = MindFusion.Diagramming.Utils;
        var EffectPhase = MindFusion.Diagramming.EffectPhase;
        var GlassEffectType = MindFusion.Diagramming.GlassEffectType;
        var GlassEffect = mdiag.GlassEffect = function() {
            mflayer.initializeBase(GlassEffect, this);
            this.type = GlassEffectType.Type1;
            this.glowColor = "white";
            this.reflectionColor = "white"
        };
        GlassEffect.prototype = {
            fromJson: function(json) {
                this.type = json.type;
                this.glowColor = json.glowColor;
                this.usePenAsGlow = json.usePenAsGlow;
                this.reflectionColor = json.reflectionColor
            },
            toJson: function() {
                var json = {
                    typeName: this.constructor.__typeName,
                    type: this.type,
                    glowColor: this.glowColor,
                    usePenAsGlow: this.usePenAsGlow,
                    reflectionColor: this.reflectionColor
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                context.writeInt(this.type, "Type", xmlElement);
                context.writeColor(this.glowColor, "GlowColor", xmlElement);
                context.writeBool(this.usePenAsGlow, "UsePenAsGlow", xmlElement);
                context.writeColor(this.reflectionColor, "ReflectionColor", xmlElement)
            },
            loadFromXml: function(xmlElement, context) {
                this.type = context.readInt("Type", xmlElement);
                this.glowColor = context.readColor("GlowColor", xmlElement);
                this.usePenAsGlow = context.readBool("UsePenAsGlow", xmlElement);
                this.reflectionColor = context.readColor("ReflectionColor", xmlElement)
            },
            clone: function() {
                var copy = new this.constructor();
                copy.type = this.type;
                copy.glowColor = this.glowColor;
                copy.usePenAsGlow = this.usePenAsGlow;
                copy.reflectionColor = this.reflectionColor;
                return copy
            },
            getTransform: function(node) {
                var outlineBounds = new Rect(0, 0, 100, 100);
                var bounds = node.getBounds();
                var x = bounds.width / outlineBounds.width;
                var y = bounds.height / outlineBounds.height;
                var matrix = new Matrix();
                matrix.translate(bounds.x - bounds.width / 2, bounds.y - bounds.height / 2);
                matrix.scale(x, y);
                matrix.translate(bounds.width / x - outlineBounds.x - outlineBounds.width / 2, bounds.height / y - outlineBounds.y - outlineBounds.height / 2);
                if (node.shapeOrientation > 0) {
                    matrix.rotateAt(node.shapeOrientation, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                if (node.rotationAngle !== 0) {
                    matrix.rotateAt(node.rotationAngle, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                return matrix
            },
            getClip: function(node) {
                if (node.shapeRenderer) {
                    return node.shapeRenderer.getOutline()
                } else {
                    var p = new Path();
                    var bounds = node.getBounds();
                    p.addRect(bounds.x, bounds.y, bounds.width, bounds.height);
                    return p
                }
            },
            apply: function(node, content, params) {
                if (params.phase == EffectPhase.AfterFill) {
                    var outlineBounds = new Rect(0, 0, 100, 100);
                    var bounds = node.getBounds();
                    if (node.shapeRenderer) {
                        var nodePath = node.shapeRenderer.getOutline()
                    } else {
                        var nodePath = new Path();
                        nodePath.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height)
                    }
                    var container = new MindFusion.Drawing.Container();
                    container.clip = this.getClip(node);
                    var matrix = this.getTransform(node);
                    var glowColor = Utils.parseColor((params.usePenAsGlow) ? node.getEffectivePen() : this.glowColor);
                    var glowColor1 = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue, 0.7);
                    var glowColor2 = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue, 0);
                    var glowColor3 = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue, 0.5);
                    var glowColor4 = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue, 0.2);
                    var glowColor5 = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue, 0.1);
                    glowColor = Utils.rgbToString(glowColor.red, glowColor.green, glowColor.blue);
                    var reflectionColor = Utils.parseColor(this.reflectionColor);
                    var reflectionColor1 = Utils.rgbToString(reflectionColor.red, reflectionColor.green, reflectionColor.blue, 0.3);
                    var reflectionColor2 = Utils.rgbToString(reflectionColor.red, reflectionColor.green, reflectionColor.blue, 0);
                    var reflectionColor3 = Utils.rgbToString(reflectionColor.red, reflectionColor.green, reflectionColor.blue, 0.5);
                    reflectionColor = Utils.rgbToString(reflectionColor.red, reflectionColor.green, reflectionColor.blue);
                    if (this.type == GlassEffectType.Type1) {
                        var epath = new Path();
                        epath.arcTo(50, 100, 50, 0, 6.28318530717959 / 2, 1);
                        var ebrush = {
                            type: "RadialGradientBrush",
                            color1: glowColor1,
                            color2: glowColor2,
                            y1: 100,
                            y2: 100,
                            radius2: 50
                        };
                        epath.setBrush(ebrush);
                        epath.setPen(glowColor2);
                        epath.transform = matrix.clone();
                        ArrayList.add(container.content, epath);
                        var l = outlineBounds.x;
                        var t = outlineBounds.y;
                        var r = outlineBounds.right();
                        var b = outlineBounds.y + outlineBounds.height * 35 / 100;
                        var w = r - l;
                        var h = b - t;
                        var epath2 = new Path();
                        if (params.isEllipse) {
                            epath2.addEllipse(outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + ((outlineBounds.height * 70 / 100) / 2) - outlineBounds.height * 20 / 100, outlineBounds.width, outlineBounds.height * 70 / 100)
                        } else {
                            epath2.lineTo(l, t, r, t);
                            epath2.lineTo(r, t, r, b);
                            epath2.lineTo(r, b, l + w / 2, b);
                            epath2.lineTo(l + w / 2, b);
                            epath2.bezierTo(l + w / 3, b, l, b, l, t + h / 2);
                            epath2.lineTo(l, t + h / 2, l, t)
                        }
                        var ebrush2 = {
                            type: "SolidBrush",
                            color: reflectionColor1
                        };
                        epath2.setBrush(ebrush2);
                        epath2.setPen(reflectionColor2);
                        epath2.transform = matrix.clone();
                        ArrayList.add(container.content, epath2)
                    } else {
                        if (this.type == GlassEffectType.Type2) {
                            var epath = new Path();
                            epath.addRect(outlineBounds.x, outlineBounds.y + outlineBounds.height / 2, outlineBounds.width, outlineBounds.height / 2);
                            var ebrush = {
                                type: "LinearGradientBrush",
                                x1: 50,
                                y1: 49.5,
                                x2: 50,
                                y2: 101.5,
                                color1: glowColor2,
                                color2: glowColor
                            };
                            epath.setBrush(ebrush);
                            epath.setPen(glowColor2);
                            epath.transform = matrix.clone();
                            ArrayList.add(container.content, epath);
                            var epath2 = new Path();
                            epath2.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height / 3);
                            var ebrush2 = {
                                type: "LinearGradientBrush",
                                x1: 50,
                                y1: 33.5,
                                x2: 50,
                                y2: 0,
                                color1: glowColor2,
                                color2: glowColor3
                            };
                            epath2.setBrush(ebrush2);
                            epath2.setPen(glowColor2);
                            epath2.transform = matrix.clone();
                            ArrayList.add(container.content, epath2);
                            var l = outlineBounds.x;
                            var t = outlineBounds.y;
                            var r = outlineBounds.right();
                            var b = outlineBounds.y + outlineBounds.height * 40 / 100;
                            var w = r - l;
                            var h = b - t;
                            var epath3 = new Path();
                            epath3.lineTo(l, t, r, t);
                            epath3.lineTo(r, t, r, b);
                            epath3.lineTo(r, t, r, b);
                            epath3.lineTo(r, b);
                            epath3.bezierTo(r - w / 3, b - h / 4, l + w / 3, b - h / 4, l, b);
                            epath3.lineTo(l, b, l, t);
                            var ebrush3 = {
                                type: "SolidBrush",
                                color: reflectionColor1
                            };
                            epath3.setBrush(ebrush3);
                            epath3.setPen(reflectionColor2);
                            epath3.transform = matrix.clone();
                            ArrayList.add(container.content, epath3)
                        } else {
                            if (this.type == GlassEffectType.Type3) {
                                var epath = new Path();
                                epath.arcTo(50, 100, 100, 0, 6.28318530717959 / 2, 1);
                                var ebrush = {
                                    type: "RadialGradientBrush",
                                    color1: glowColor1,
                                    color2: glowColor2,
                                    y1: 100,
                                    y2: 100,
                                    raduis1: 50,
                                    radius2: 100
                                };
                                epath.setBrush(ebrush);
                                epath.setPen(glowColor2);
                                epath.transform = matrix.clone();
                                ArrayList.add(container.content, epath);
                                var epath2 = new Path();
                                epath2.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height / 4);
                                var ebrush2 = {
                                    type: "LinearGradientBrush",
                                    x1: 50,
                                    y1: 0,
                                    x2: 50,
                                    y2: 25.5,
                                    color1: reflectionColor3,
                                    color2: reflectionColor2
                                };
                                epath2.setBrush(ebrush2);
                                epath2.setPen(reflectionColor2);
                                epath2.transform = matrix.clone();
                                ArrayList.add(container.content, epath2);
                                var epath3 = nodePath.clone();
                                var clipPath = new Rect(bounds.x, bounds.y, bounds.width, bounds.height / 4);
                                var c = new MindFusion.Drawing.Container();
                                c.clip = clipPath;
                                var ebrush3 = {
                                    type: "LinearGradientBrush",
                                    x1: 50,
                                    y1: 0,
                                    x2: 50,
                                    y2: 100,
                                    color1: reflectionColor,
                                    color2: reflectionColor2
                                };
                                epath3.setBrush("transparent");
                                epath3.setPen(ebrush3);
                                var s = 1 - (((node.getEffectiveStrokeThickness() || 1) / node.parent.scale) / 100);
                                var innerMatrix = matrix.clone();
                                innerMatrix.scaleAtCenter(s, s, outlineBounds);
                                epath3.transform = innerMatrix.clone();
                                ArrayList.add(c.content, epath3);
                                ArrayList.add(container.content, c)
                            } else {
                                if (this.type == GlassEffectType.Type4) {
                                    var epath = new Path();
                                    epath.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height / 2);
                                    var ebrush = {
                                        type: "LinearGradientBrush",
                                        x1: 50,
                                        y1: 0,
                                        x2: 50,
                                        y2: 50.5,
                                        color1: reflectionColor3,
                                        color2: reflectionColor1
                                    };
                                    ebrush.colorStops = [];
                                    ebrush.colorStops.push({
                                        position: 0,
                                        color: reflectionColor2
                                    });
                                    ebrush.colorStops.push({
                                        position: 0.2,
                                        color: reflectionColor1
                                    });
                                    ebrush.colorStops.push({
                                        position: 0.4,
                                        color: reflectionColor3
                                    });
                                    epath.setBrush(ebrush);
                                    epath.setPen(reflectionColor2);
                                    epath.transform = matrix.clone();
                                    ArrayList.add(container.content, epath);
                                    var epath2 = new Path();
                                    epath2.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height);
                                    var ebrush2 = {
                                        type: "LinearGradientBrush",
                                        color1: glowColor,
                                        color2: glowColor
                                    };
                                    ebrush2.colorStops = [];
                                    ebrush2.colorStops.push({
                                        position: 0,
                                        color: glowColor4
                                    });
                                    ebrush2.colorStops.push({
                                        position: 0.037,
                                        color: glowColor5
                                    });
                                    ebrush2.colorStops.push({
                                        position: 0.143,
                                        color: glowColor2
                                    });
                                    ebrush2.colorStops.push({
                                        position: 0.4,
                                        color: glowColor5
                                    });
                                    ebrush2.colorStops.push({
                                        position: 0.857,
                                        color: glowColor2
                                    });
                                    ebrush2.colorStops.push({
                                        position: 0.963,
                                        color: glowColor5
                                    });
                                    ebrush2.colorStops.push({
                                        position: 1,
                                        color: glowColor4
                                    });
                                    epath2.setBrush(ebrush2);
                                    epath2.setPen(reflectionColor2);
                                    epath2.transform = matrix.clone();
                                    ArrayList.add(container.content, epath2)
                                }
                            }
                        }
                    }
                    ArrayList.add(content, container)
                }
            },
            getType: function() {
                return this.type
            },
            setType: function(value) {
                this.type = value
            },
            getGlowColor: function() {
                return this.glowColor
            },
            setGlowColor: function(value) {
                this.glowColor = value
            },
            getUsePenAsGlow: function() {
                return this.usePenAsGlow
            },
            setUsePenAsGlow: function(value) {
                this.usePenAsGlow = value
            },
            getReflectionColor: function() {
                return this.reflectionColor
            },
            setReflectionColor: function(value) {
                this.reflectionColor = value
            }
        };
        MindFusion.registerClass(GlassEffect, "MindFusion.Diagramming.GlassEffect");
        var AeroEffect = mdiag.AeroEffect = function() {
            mflayer.initializeBase(AeroEffect, this);
            this.opacity = 0.4;
            this.shadeColor = "black";
            this.innerOutlineColor = "white"
        };
        AeroEffect.prototype = {
            fromJson: function(json) {
                this.opacity = json.opacity;
                this.shadeColor = json.shadeColor;
                this.innerOutlineColor = json.innerOutlineColor
            },
            toJson: function() {
                var json = {
                    typeName: this.constructor.__typeName,
                    opacity: this.opacity,
                    shadeColor: this.shadeColor,
                    innerOutlineColor: this.innerOutlineColor
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                context.writeFloat(this.opacity, "Opacity", xmlElement);
                context.writeColor(this.shadeColor, "ShadeColor", xmlElement);
                context.writeColor(this.innerOutlineColor, "InnerOutlineColor", xmlElement)
            },
            loadFromXml: function(xmlElement, context) {
                this.opacity = context.readFloat("Opacity", xmlElement);
                this.shadeColor = context.readColor("ShadeColor", xmlElement);
                this.innerOutlineColor = context.readColor("InnerOutlineColor", xmlElement)
            },
            clone: function() {
                var copy = new this.constructor();
                copy.opacity = this.opacity;
                copy.shadeColor = this.shadeColor;
                copy.innerOutlineColor = this.innerOutlineColor;
                return copy
            },
            getTransform: function(node) {
                var outlineBounds = new Rect(0, 0, 100, 100);
                var bounds = node.getBounds();
                var x = bounds.width / outlineBounds.width;
                var y = bounds.height / outlineBounds.height;
                var matrix = new Matrix();
                matrix.translate(bounds.x - bounds.width / 2, bounds.y - bounds.height / 2);
                matrix.scale(x, y);
                matrix.translate(bounds.width / x - outlineBounds.x - outlineBounds.width / 2, bounds.height / y - outlineBounds.y - outlineBounds.height / 2);
                if (node.shapeOrientation > 0) {
                    matrix.rotateAt(node.shapeOrientation, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                if (node.rotationAngle !== 0) {
                    matrix.rotateAt(node.rotationAngle, outlineBounds.x + outlineBounds.width / 2, outlineBounds.y + outlineBounds.height / 2)
                }
                return matrix
            },
            apply: function(node, content, params) {
                var outlineBounds = new Rect(0, 0, 100, 100);
                var bounds = node.getBounds();
                if (node.shapeRenderer) {
                    var nodePath = node.shapeRenderer.getOutline()
                } else {
                    var nodePath = new Path();
                    nodePath.addRect(outlineBounds.x, outlineBounds.y, outlineBounds.width, outlineBounds.height)
                }
                var container = new MindFusion.Drawing.Container();
                var matrix = this.getTransform(node);
                var px1 = params.unitsPerPixel;
                var px3 = px1 * 3;
                var brush = params.brush;
                if (params.phase == EffectPhase.BeforeFill) {
                    if (typeof(params.brush) == "string") {
                        brush = {
                            type: "SolidBrush",
                            color: Utils.parseColor(params.brush)
                        }
                    } else {
                        if (brush.type == "SolidBrush") {
                            brush.color = Utils.parseColor(brush.color)
                        }
                    }
                    if (brush.type == "LinearGradientBrush" || brush.type == "RadialGradientBrush") {
                        brush.color1 = Utils.parseColor(brush.color1);
                        brush.color2 = Utils.parseColor(brush.color2)
                    }
                    if (brush.type == "SolidBrush") {
                        brush.color = Utils.rgbToString(brush.color.red, brush.color.green, brush.color.blue, this.opacity)
                    } else {
                        if (brush.type == "LinearGradientBrush" || brush.type == "RadialGradientBrush") {
                            brush.color1 = Utils.rgbToString(brush.color1.red, brush.color1.green, brush.color1.blue, this.opacity);
                            brush.color2 = Utils.rgbToString(brush.color2.red, brush.color2.green, brush.color2.blue, this.opacity)
                        }
                    }
                    params.brush = brush;
                    var epath = nodePath.clone();
                    epath.setBrush("transparent");
                    var shadeColor = Utils.parseColor(this.shadeColor);
                    var shadowMatrix = matrix.clone();
                    shadowMatrix.scaleAtCenter(1.01, 1.01, outlineBounds);
                    var t = 15;
                    for (var i = 10; i >= 0; i -= 2) {
                        epath2 = epath.clone();
                        epath2.lineJoin = "round";
                        epath2.setPen(Utils.rgbToString(shadeColor.red, shadeColor.green, shadeColor.blue, 0.1));
                        t -= 3;
                        epath2.strokeThickness = t;
                        epath2.transform = shadowMatrix.clone();
                        ArrayList.add(container.content, epath2)
                    }
                    ArrayList.add(content, container);
                    return
                }
                var epath = nodePath.clone();
                epath.setBrush("transparent");
                epath.setPen(this.innerOutlineColor);
                epath.strokeThickness = node.getEffectiveStrokeThickness() + px3;
                var innerMatrix = matrix.clone();
                innerMatrix.scaleAtCenter(0.99, 0.99, outlineBounds);
                epath.transform = innerMatrix.clone();
                ArrayList.add(container.content, epath);
                ArrayList.add(content, container)
            },
            getOpacity: function() {
                return this.opacity
            },
            setOpacity: function(value) {
                this.opacity = value
            },
            getShadeColor: function() {
                return this.shadeColor
            },
            setShadeColor: function(value) {
                this.shadeColor = value
            },
            getInnerOutlineColor: function() {
                return this.innerOutlineColor
            },
            setInnerOutlineColor: function(value) {
                this.innerOutlineColor = value
            }
        };
        MindFusion.registerClass(AeroEffect, "MindFusion.Diagramming.AeroEffect")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var CompositeCommand = mdiag.CompositeCommand = function(diagram) {
            mflayer.initializeBase(CompositeCommand, this, [diagram]);
            this.commands = [];
            this.name = "CompositeCommand"
        };
        CompositeCommand.prototype = {
            execute: function() {
                ArrayList.forEach(this.commands, function(command) {
                    command.execute()
                }, this)
            },
            undo: function() {
                for (var i = this.commands.length - 1; i >= 0; i--) {
                    this.commands[i].undo()
                }
            },
            redo: function() {
                ArrayList.forEach(this.commands, function(command) {
                    command.redo()
                }, this)
            },
            getCommands: function() {
                return this.commands
            }
        };
        MindFusion.registerClass(CompositeCommand, "MindFusion.Diagramming.CompositeCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var AddItemCommand = mdiag.AddItemCommand = function(diagram, item) {
            mflayer.initializeBase(AddItemCommand, this, [diagram]);
            this.item = item;
            this.name = "AddItemCommand"
        };
        AddItemCommand.prototype = {
            execute: function() {
                this.diagram.doAddItem(this.item)
            },
            undo: function() {
                this.diagram.doRemoveItem(this.item, false)
            },
            redo: function() {
                this.diagram.doAddItem(this.item)
            }
        };
        MindFusion.registerClass(AddItemCommand, "MindFusion.Diagramming.AddItemCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var RemoveItemCommand = mdiag.RemoveItemCommand = function(diagram, item) {
            mflayer.initializeBase(RemoveItemCommand, this, [diagram]);
            this.item = item;
            this.name = "RemoveItemCommand"
        };
        RemoveItemCommand.prototype = {
            execute: function() {
                this.diagram.doRemoveItem(this.item)
            },
            undo: function() {
                this.diagram.doAddItem(this.item)
            },
            redo: function() {
                this.diagram.doRemoveItem(this.item)
            }
        };
        MindFusion.registerClass(RemoveItemCommand, "MindFusion.Diagramming.RemoveItemCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ChangeItemCommand = mdiag.ChangeItemCommand = function(diagram, item) {
            mflayer.initializeBase(ChangeItemCommand, this, [diagram]);
            this.state = item.saveState();
            this.item = item
        };
        ChangeItemCommand.prototype = {
            undo: function() {
                this.exchangeStates()
            },
            redo: function() {
                this.exchangeStates()
            },
            execute: function() {},
            exchangeStates: function() {
                var currentState = this.item.saveState();
                this.item.restoreState(this.state);
                this.state = currentState
            }
        };
        MindFusion.registerClass(ChangeItemCommand, "MindFusion.Diagramming.ChangeItemCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var FoldContainerCommand = mdiag.FoldContainerCommand = function(diagram, container) {
            mflayer.initializeBase(FoldContainerCommand, this, [diagram]);
            this.container = container;
            this.folded = this.container.folded;
            this.name = "FoldContainerCommand"
        };
        FoldContainerCommand.prototype = {
            execute: function() {
                this.container.setFolded(!this.container.getFolded())
            },
            undo: function() {
                if (this.folded) {
                    this.container.doFold()
                } else {
                    this.container.doUnfold()
                }
            },
            redo: function() {
                if (!this.folded) {
                    this.container.doFold()
                } else {
                    this.container.doUnfold()
                }
            }
        };
        MindFusion.registerClass(FoldContainerCommand, "MindFusion.Diagramming.FoldContainerCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ScrollTableCommand = mdiag.ScrollTableCommand = function(diagram, table) {
            mflayer.initializeBase(ScrollTableCommand, this, [diagram]);
            this.table = table;
            this.oldRow = table.currentScrollRow;
            this.name = "ScrollTableCommand"
        };
        ScrollTableCommand.prototype = {
            execute: function() {
                this.newRow = this.table.currentScrollRow
            },
            undo: function() {
                this.table.setCurrScrollRow(this.oldRow)
            },
            redo: function() {
                this.table.setCurrScrollRow(this.newRow)
            }
        };
        MindFusion.registerClass(ScrollTableCommand, "MindFusion.Diagramming.ScrollTableCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ResizeTableColumnCommand = mdiag.ResizeTableColumnCommand = function(diagram, table, column) {
            mflayer.initializeBase(ResizeTableColumnCommand, this, [diagram]);
            this.table = table;
            this.column = column;
            this.oldWidth = this.column.width;
            this.oldStyle = this.column.columnStyle;
            this.name = "ResizeTableColumnCommand"
        };
        ResizeTableColumnCommand.prototype = {
            execute: function() {
                this.newWidth = this.column.width;
                this.newStyle = this.column.columnStyle
            },
            undo: function() {
                this.table.setColumnWidth(this.column, this.oldWidth);
                this.table.setColumnStyle(this.column, this.oldStyle)
            },
            redo: function() {
                this.table.setColumnStyle(this.column, this.newStyle);
                this.table.setColumnWidth(this.column, this.newWidth)
            }
        };
        MindFusion.registerClass(ResizeTableColumnCommand, "MindFusion.Diagramming.ResizeTableColumnCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ResizeTableRowCommand = mdiag.ResizeTableRowCommand = function(diagram, table, row) {
            mflayer.initializeBase(ResizeTableRowCommand, this, [diagram]);
            this.table = table;
            this.row = row;
            this.oldHeight = this.row.height;
            this.name = "ResizeTableRowCommand"
        };
        ResizeTableRowCommand.prototype = {
            execute: function() {
                this.newHeight = this.row.height
            },
            undo: function() {
                this.table.setRowHeight(this.row, this.oldHeight)
            },
            redo: function() {
                this.table.setRowHeight(this.row, this.newHeight)
            }
        };
        MindFusion.registerClass(ResizeTableRowCommand, "MindFusion.Diagramming.ResizeTableRowCommand", mdiag.Command)
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var UndoManager = mdiag.UndoManager = function(diagram) {
            this.diagram = diagram;
            this.undoHistory = [];
            this.undoIndex = -1;
            this.currentComposite = null;
            this.startCompositeCounter = 0
        };
        UndoManager.prototype = {
            executeCommand: function(command) {
                command.execute();
                if (this.currentComposite == null) {
                    this.addToHistory(command)
                } else {
                    this.currentComposite.commands.push(command)
                }
            },
            addToHistory: function(command) {
                if (this.undoIndex < this.undoHistory.length - 1) {
                    this.undoHistory.splice(this.undoIndex + 1, this.undoHistory.length - this.undoIndex - 1)
                }
                this.undoHistory.push(command);
                ++this.undoIndex;
                this.diagram.updateCanUndo()
            },
            startComposite: function() {
                if (this.currentComposite == null) {
                    this.currentComposite = new mdiag.CompositeCommand(this.diagram)
                }
                this.startCompositeCounter++;
                return this.currentComposite
            },
            endComposite: function(addToHistory) {
                this.startCompositeCounter--;
                if (this.startCompositeCounter == 0) {
                    if (addToHistory != false) {
                        this.addToHistory(this.currentComposite)
                    }
                    this.currentComposite = null
                }
            },
            undo: function() {
                if (this.canUndo()) {
                    var c = this.undoHistory[this.undoIndex];
                    c.undo();
                    --this.undoIndex;
                    this.diagram.updateCanUndo()
                }
            },
            redo: function() {
                if (this.canRedo()) {
                    ++this.undoIndex;
                    var c = this.undoHistory[this.undoIndex];
                    c.redo();
                    this.diagram.updateCanUndo()
                }
            },
            canUndo: function() {
                return this.undoIndex >= 0
            },
            canRedo: function() {
                return this.undoIndex < this.undoHistory.length - 1
            }
        };
        MindFusion.registerClass(UndoManager, "MindFusion.Diagramming.UndoManager")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Geometry = MindFusion.Geometry;
        var Graph = MindFusion.Graphs.Graph;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var Set = MindFusion.Collections.Set;
        var Router = mdiag.Router = function(diagram) {
            this.diagram = diagram;
            cm = this.diagram.routeMargin
        };
        Router.prototype = {
            route: function(link) {
                this.markObstacles();
                var points = this.routeInternal(link);
                link.copyPoints(points, 0, 0, false)
            },
            routeLinks: function(links) {
                this.markObstacles();
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    link._mf_route = this.routeInternal(link)
                }
                this.pullLinksApart(links);
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    link.copyPoints(link._mf_route, 0, 0, false);
                    delete link._mf_route
                }
            },
            routeInternal: function(link) {
                cm = this.diagram.routeMargin;
                var originRect = link.getOrigin().getRotatedBounds();
                var startPoint = link.getStartPoint();
                var destRect = link.getDestination().getRotatedBounds();
                var endPoint = link.getEndPoint();
                var originCenter = originRect.center();
                var destCenter = destRect.center();
                var rotation = -[0, 90, 180, 270][getSector(originCenter, destCenter)];
                if (rotation != 0) {
                    originRect = rotateRect(originRect, originCenter, rotation);
                    startPoint = mdiag.Utils.rotatePointAt(startPoint, originCenter, rotation);
                    destRect = rotateRect(destRect, originCenter, rotation);
                    endPoint = mdiag.Utils.rotatePointAt(endPoint, originCenter, rotation)
                }
                var sides = getNearestSide(originRect, startPoint) + getNearestSide(destRect, endPoint);
                var points = createPath[sides](originRect, startPoint, destRect, endPoint);
                if (rotation != 0) {
                    mdiag.Utils.rotatePointsAt(points, originCenter, -rotation)
                }
                var nodes = getNearbyNodes(this.diagram, link, points);
                if (nodes.length > 0) {
                    var linkIntersections = [];
                    var mergedNodes = mergeOverlappingNodes(nodes);
                    for (var i = 0; i < points.length - 1; ++i) {
                        var segmentIntersections = [];
                        var p1 = points[i];
                        var p2 = points[i + 1];
                        ArrayList.forEach(mergedNodes, function(node) {
                            ArrayList.addRange(segmentIntersections, getNodeIntersections(p1, p2, node, i))
                        });
                        segmentIntersections.sort(function(i1, i2) {
                            var d1 = Geometry.distance(p1, i1);
                            var d2 = Geometry.distance(p1, i2);
                            if (d1 < d2) {
                                return -1
                            }
                            if (d1 > d2) {
                                return 1
                            }
                            return 0
                        });
                        ArrayList.addRange(linkIntersections, segmentIntersections)
                    }
                    var pairs = [];
                    for (var i = 0; i < linkIntersections.length; ++i) {
                        var enter = linkIntersections[i];
                        for (var j = i + 1; j < linkIntersections.length; ++j) {
                            var intersection = linkIntersections[j];
                            if (intersection.node == enter.node) {
                                pairs.push(enter);
                                pairs.push(intersection);
                                i = j;
                                break
                            }
                        }
                    }
                    if (pairs.length > 0) {
                        var newPoints = [];
                        var lastSegmentAdded = -1;
                        for (var pair = 0; pair < pairs.length - 1; pair += 2) {
                            var enter = pairs[pair];
                            var exit = pairs[pair + 1];
                            while (lastSegmentAdded != enter.segment) {
                                newPoints.push(points[++lastSegmentAdded])
                            }
                            addBorderSegments(newPoints, enter.node, enter, exit);
                            lastSegmentAdded = exit.segment
                        }
                        while (lastSegmentAdded != points.length - 1) {
                            newPoints.push(points[++lastSegmentAdded])
                        }
                        points = newPoints
                    }
                    addLinkNodes(link, nodes);
                    removeUturns(points, nodes)
                }
                return points
            },
            segmentsFromPoints: function(points) {
                var segments = [];
                for (var i = 0; i < points.length - 1; i++) {
                    var segment = {
                        index: i,
                        points: points,
                        horizontal: function() {
                            return this.points[this.index].y == this.points[this.index + 1].y
                        },
                        xint: function() {
                            var prev = this.points[this.index].x;
                            var next = this.points[this.index + 1].x;
                            return prev < next ? [prev, next] : [next, prev]
                        },
                        yint: function() {
                            var prev = this.points[this.index].y;
                            var next = this.points[this.index + 1].y;
                            return prev < next ? [prev, next] : [next, prev]
                        }
                    };
                    segments.push(segment)
                }
                return segments
            },
            pullLinksApart: function(links) {
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    link._mf_segments = this.segmentsFromPoints(link._mf_route)
                }
                this.splitPaths(links, true);
                this.splitPaths(links, false)
            },
            splitPaths: function(links, horizontal) {
                var segments = [];
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    var path = link._mf_segments;
                    for (var j = 0; j < path.length; j++) {
                        var segment = path[j];
                        if (segment.horizontal() == horizontal) {
                            segments.push(segment)
                        }
                    }
                }
                segments.sort(horizontal ? compareY : compareX);
                var currentPos = -(Number.MAX_VALUE - 1);
                var bucket = [];
                var count = segments.length;
                for (var i = 0; i <= count; ++i) {
                    var segment = i < count ? segments[i] : null;
                    if (segment == null || coord(segment, horizontal) != currentPos) {
                        if (bucket.length > 1) {
                            var splitGroups = getSplitGroups(bucket, horizontal);
                            for (var g = 0; g < splitGroups.length; g++) {
                                var group = splitGroups[g];
                                if (group.length < 2) {
                                    continue
                                }
                                var sharedPos = coord(group[0], horizontal);
                                group.sort(horizontal ? compareH : compareV);
                                var min = sharedPos - cm / 2;
                                var max = sharedPos + cm / 2;
                                var mm = cm / 8;
                                var m = (min + max) / 2;
                                var d = Math.min((max - min) / 2, (group.length - 1) * 3 * mm);
                                var step = d / (group.length - 1);
                                var pos = sharedPos - d / 2 >= min + step ? sharedPos - d / 2 : m - d / 2;
                                for (var si = 0; si < group.length; si++) {
                                    var s = group[si];
                                    var offset = pos - coord(s, horizontal);
                                    if (horizontal) {
                                        s.points[s.index].y = pos;
                                        s.points[s.index + 1].y = pos
                                    } else {
                                        s.points[s.index].x = pos;
                                        s.points[s.index + 1].x = pos
                                    }
                                    pos += step
                                }
                            }
                        }
                        bucket.length = 0
                    }
                    if (segment != null) {
                        currentPos = coord(segment, horizontal);
                        if (segment.index > 0 && segment.index < segment.points.length - 1) {
                            bucket.push(segment)
                        }
                    }
                }
            },
            markObstacles: function() {}
        };
        var cm = 8;
        var createPath = {
            rl: function(or, op, dr, dp) {
                var mx = m(r(or), l(dr));
                return [op, {
                    x: mx,
                    y: op.y
                }, {
                    x: mx,
                    y: dp.y
                }, dp]
            },
            rt: function(or, op, dr, dp) {
                if (op.y < t(dr) - cm) {
                    return [op, {
                        x: dp.x,
                        y: op.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: mx,
                    y: op.y
                }, {
                    x: mx,
                    y: t(dr) - cm
                }, {
                    x: dp.x,
                    y: t(dr) - cm
                }, dp]
            },
            rb: function(or, op, dr, dp) {
                if (op.y > b(dr) + cm) {
                    return [op, {
                        x: dp.x,
                        y: op.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: mx,
                    y: op.y
                }, {
                    x: mx,
                    y: b(dr) + cm
                }, {
                    x: dp.x,
                    y: b(dr) + cm
                }, dp]
            },
            rr: function(or, op, dr, dp) {
                if (op.y < t(dr) - cm || op.y > b(dr) + cm) {
                    return [op, {
                        x: r(dr) + cm,
                        y: op.y
                    }, {
                        x: r(dr) + cm,
                        y: dp.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: mx,
                    y: op.y
                }, {
                    x: mx,
                    y: b(dr) + cm
                }, {
                    x: r(dr) + cm,
                    y: b(dr) + cm
                }, {
                    x: r(dr) + cm,
                    y: dp.y
                }, dp]
            },
            bl: function(or, op, dr, dp) {
                if (b(or) < dp.y - cm) {
                    return [op, {
                        x: op.x,
                        y: dp.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: op.x,
                    y: b(or) + cm
                }, {
                    x: mx,
                    y: b(or) + cm
                }, {
                    x: mx,
                    y: dp.y
                }, dp]
            },
            bt: function(or, op, dr, dp) {
                if (b(or) < t(dr) - 2 * cm) {
                    var my = m(b(or), t(dr));
                    return [op, {
                        x: op.x,
                        y: my
                    }, {
                        x: dp.x,
                        y: my
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: op.x,
                    y: b(or) + cm
                }, {
                    x: mx,
                    y: b(or) + cm
                }, {
                    x: mx,
                    y: t(dr) - cm
                }, {
                    x: dp.x,
                    y: t(dr) - cm
                }, dp]
            },
            bb: function(or, op, dr, dp) {
                var maxY = Math.max(b(or), b(dr)) + cm;
                return [op, {
                    x: op.x,
                    y: maxY
                }, {
                    x: dp.x,
                    y: maxY
                }, dp]
            },
            br: function(or, op, dr, dp) {
                var my = b(or) < t(dr) - 2 * cm ? m(b(or), t(dr)) : Math.max(b(or), b(dr)) + cm;
                return [op, {
                    x: op.x,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: dp.y
                }, dp]
            },
            tl: function(or, op, dr, dp) {
                if (dp.y < t(or) - cm) {
                    return [op, {
                        x: op.x,
                        y: dp.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: op.x,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: dp.y
                }, dp]
            },
            tt: function(or, op, dr, dp) {
                var minY = Math.min(t(or), t(dr));
                return [op, {
                    x: op.x,
                    y: minY - cm
                }, {
                    x: dp.x,
                    y: minY - cm
                }, dp]
            },
            tb: function(or, op, dr, dp) {
                if (t(or) > b(dr) + 2 * cm) {
                    var my = m(t(or), b(dr));
                    return [op, {
                        x: op.x,
                        y: my
                    }, {
                        x: dp.x,
                        y: my
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: op.x,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: b(dr) + cm
                }, {
                    x: dp.x,
                    y: b(dr) + cm
                }, dp]
            },
            tr: function(or, op, dr, dp) {
                var my = t(or) > b(dr) + 2 * cm ? m(t(or), b(dr)) : Math.min(t(or), t(dr)) - cm;
                return [op, {
                    x: op.x,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: dp.y
                }, dp]
            },
            ll: function(or, op, dr, dp) {
                if (t(or) > dp.y + cm || b(or) < dp.y - cm) {
                    return [op, {
                        x: l(or) - cm,
                        y: op.y
                    }, {
                        x: l(or) - cm,
                        y: dp.y
                    }, dp]
                }
                var mx = m(r(or), l(dr));
                return [op, {
                    x: l(or) - cm,
                    y: op.y
                }, {
                    x: l(or) - cm,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: t(or) - cm
                }, {
                    x: mx,
                    y: dp.y
                }, dp]
            },
            lt: function(or, op, dr, dp) {
                if (b(or) < t(dr) - 2 * cm) {
                    var my = m(b(or), t(dr));
                    return [op, {
                        x: l(or) - cm,
                        y: op.y
                    }, {
                        x: l(or) - cm,
                        y: my
                    }, {
                        x: dp.x,
                        y: my
                    }, dp]
                }
                var minY = Math.min(t(or), t(dr));
                return [op, {
                    x: l(or) - cm,
                    y: op.y
                }, {
                    x: l(or) - cm,
                    y: minY - cm
                }, {
                    x: dp.x,
                    y: minY - cm
                }, dp]
            },
            lb: function(or, op, dr, dp) {
                if (t(or) > b(dr) + 2 * cm) {
                    var my = m(t(or), b(dr));
                    return [op, {
                        x: l(or) - cm,
                        y: op.y
                    }, {
                        x: l(or) - cm,
                        y: my
                    }, {
                        x: dp.x,
                        y: my
                    }, dp]
                }
                var maxY = Math.max(b(or), b(dr));
                return [op, {
                    x: l(or) - cm,
                    y: op.y
                }, {
                    x: l(or) - cm,
                    y: maxY + cm
                }, {
                    x: dp.x,
                    y: maxY + cm
                }, dp]
            },
            lr: function(or, op, dr, dp) {
                var my = 0;
                if (t(or) > b(dr) + 2 * cm) {
                    my = m(t(or), b(dr))
                } else {
                    if (b(or) < t(dr) - 2 * cm) {
                        my = m(b(or), t(dr))
                    } else {
                        my = Math.min(t(or), t(dr)) - cm
                    }
                }
                return [op, {
                    x: l(or) - cm,
                    y: op.y
                }, {
                    x: l(or) - cm,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: my
                }, {
                    x: r(dr) + cm,
                    y: dp.y
                }, dp]
            }
        };

        function getNearestSide(rect, point) {
            var corners = rect.getCornerPoints();
            var distances = [];
            var sides = ["t", "r", "b", "l"];
            var side = "t";
            for (var i = 0; i < 4; ++i) {
                var d = new MindFusion.Drawing.DistanceToSegment(point, corners[i], corners[(i + 1) % 4]);
                distances.push(d.distanceToSegment())
            }
            var minDist = Number.MAX_VALUE;
            for (var i = 0; i < 4; ++i) {
                if (distances[i] < minDist) {
                    minDist = distances[i];
                    side = sides[i]
                }
            }
            return side
        }

        function getSector(pivot, point) {
            var x = point.x - pivot.x;
            var y = point.y - pivot.y;
            if (Math.abs(x) > Math.abs(y) && x >= 0) {
                return 0
            }
            if (Math.abs(x) > Math.abs(y) && x < 0) {
                return 2
            }
            if (y > 0) {
                return 1
            }
            return 3
        }

        function rotateRect(rect, pivot, angle) {
            var corners = rect.getCornerPoints();
            mdiag.Utils.rotatePointsAt(corners, pivot, angle);
            var l = Math.min(corners[0].x, Math.min(corners[1].x, corners[2].x));
            var t = Math.min(corners[0].y, Math.min(corners[1].y, corners[2].y));
            var r = Math.max(corners[0].x, Math.max(corners[1].x, corners[2].x));
            var b = Math.max(corners[0].y, Math.max(corners[1].y, corners[2].y));
            return Rect.fromLTRB(l, t, r, b)
        }

        function getIntersection(a1, a2, b1, b2) {
            var adx = a2.x - a1.x;
            var ady = a2.y - a1.y;
            var bdx = b2.x - b1.x;
            var bdy = b2.y - b1.y;
            if (adx == 0 && bdx == 0) {
                return null
            }
            if (ady == 0 && bdy == 0) {
                return null
            }
            if (bdx == 0 && betweenInc(b1.x, a1.x, a2.x) && between(a1.y, b1.y, b2.y)) {
                return {
                    x: b1.x,
                    y: a1.y
                }
            }
            if (adx == 0 && between(a1.x, b1.x, b2.x) && betweenInc(b1.y, a1.y, a2.y)) {
                return {
                    x: a1.x,
                    y: b1.y
                }
            }
            return null
        }

        function getNodeIntersections(p1, p2, node, segment) {
            var rect = node.routeBounds;
            var intersections = [];
            var corners = rect.getCornerPoints();
            for (var i = 0; i < 4; ++i) {
                var intersection = getIntersection(p1, p2, corners[i], corners[(i + 1) % 4]);
                if (intersection) {
                    intersection.node = node;
                    intersection.segment = segment;
                    intersection.side = i;
                    intersections.push(intersection);
                    node.routeIntersections++
                }
            }
            return intersections
        }

        function between(v, v1, v2) {
            var min = Math.min(v1, v2);
            var max = Math.max(v1, v2);
            return min < v && v < max
        }

        function betweenInc(v, v1, v2) {
            var min = Math.min(v1, v2);
            var max = Math.max(v1, v2);
            return min <= v && v <= max
        }

        function getNearbyNodes(diagram, link, points) {
            var nodes = [];
            var linkBounds = Rect.boundingRect(points);
            diagram.nodes.forEach(function(node) {
                if (node == link.getOrigin() || node == link.getDestination()) {
                    return
                }
                if (!node.getObstacle()) {
                    return
                }
                if (node.containsRecursively) {
                    if (node.containsRecursively(link.getOrigin()) || node.containsRecursively(link.getDestination())) {
                        return
                    }
                }
                var nodeBounds = mdiag.Utils.inflate(node.getRotatedBounds(), cm, cm);
                node.routeBounds = nodeBounds;
                node.routeIntersections = 0;
                if (nodeBounds.intersectsWith(linkBounds)) {
                    nodes.push(node)
                }
            });
            return nodes
        }

        function addLinkNodes(link, nodes) {
            var newNodes = [];
            newNodes.push(link.getOrigin());
            if (link.getOrigin() != link.getDestination()) {
                newNodes.push(link.getDestination())
            }
            ArrayList.forEach(newNodes, function(node) {
                if (!node.getObstacle()) {
                    return
                }
                var nodeBounds = mdiag.Utils.inflate(node.getRotatedBounds(), cm, cm);
                node.routeBounds = nodeBounds;
                node.routeIntersections = 0;
                nodes.push(node)
            })
        }

        function mergeOverlappingNodes(nodes) {
            if (nodes.length == 1) {
                return nodes
            }
            var unions = [];
            var graph = new Graph;
            ArrayList.forEach(nodes, function(node) {
                node.rvertex = graph.createVertex(null, node)
            });
            for (var i = 0; i < nodes.length - 1; ++i) {
                var node1 = nodes[i];
                for (var j = i + 1; j < nodes.length; ++j) {
                    var node2 = nodes[j];
                    if (node1.routeBounds.intersectsWith(node2.routeBounds.inflate(-cm / 4))) {
                        graph.createEdge(node1.rvertex, node2.rvertex)
                    }
                }
            }
            var components = graph.getConnectedComponents();
            ArrayList.forEach(components, function(component) {
                if (component.vertices.length == 1) {
                    unions.push(component.vertices[0].owner)
                } else {
                    var union = null;
                    component.vertices.forEach(function(vertex) {
                        union = vertex.owner.routeBounds.union(union)
                    });
                    unions.push({
                        routeBounds: union,
                        routeIntersections: 0
                    })
                }
            });
            ArrayList.forEach(nodes, function(node) {
                delete node.rvertex
            });
            return unions
        }

        function addBorderSegments(points, node, enter, exit) {
            var corners = node.routeBounds.getCornerPoints();
            var path1 = [];
            path1.push(enter);
            var side = enter.side;
            while (side != exit.side) {
                side = (side + 1) % 4;
                path1.push(corners[side])
            }
            path1.push(exit);
            var path2 = [];
            path2.push(enter);
            var side = enter.side;
            while (side != exit.side) {
                path2.push(corners[side]);
                side = side - 1;
                if (side < 0) {
                    side = 3
                }
            }
            path2.push(exit);
            if (path1.length < path2.length) {
                ArrayList.addRange(points, path1)
            } else {
                if (path1.length > path2.length) {
                    ArrayList.addRange(points, path2)
                } else {
                    ArrayList.addRange(points, pathLength(path1) < pathLength(path2) ? path1 : path2)
                }
            }
        }

        function pathLength(points) {
            var len = 0;
            for (var i = 0; i < points.length - 1; ++i) {
                len += Geometry.distance(points[i], points[i + 1])
            }
            return len
        }

        function l(rect) {
            return rect.x
        }

        function t(rect) {
            return rect.y
        }

        function r(rect) {
            return rect.x + rect.width
        }

        function b(rect) {
            return rect.y + rect.height
        }

        function m(v1, v2) {
            return (v1 + v2) / 2
        }

        function horizontal(segment, points) {
            return points[segment].y == points[segment + 1].y
        }

        function directedLength(segment, points) {
            var p1 = points[segment];
            var p2 = points[segment + 1];
            if (p1.x == p2.x) {
                return p2.y - p1.y
            } else {
                return p2.x - p1.x
            }
        }

        function intersectsNode(p1, p2, nodes) {
            for (var n = 0; n < nodes.length; ++n) {
                var node = nodes[n];
                var rect = node.routeBounds.inflate(-cm / 8);
                if (rect.containsPoint(p1) && rect.containsPoint(p2)) {
                    return true
                }
                var corners = rect.getCornerPoints();
                for (var i = 0; i < 4; ++i) {
                    var intersection = getIntersection(p1, p2, corners[i], corners[(i + 1) % 4]);
                    if (intersection) {
                        return true
                    }
                }
            }
            return false
        }

        function removeUturns(points, nodes) {
            for (var i = 1; i < points.length - 4; ++i) {
                var c = i;
                var n = i + 1;
                var u = i + 2;
                var cLen = directedLength(c, points);
                var uLen = directedLength(u, points);
                var cHorz = horizontal(c, points);
                var nHorz = horizontal(n, points);
                var uHorz = horizontal(u, points);
                if (cHorz != nHorz && cHorz == uHorz && cLen * uLen < 0) {
                    if (Math.abs(cLen) < Math.abs(uLen)) {
                        var x = cHorz ? {
                            x: points[c].x,
                            y: points[u].y
                        } : {
                            x: points[u].x,
                            y: points[c].y
                        };
                        if (!intersectsNode(points[c], x, nodes)) {
                            points.splice(c, 3, x);
                            i = Math.max(1, i - 2)
                        }
                    } else {
                        var x = cHorz ? {
                            x: points[u + 1].x,
                            y: points[c].y
                        } : {
                            x: points[c].x,
                            y: points[u + 1].y
                        };
                        if (!intersectsNode(x, points[u + 1], nodes)) {
                            points.splice(n, 3, x);
                            i = Math.max(1, i - 2)
                        }
                    }
                }
            }
        }

        function compareX(s1, s2) {
            var p1 = s1.points[s1.index];
            var p2 = s2.points[s2.index];
            if (p1.x < p2.x) {
                return -1
            }
            if (p1.x > p2.x) {
                return 1
            }
            return 0
        }

        function compareY(s1, s2) {
            var p1 = s1.points[s1.index];
            var p2 = s2.points[s2.index];
            if (p1.y < p2.y) {
                return -1
            }
            if (p1.y > p2.y) {
                return 1
            }
            return 0
        }

        function compareV(s1, s2) {
            var p1 = s1.points[0];
            var p2 = s2.points[0];
            if (p1.x < p2.x) {
                return -1
            }
            if (p1.x > p2.x) {
                return 1
            }
            var q1 = s1.points[s1.index];
            var q2 = s2.points[s2.index];
            var r1 = s1.points[s1.index + 1];
            var r2 = s2.points[s2.index + 1];
            var up1 = q1.y > r1.y;
            var up2 = q2.y > r2.y;
            if (up1 && up2) {
                if (q1.y < q2.y) {
                    return -1
                }
                if (q1.y > q2.y) {
                    return 1
                }
            }
            if (!up1 && !up2) {
                if (q1.y < q2.y) {
                    return 1
                }
                if (q1.y > q2.y) {
                    return -1
                }
            }
            if (up1 && !up2) {
                return -1
            }
            if (!up1 && up2) {
                return 1
            }
            return 0
        }

        function compareH(s1, s2) {
            var p1 = s1.points[0];
            var p2 = s2.points[0];
            if (p1.y < p2.y) {
                return -1
            }
            if (p1.y > p2.y) {
                return 1
            }
            return 0
        }

        function coord(segment, horizontal) {
            var point = segment.points[segment.index];
            return horizontal ? point.y : point.x
        }

        function getSplitGroups(segments, horizontal) {
            var graph = new MindFusion.Graphs.Graph();
            var vertices = [];
            for (var i = 0; i < segments.length; i++) {
                var segment = segments[i];
                var vertex = graph.createVertex(null, segment);
                vertices.push(vertex)
            }
            for (var i = 0; i < segments.length - 1; i++) {
                for (var j = i + 1; j < segments.length; j++) {
                    var i1 = horizontal ? segments[i].xint() : segments[i].yint();
                    var i2 = horizontal ? segments[j].xint() : segments[j].yint();
                    if (intervalsIntersect(i1, i2)) {
                        graph.createEdge(vertices[i], vertices[j])
                    }
                }
            }
            var components = graph.getConnectedComponents();
            var splitGroups = [];
            for (var i = 0; i < components.length; i++) {
                var component = components[i];
                var group = [];
                for (var v = 0; v < component.vertices.length; v++) {
                    var vertex = component.vertices[v];
                    group.push(vertex.owner)
                }
                splitGroups.push(group)
            }
            return splitGroups
        }

        function intervalsIntersect(i1, i2) {
            if (i1[0] >= i2[1]) {
                return false
            }
            if (i2[0] >= i1[1]) {
                return false
            }
            return true
        }
        MindFusion.registerClass(Router, "MindFusion.Diagramming.Router")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var ArrayList = MindFusion.Collections.ArrayList;
        var Geometry = MindFusion.Geometry;
        var Graph = MindFusion.Graphs.Graph;
        var GraphicsUnit = MindFusion.Drawing.GraphicsUnit;
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var Set = MindFusion.Collections.Set;
        var PriorityQueue = MindFusion.Collections.PriorityQueue;
        var Grid = MindFusion.Collections.Grid;
        var GridRouter = mdiag.GridRouter = function(diagram) {
            mflayer.initializeBase(GridRouter, this, [diagram]);
            this.grid = new Grid();
            this.gridSize = 4;
            this.nodeVicinitySize = 12;
            this.crossingCost = 4;
            this.lengthCost = 2;
            this.nodeVicinityCost = 2;
            this.turnCost = 4
        };
        GridRouter.prototype = {
            routeInternal: function(link) {
                var orgStart = link.getStartPoint();
                var orgEnd = link.getEndPoint();
                var route = this.aStar(this.diagramToGrid(orgStart), this.diagramToGrid(orgEnd));
                if (route) {
                    var l = route.length - 1;
                    var startHorz = route[0].y == route[1].y;
                    var endHorz = route[l].y == route[l - 1].y;
                    for (var i = 0; i < route.length; i++) {
                        route[i] = this.gridToDiagram(route[i])
                    }
                    route[0] = orgStart;
                    if (startHorz) {
                        route[1].y = orgStart.y
                    } else {
                        route[1].x = orgStart.x
                    }
                    route[l] = orgEnd;
                    if (endHorz) {
                        route[l - 1].y = orgEnd.y
                    } else {
                        route[l - 1].x = orgEnd.x
                    }
                }
                return route
            },
            nearestFree: function(gridPoint) {
                var m = [];
                m[0] = this.freeInDir(gridPoint, 1, 0);
                m[1] = this.freeInDir(gridPoint, 0, 1);
                m[2] = this.freeInDir(gridPoint, -1, 0);
                m[3] = this.freeInDir(gridPoint, 0, -1);
                var maxDist = Number.MAX_VALUE;
                var nearest = null;
                for (var i = 0; i < 4; i++) {
                    if (maxDist > m[i].d) {
                        maxDist = m[i].d;
                        nearest = m[i]
                    }
                }
                return new Point(nearest.x, nearest.y)
            },
            freeInDir: function(gridPoint, dx, dy) {
                var x = gridPoint.x;
                var y = gridPoint.y;
                var d = 0;
                while (this.grid.get(x, y) == 255) {
                    x += dx;
                    y += dy;
                    d++
                }
                return {
                    x: x,
                    y: y,
                    d: d
                }
            },
            aStar: function(start, end) {
                var orgStart = start.clone();
                var orgEnd = end.clone();
                start = this.nearestFree(start);
                end = this.nearestFree(end);
                var grid = this.grid;
                var gridClosed = new Grid(grid.columns, grid.rows);
                var gridOpen = new Grid(grid.columns, grid.rows);
                grid.set(start.x, start.y, 0);
                grid.set(end.x, end.y, 0);
                var open = new PriorityQueue(compareNodes);
                var stack = [];
                var temp = {
                    x: start.x,
                    y: start.y,
                    children: [],
                    g: 0,
                    h: this.routeHeuristics(start, end)
                };
                temp.f = temp.g + temp.h;
                open.add(temp);
                gridOpen.set(temp.x, temp.y, temp);
                var adjcCost = this.lengthCost;
                var turnCost = this.turnCost;
                var best = null;
                var found = false;
                while (true) {
                    if (open.empty()) {
                        break
                    }
                    var pstmp = open.popMin();
                    gridOpen.set(pstmp.x, pstmp.y, null);
                    gridClosed.set(pstmp.x, pstmp.y, pstmp);
                    best = pstmp;
                    if (best.x == end.x && best.y == end.y) {
                        found = true;
                        break
                    }
                    var x = best.x;
                    var y = best.y;
                    var off = [
                        [1, 0],
                        [0, 1],
                        [-1, 0],
                        [0, -1]
                    ];
                    for (var i = 0; i < 4; i++) {
                        var tx = x + off[i][0];
                        var ty = y + off[i][1];
                        if (tx < 0 || ty < 0 || tx >= grid.columns || ty >= grid.columns) {
                            continue
                        }
                        var localCost = grid.get(tx, ty) || 0;
                        if (localCost == 255) {
                            continue
                        }
                        var g = best.g + adjcCost + localCost;
                        var straight = best.parent == null || (best.parent.y == best.y && off[i][1] == 0) || (best.parent.x == best.x && off[i][0] == 0);
                        if (!straight) {
                            g += turnCost
                        }
                        var check = gridOpen.get(tx, ty);
                        if (check != null) {
                            best.children.push(check);
                            if (g < check.g) {
                                check.parent = best;
                                check.g = g;
                                check.f = g + check.h;
                                open.changePriority(check)
                            }
                        } else {
                            check = gridClosed.get(tx, ty);
                            if (check != null) {
                                best.children.push(check);
                                if (g < check.g) {
                                    check.parent = best;
                                    check.g = g;
                                    check.f = g + check.h;
                                    var cc = check.children.length;
                                    var kid;
                                    for (var j = 0; j < cc; j++) {
                                        kid = check.children[j];
                                        var gi = adjcCost;
                                        straight = check.parent == null || (check.parent.y == check.y && check.y == kid.y) || (check.parent.x == check.x && check.x == kid.x);
                                        if (!straight) {
                                            gi += turnCost
                                        }
                                        if (g + gi < kid.g) {
                                            var wasOpen = gridOpen.get(kid.x, kid.y) != null;
                                            kid.g = g + gi;
                                            kid.f = kid.g + kid.h;
                                            kid.parent = check;
                                            stack.push(kid);
                                            if (wasOpen) {
                                                open.changePriority(kid)
                                            }
                                        }
                                    }
                                    var parent;
                                    while (stack.length > 0) {
                                        parent = stack.pop();
                                        cc = parent.children.length;
                                        for (var j = 0; j < cc; j++) {
                                            kid = parent.children[j];
                                            var gi = adjcCost;
                                            straight = parent.parent == null || (parent.parent.y == parent.y && parent.y == kid.y) || (parent.parent.x == parent.x && parent.x == kid.x);
                                            if (!straight) {
                                                gi += turnCost
                                            }
                                            if (parent.g + gi < kid.g) {
                                                var wasOpen = gridOpen.get(kid.x, kid.y) != null;
                                                kid.g = parent.g + gi;
                                                kid.f = kid.g + kid.h;
                                                kid.parent = parent;
                                                stack.push(kid);
                                                if (wasOpen) {
                                                    open.changePriority(kid)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                var current = new Point(tx, ty);
                                var newNode = {
                                    x: current.x,
                                    y: current.y,
                                    parent: best,
                                    children: [],
                                    g: g,
                                    h: this.routeHeuristics(current, end)
                                };
                                newNode.f = newNode.g + newNode.h;
                                open.add(newNode);
                                gridOpen.set(newNode.x, newNode.y, newNode);
                                best.children.push(newNode)
                            }
                        }
                    }
                }
                if (found) {
                    var current = [];
                    current.push(orgEnd);
                    if (!end.equals(orgEnd)) {
                        current.push(end)
                    }
                    while (best != null) {
                        current.push(new Point(best.x, best.y));
                        best = best.parent
                    }
                    if (!start.equals(orgStart)) {
                        current.push(start)
                    }
                    current.push(orgStart);
                    current.reverse();
                    var pt1, pt2, pt3;
                    for (var i = 1; i < current.length - 1;) {
                        pt1 = current[i - 1];
                        pt2 = current[i];
                        pt3 = current[i + 1];
                        if (pt1.x == pt2.x && pt2.x == pt3.x) {
                            current.splice(i, 1)
                        } else {
                            if (pt1.y == pt2.y && pt2.y == pt3.y) {
                                current.splice(i, 1)
                            } else {
                                i++
                            }
                        }
                    }
                    return current
                }
                return null
            },
            routeHeuristics: function(start, end) {
                return Point.distance(start, end)
            },
            cost: function(c, r) {
                var cost = this.grid.get(c, r);
                return cost || 0
            },
            markObstacles: function() {
                var diagram = this.diagram;
                var gridSize = this.gridSize;
                var grid = this.grid;
                var rect = diagram.getContentBounds().union(diagram.getBounds());
                this.gridOffsetLeft = rect.left();
                this.gridOffsetTop = rect.top();
                var gridWidth = Math.floor(rect.width / gridSize);
                var gridHeight = Math.floor(rect.height / gridSize);
                grid.clear();
                grid.resize(gridWidth, gridHeight);
                for (var i = 0; i < diagram.nodes.length; i++) {
                    var node = diagram.nodes[i];
                    if (node.obstacle && !mflayer.isInstanceOfType(mdiag.ContainerNode, node)) {
                        var nodeRect = node.getRotatedBounds();
                        var nodeLeft = nodeRect.left() - rect.left();
                        nodeLeft = Math.floor(nodeLeft / gridSize);
                        var nodeTop = nodeRect.top() - rect.top();
                        nodeTop = Math.floor(nodeTop / gridSize);
                        var nodeRight = nodeRect.right() - rect.left();
                        nodeRight = Math.ceil(nodeRight / gridSize);
                        var nodeBottom = nodeRect.bottom() - rect.top();
                        nodeBottom = Math.ceil(nodeBottom / gridSize);
                        for (var c = nodeLeft; c <= nodeRight; c++) {
                            for (var r = nodeTop; r <= nodeBottom; r++) {
                                grid.set(c, r, 255)
                            }
                        }
                    }
                }
                for (var i = 0; i < diagram.nodes.length; i++) {
                    var node = diagram.nodes[i];
                    if (node.obstacle && !mflayer.isInstanceOfType(mdiag.ContainerNode, node)) {
                        if (this.nodeVicinityCost == 0) {
                            continue
                        }
                        var nodeRect = node.getRotatedBounds();
                        var topLeft = this.diagramToGrid(nodeRect.topLeft());
                        var bottomRight = this.diagramToGrid(nodeRect.bottomRight());
                        var bands = Math.floor(this.nodeVicinitySize / this.gridSize);
                        for (var b = 1; b <= bands; ++b) {
                            var cost = this.nodeVicinityCost / b;
                            var minc = Math.max(0, topLeft.x - b);
                            var maxc = Math.min(gridWidth - 1, bottomRight.x + b);
                            var minr = Math.max(0, topLeft.y - b);
                            var maxr = Math.min(gridHeight - 1, bottomRight.y + b);
                            var r = topLeft.y - b;
                            if (r >= 0) {
                                for (var c = minc; c <= maxc; ++c) {
                                    if (this.cost(c, r) < cost) {
                                        this.grid.set(c, r, cost)
                                    }
                                }
                            }
                            r = bottomRight.y + b;
                            if (r <= maxr) {
                                for (var c = minc; c <= maxc; ++c) {
                                    if (this.cost(c, r) < cost) {
                                        this.grid.set(c, r, cost)
                                    }
                                }
                            }
                            var c = topLeft.x - b;
                            if (c >= 0) {
                                for (r = minr; r <= maxr; ++r) {
                                    if (this.cost(c, r) < cost) {
                                        this.grid.set(c, r, cost)
                                    }
                                }
                            }
                            c = bottomRight.x + b;
                            if (c <= maxc) {
                                for (r = minr; r <= maxr; ++r) {
                                    if (this.cost(c, r) < cost) {
                                        this.grid.set(c, r, cost)
                                    }
                                }
                            }
                        }
                    }
                }
            },
            diagramToGrid: function(point) {
                var x = point.x - this.gridOffsetLeft;
                x = Math.floor(x / this.gridSize);
                var y = point.y - this.gridOffsetTop;
                y = Math.floor(y / this.gridSize);
                return new Point(x, y)
            },
            gridToDiagram: function(point) {
                var x = point.x * this.gridSize + this.gridSize / 2;
                x = x + this.gridOffsetLeft;
                var y = point.y * this.gridSize + this.gridSize / 2;
                y = y + this.gridOffsetTop;
                return new Point(x, y)
            },
            setGridSize: function(value) {
                this.gridSize = value
            },
            getGridSize: function() {
                return this.gridSize
            },
            setNodeVicinitySize: function(value) {
                this.nodeVicinitySize = value
            },
            getNodeVicinitySize: function() {
                return this.nodeVicinitySize
            },
            setCrossingCost: function(value) {
                this.crossingCost = value
            },
            getCrossingCost: function() {
                return this.crossingCost
            },
            setLengthCost: function(value) {
                this.lengthCost = value
            },
            getLengthCost: function() {
                return this.lengthCost
            },
            setNodeVicinityCost: function(value) {
                this.nodeVicinityCost = value
            },
            getNodeVicinityCost: function() {
                return this.nodeVicinityCost
            },
            setTurnCost: function(value) {
                this.turnCost = value
            },
            getTurnCost: function() {
                return this.turnCost
            }
        };

        function compareNodes(node1, node2) {
            if (node2 == null) {
                return 1
            }
            if (node1 == node2) {
                return 0
            }
            if (node1.f > node2.f) {
                return 1
            }
            if (node1.f < node2.f) {
                return -1
            }
            if (node1.x > node2.x) {
                return 1
            }
            if (node1.x < node2.x) {
                return -1
            }
            if (node1.y > node2.y) {
                return 1
            }
            if (node1.y < node2.y) {
                return -1
            }
            return 0
        }
        MindFusion.registerClass(GridRouter, "MindFusion.Diagramming.GridRouter", mdiag.Router)
    })(MindFusion.Diagramming);
    MindFusion.registerNamespace("MindFusion.Diagramming.Lanes");
    MindFusion.Diagramming.Lanes.ResizeType = {
        Fixed: 0,
        Proportional: 1
    };
    (function(mlanes) {
        var Cell = mlanes.Cell = function(parent) {
            mflayer.initializeBase(Cell, this);
            this.parent = parent;
            this.style = new mlanes.Style();
            this.text = ""
        };
        Cell.prototype = {
            setIndex: function(column, row) {
                this.column = column;
                this.row = row
            },
            getObjectToEdit: function() {
                return this
            },
            getTextToEdit: function() {
                return this.getText()
            },
            getEditRect: function(point) {
                return this.getInplaceEditBounds()
            },
            createEditArgs: function(oldText, newText) {
                return new MindFusion.Diagramming.CellEventArgs({
                    cell: this,
                    oldText: oldText,
                    newText: newText,
                    column: this.column,
                    row: this.row
                })
            },
            setEditedText: function(newText) {
                this.setText(newText)
            },
            getDiagramItem: function() {
                return null
            },
            fromJson: function(json) {
                if (json.style) {
                    this.style.fromJson(json.style)
                }
                this.text = json.text
            },
            toJson: function() {
                var json = {
                    style: this.style.toJson(),
                    text: this.text
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                var styleElement = context.addChildElement("Style", xmlElement);
                this.style.saveToXml(styleElement, context);
                context.writeString(this.text, "Text", xmlElement);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var font = {};
                    if (this.style.fontName) {
                        font.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        font.size = this.style.fontSize
                    }
                    context.writeFont(font, "Font", xmlElement)
                }
                if (this.style && (this.style.textAlignment != undefined || this.style.lineAlignment != undefined)) {
                    var stringFormat = {};
                    if (this.style.textAlignment !== undefined) {
                        stringFormat.alignment = this.style.textAlignment
                    }
                    if (this.style.lineAlignment != undefined) {
                        stringFormat.lineAlignment = this.style.lineAlignment
                    }
                    context.writeStringFormat(stringFormat, "Format", xmlElement)
                }
                if (this.style && this.style.textColor != undefined) {
                    context.writeColor(this.style.textColor, "Color", xmlElement)
                }
            },
            loadFromXml: function(xmlElement, context) {
                var styleElement = context.selectSingleNode("Style", xmlElement);
                this.style.loadFromXml(styleElement, context);
                this.text = context.readString("Text", xmlElement);
                var font = context.readFont("Font", xmlElement);
                if (font) {
                    if (font.name) {
                        this.style.fontName = font.name
                    }
                    if (font.size) {
                        this.style.fontSize = font.size
                    }
                }
                var stringFormat = context.readStringFormat("Format", xmlElement);
                if (stringFormat) {
                    if (stringFormat.alignment) {
                        this.style.textAlignment = stringFormat.alignment
                    }
                    if (stringFormat.lineAlignment) {
                        this.style.lineAlignment = stringFormat.lineAlignment
                    }
                }
                var color = context.readColor("Color", xmlElement);
                if (color) {
                    this.style.textColor = color
                }
            },
            getStyle: function() {
                return this.style
            },
            setStyle: function(value) {
                if (!value) {
                    throw new Error("The style of a cell cannot be null.")
                }
                if (this.style === value) {
                    return
                }
                this.style = value;
                this.parent.grid.invalidate()
            },
            getText: function() {
                return this.text
            },
            setText: function(value) {
                if (this.text === value) {
                    return
                }
                this.text = value;
                this.parent.grid.invalidate()
            },
            getInplaceEditBounds: function() {
                return this.inplaceEditBounds
            },
            setInplaceEditBounds: function(value) {
                this.inplaceEditBounds = value
            }
        };
        MindFusion.registerClass(Cell, "MindFusion.Diagramming.Lanes.Cell")
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var CellCluster = mlanes.CellCluster = function(grid, columnStart, columnEnd, rowStart, rowEnd) {
            mflayer.initializeBase(CellCluster, this);
            this.grid = grid;
            var _this = this;
            var handler = function() {
                _this.valid = false;
                _this.grid.removeEventListener(mlanes.Events.invalidated, handler)
            };
            this.grid.addEventListener(mlanes.Events.invalidated, handler);
            this.columnStart = columnStart;
            this.columnEnd = columnEnd;
            this.rowStart = rowStart;
            this.rowEnd = rowEnd;
            this.valid = true
        };
        CellCluster.prototype = {
            getStyle: function() {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return new mlanes.CellClusterStyle(this)
            },
            setStyle: function(value) {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var c = this.columnStart; c <= this.columnEnd; c++) {
                    for (var r = this.rowStart; r <= this.rowEnd; r++) {
                        this.grid.get(c, r).setStyle(value)
                    }
                }
            },
            getText: function() {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return this.grid.get(this.columnStart, this.columnEnd).getText()
            },
            setText: function(value) {
                if (!valid) {
                    throw new InvalidOperationException("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var c = this.columnStart; c <= this.columnEnd; c++) {
                    for (var r = this.rowStart; r <= this.rowEnd; r++) {
                        this.grid.get(c, r).setText(value)
                    }
                }
            },
            getColumnStart: function() {
                return this.columnStart
            },
            getColumnEnd: function() {
                return this.columnEnd
            },
            getRowStart: function() {
                return this.rowStart
            },
            getRowEnd: function() {
                return this.rowEnd
            }
        };
        MindFusion.registerClass(CellCluster, "MindFusion.Diagramming.Lanes.CellCluster")
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var CellClusterStyle = mlanes.CellClusterStyle = function(cellCluster, columnStart, columnEnd, rowStart, rowEnd) {
            mflayer.initializeBase(CellClusterStyle, this);
            this.cellCluster = cellCluster;
            this.grid = cellCluster.grid;
            this.columnStart = cellCluster.columnStart;
            this.columnEnd = cellCluster.columnEnd;
            this.rowStart = cellCluster.rowStart;
            this.rowEnd = cellCluster.rowEnd
        };
        CellClusterStyle.prototype = {
            getPropertyValue: function(getter) {
                if (!this.cellCluster.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return getter.apply(this.grid.get(this.columnStart, this.rowStart).getStyle())
            },
            setPropertyValue: function(setter, value) {
                if (!this.cellCluster.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var c = this.columnStart; c <= this.columnEnd; c++) {
                    for (var r = this.rowStart; r <= this.rowEnd; r++) {
                        setter.apply(this.grid.get(c, r).getStyle(), [value])
                    }
                }
            },
            getBackgroundBrush: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getBackgroundBrush)
            },
            setBackgroundBrush: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setBackgroundBrush, value)
            },
            getLeftBorderPen: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getLeftBorderPen)
            },
            setLeftBorderPen: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setLeftBorderPen, value)
            },
            getLeftBorderThickness: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getLeftBorderThickness)
            },
            setLeftBorderThickness: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setLeftBorderThickness, value)
            },
            getTopBorderPen: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getTopBorderPen)
            },
            setTopBorderPen: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setTopBorderPen, value)
            },
            getTopBorderThickness: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getTopBorderThickness)
            },
            setTopBorderThickness: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setTopBorderThickness, value)
            },
            getRightBorderPen: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getRightBorderPen)
            },
            setRightBorderPen: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setRightBorderPen, value)
            },
            getRightBorderThickness: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getRightBorderThickness)
            },
            setRightBorderThickness: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setRightBorderThickness, value)
            },
            getBottomBorderPen: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getBottomBorderPen)
            },
            setBottomBorderPen: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setBottomBorderPen, value)
            },
            getBottomBorderThickness: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getBottomBorderThickness)
            },
            setBottomBorderThickness: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setBottomBorderThickness, value)
            },
            getTextColor: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getTextColor)
            },
            setTextColor: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setTextColor, value)
            },
            getFontName: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getFontName)
            },
            setFontName: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setFontName, value)
            },
            getFontSize: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getFontSize)
            },
            setFontSize: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setFontSize, value)
            },
            getTextAlignment: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getTextAlignment)
            },
            setTextAlignment: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setTextAlignment, value)
            },
            getLineAlignment: function() {
                return this.getPropertyValue(mlanes.Style.prototype.getLineAlignment)
            },
            setLineAlignment: function(value) {
                this.setPropertyValue(mlanes.Style.prototype.setLineAlignment, value)
            }
        };
        MindFusion.registerClass(CellClusterStyle, "MindFusion.Diagramming.Lanes.CellClusterStyle")
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var CellMatrix = mlanes.CellMatrix = function(grid) {
            mflayer.initializeBase(CellMatrix, this);
            this.grid = grid;
            this.data = [
                []
            ];
            this.rowCount = 0;
            this.columnCount = 0
        };
        CellMatrix.prototype = {
            fromJson: function(json) {
                this.data = [];
                this.rowCount = json.rowCount;
                this.columnCount = json.columnCount;
                var column;
                for (var i = 0; i < json.data.length; i++) {
                    if (i % this.rowCount === 0) {
                        if (column) {
                            this.data.push(column)
                        }
                        column = []
                    }
                    var cell = new mlanes.Cell(this);
                    cell.fromJson(json.data[i]);
                    column.push(cell)
                }
                if (json.data.length > 0) {
                    this.data.push(column)
                }
            },
            toJson: function() {
                var json = {
                    data: this.serializeData(),
                    rowCount: this.rowCount,
                    columnCount: this.columnCount
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                xmlElement.setAttribute("ColumnCount", this.columnCount);
                xmlElement.setAttribute("RowCount", this.rowCount);
                for (var c = 0, cl = this.columnCount; c < cl; c++) {
                    for (var r = 0, rl = this.rowCount; r < rl; r++) {
                        var cellElement = context.addChildElement("Cell", xmlElement);
                        cellElement.setAttribute("Row", r);
                        cellElement.setAttribute("Column", c);
                        this.data[c][r].saveToXml(cellElement, context)
                    }
                }
            },
            loadFromXml: function(xmlElement, context) {
                this.columnCount = parseInt(xmlElement.getAttribute("ColumnCount"));
                this.rowCount = parseInt(xmlElement.getAttribute("RowCount"));
                this.data = [];
                for (var i = 0; i < this.columnCount; i++) {
                    this.data.push([])
                }
                var elements = context.selectNodes("Cell", xmlElement);
                for (var i = 0; i < elements.length; i++) {
                    var cell = new mlanes.Cell(this);
                    cell.loadFromXml(elements[i], context);
                    var c = parseInt(elements[i].getAttribute("Column"));
                    var r = parseInt(elements[i].getAttribute("Row"));
                    this.data[c][r] = cell
                }
            },
            serializeData: function() {
                var result = [];
                for (var c = 0, cl = this.columnCount; c < cl; c++) {
                    for (var r = 0, rl = this.rowCount; r < rl; r++) {
                        result.push(this.data[c][r].toJson())
                    }
                }
                return result
            },
            insertColumns: function(index, count) {
                if (count <= 0) {
                    return
                }
                var rowCount = this.getRowCount();
                for (var c = 0; c < count; c++) {
                    var column = [];
                    for (var r = 0; r < rowCount; r++) {
                        column.push(new mlanes.Cell(this))
                    }
                    this.data.splice(index + c, 0, column)
                }
                this.columnCount += count
            },
            insertRows: function(index, count) {
                if (count <= 0) {
                    return
                }
                var columnCount = this.getColumnCount();
                for (var c = 0; c < columnCount; c++) {
                    for (var r = 0; r < count; r++) {
                        this.data[c].splice(index + r, 0, new mlanes.Cell(this))
                    }
                }
                this.rowCount += count
            },
            removeColumns: function(index, count) {
                if (count <= 0) {
                    return
                }
                this.data.splice(index, count);
                this.columnCount -= count
            },
            removeRows: function(index, count) {
                if (count <= 0) {
                    return
                }
                var columnCount = this.getColumnCount();
                for (var c = 0; c < columnCount; c++) {
                    this.data[c].splice(index, count)
                }
                this.rowCount -= count
            },
            get: function(column, row) {
                return this.data[column][row]
            },
            getColumnCount: function() {
                return this.columnCount
            },
            getRowCount: function() {
                return this.rowCount
            }
        };
        MindFusion.registerClass(CellMatrix, "MindFusion.Diagramming.Lanes.CellMatrix")
    })(MindFusion.Diagramming.Lanes);
    MindFusion.Diagramming.Lanes.Events = {
        invalidated: "invalidated"
    };
    (function(mlanes) {
        var Rect = MindFusion.Drawing.Rect;
        var Point = MindFusion.Drawing.Point;
        var Dictionary = MindFusion.Collections.Dictionary;
        var Grid = mlanes.Grid = function(parent) {
            mflayer.initializeBase(Grid, this);
            this.parent = parent;
            this.columnHeader = new mlanes.MasterHeader(this, false);
            this.rowHeader = new mlanes.MasterHeader(this, true);
            this.leftMargin = 0;
            this.topMargin = 0;
            this.minHeaderSize = 10;
            this.topLeftAreaText = "";
            this.allowInplaceEdit = false;
            this.allowResizeHeaders = true;
            this.hookHeaders = true;
            this.headersOnTop = true;
            this.rowWidths = [];
            this.columnHeights = [];
            this.cells = new mlanes.CellMatrix(this);
            this.style = new mlanes.Style();
            this.style.setLeftBorderThickness(1);
            this.style.setTopBorderThickness(1);
            this.style.setRightBorderThickness(1);
            this.style.setBottomBorderThickness(1);
            this.style.setTextAlignment(MindFusion.Diagramming.Alignment.Center);
            this.style.setLineAlignment(MindFusion.Diagramming.Alignment.Center);
            this.eventHandlers = mflayer.eventHandlerList()
        };
        Grid.prototype = {
            fromJson: function(json) {
                this.columnHeader.fromJson(json.columnHeader);
                this.rowHeader.fromJson(json.rowHeader);
                this.leftMargin = json.leftMargin;
                this.topMargin = json.topMargin;
                this.minHeaderSize = json.minHeaderSize;
                this.topLeftAreaText = json.topLeftAreaText;
                this.hookHeaders = json.hookHeaders;
                this.headersOnTop = json.headersOnTop;
                this.rowWidths = json.rowWidths;
                this.columnHeights = json.columnHeights;
                if (json.allowResizeHeaders != undefined) {
                    this.allowResizeHeaders = json.allowResizeHeaders
                }
                if (json.style) {
                    this.style.fromJson(json.style)
                }
                this.cells.fromJson(json.cells);
                this.raiseEvent(mlanes.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            toJson: function() {
                var json = {
                    columnHeader: this.columnHeader.toJson(),
                    rowHeader: this.rowHeader.toJson(),
                    leftMargin: this.leftMargin,
                    topMargin: this.topMargin,
                    minHeaderSize: this.minHeaderSize,
                    topLeftAreaText: this.topLeftAreaText,
                    hookHeaders: this.hookHeaders,
                    headersOnTop: this.headersOnTop,
                    rowWidths: this.rowWidths,
                    columnHeights: this.columnHeights,
                    allowResizeHeaders: this.allowResizeHeaders,
                    style: this.style.toJson(),
                    cells: this.cells.toJson()
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                context.writeFloat(this.leftMargin, "LeftMargin", xmlElement);
                context.writeFloat(this.topMargin, "TopMargin", xmlElement);
                context.writeFloat(this.minHeaderSize, "MinHeaderSize", xmlElement);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var font = {};
                    if (this.style.fontName) {
                        font.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        font.size = this.style.fontSize
                    }
                    context.writeFont(font, "DefaultFont", xmlElement)
                }
                context.writeBool(this.hookHeaders, "HookHeaders", xmlElement);
                context.writeBool(this.headersOnTop, "HeadersOnTop", xmlElement);
                context.writeFloatArray(this.rowWidths, "RowWidths", "Width", xmlElement);
                context.writeFloatArray(this.columnHeights, "ColumnHeights", "Height", xmlElement);
                context.writeBool(this.allowResizeHeaders, "AllowResizeHeaders", xmlElement);
                var columnsElement = context.addChildElement("Columns", xmlElement);
                this.columnHeader.saveToXml(columnsElement, context);
                var rowsElement = context.addChildElement("Rows", xmlElement);
                this.rowHeader.saveToXml(rowsElement, context);
                var cellsElement = context.addChildElement("Cells", xmlElement);
                this.cells.saveToXml(cellsElement, context)
            },
            loadFromXml: function(xmlElement, context) {
                this.leftMargin = context.readFloat("LeftMargin", xmlElement);
                this.topMargin = context.readFloat("TopMargin", xmlElement);
                this.minHeaderSize = context.readFloat("MinHeaderSize", xmlElement);
                var font = context.readFont("DefaultFont", xmlElement);
                if (font) {
                    if (font.name) {
                        this.style.fontName = font.name
                    }
                    if (font.size) {
                        this.style.fontSize = font.size
                    }
                }
                this.hookHeaders = context.readBool("HookHeaders", xmlElement);
                this.headersOnTop = context.readBool("HeadersOnTop", xmlElement);
                this.rowWidths = context.readFloatArray("RowWidths", "Width", xmlElement);
                this.columnHeights = context.readFloatArray("ColumnHeights", "Height", xmlElement);
                this.allowResizeHeaders = context.readBool("AllowResizeHeaders", xmlElement);
                var columnsElement = context.selectSingleNode("Columns", xmlElement);
                this.columnHeader.loadFromXml(columnsElement, context);
                var rowsElement = context.selectSingleNode("Rows", xmlElement);
                this.rowHeader.loadFromXml(rowsElement, context);
                var cellsElement = context.selectSingleNode("Cells", xmlElement);
                this.cells.loadFromXml(cellsElement, context)
            },
            addEventListener: function(eventName, handler) {
                mflayer.addHandler(this, eventName, handler)
            },
            removeEventListener: function(eventName, handler) {
                mflayer.removeHandler(this, eventName, handler)
            },
            raiseEvent: function(eventName, args) {
                var handler = mflayer.getHandler(this, eventName);
                if (handler) {
                    handler(this, args)
                }
            },
            addColumnHeader: function(header, parent, i) {
                if (header.getParent()) {
                    throw new Error("Cannot add a header to more than one parent header at a time.")
                }
                if (!parent) {
                    parent = this.columnHeader
                }
                if (!parent.isColumnHeader()) {
                    throw new Error("The specified header is not a column header.")
                }
                var next = parent;
                while (next) {
                    if (header === next) {
                        throw new Error("Cannot add a header to itself or as a direct or indirect child to any of its children.")
                    }
                    next = next.parent
                }
                header.setParent(parent);
                var subHeaders = parent.getSubHeaders();
                if (!i) {
                    subHeaders.push(header)
                } else {
                    subHeaders.splice(i, 0, header)
                }
                this.onColumnHeaderAdded(header);
                this.invalidate()
            },
            onColumnHeaderAdded: function(header) {
                var gindex = this.getIndex(header);
                var columnsToAdd = header.getDeepChildCount();
                if (header.getParent().getSubHeaders().length === 1) {
                    if (header.getParent() !== this.columnHeader) {
                        columnsToAdd -= 1
                    }
                }
                this.cells.insertColumns(gindex, columnsToAdd);
                if (header.getParent().getSubHeaders().length === 1) {
                    header.ensureWidth(Math.max(this.minHeaderSize, header.getParent().getWidth()))
                } else {
                    header.ensureWidth(this.minHeaderSize)
                }
                if (header.getHeight() === 0) {
                    header.height = 20
                }
                this.raiseEvent(mlanes.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            removeColumnHeader: function(header) {
                var parent = header.getParent();
                if (!parent) {
                    return
                }
                if (!header.isColumnHeader()) {
                    throw new Error("The specified header is not a column header.")
                }
                var subHeaders = parent.getSubHeaders();
                var index = subHeaders.indexOf(header);
                this.onColumnHeaderRemoved(header);
                header.setParent();
                subHeaders.splice(index, 1);
                this.invalidate()
            },
            onColumnHeaderRemoved: function(header) {
                var gindex = this.getIndex(header);
                var columnsToRemove = header.getDeepChildCount();
                if (header.getParent().getSubHeaders().length === 1) {
                    if (header.getParent() !== this.columnHeader) {
                        columnsToRemove -= 1
                    }
                }
                if (header.getParent().getSubHeaders().length === 1 && header.getParent() !== this.columnHeader) {
                    header.getParent().setWidth(header.getWidth())
                }
                header.zeroWidth();
                header.zeroHeight();
                this.cells.removeColumns(gindex, columnsToRemove);
                this.raiseEvent(mlanes.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            addRowHeader: function(header, parent, i) {
                if (header.getParent()) {
                    throw new Error("Cannot add a header to more than one parent header at a time.")
                }
                if (!parent) {
                    parent = this.rowHeader
                }
                if (!parent.isRowHeader()) {
                    throw new Error("The specified header is not a row header.")
                }
                var next = parent;
                while (next) {
                    if (header === next) {
                        throw new Error("Cannot add a header to itself or as a direct or indirect child to any of its children.")
                    }
                    next = next.parent
                }
                header.setParent(parent);
                var subHeaders = parent.getSubHeaders();
                if (isNaN(i) || i < 0 || i > subHeaders.length) {
                    subHeaders.push(header)
                } else {
                    subHeaders.splice(i, 0, header)
                }
                this.onRowHeaderAdded(header);
                this.invalidate()
            },
            onRowHeaderAdded: function(header) {
                var gindex = this.getIndex(header);
                var rowsToAdd = header.getDeepChildCount();
                if (header.getParent().getSubHeaders().length === 1) {
                    if (header.getParent() !== this.rowHeader) {
                        rowsToAdd -= 1
                    }
                }
                this.cells.insertRows(gindex, rowsToAdd);
                if (header.getParent().getSubHeaders().length === 1) {
                    header.ensureHeight(Math.max(this.minHeaderSize, header.getParent().getHeight()))
                } else {
                    header.ensureHeight(this.minHeaderSize)
                }
                if (header.getWidth() === 0) {
                    header.width = 20
                }
                this.raiseEvent(mlanes.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            removeRowHeader: function(header) {
                var parent = header.getParent();
                if (!parent) {
                    return
                }
                if (!header.isRowHeader()) {
                    throw new Error("The specified header is not a row header.")
                }
                var subHeaders = parent.getSubHeaders();
                var index = subHeaders.indexOf(header);
                this.onRowHeaderRemoved(header);
                header.setParent();
                subHeaders.splice(index, 1);
                this.invalidate()
            },
            onRowHeaderRemoved: function(header) {
                var gindex = this.getIndex(header);
                var rowsToRemove = header.getDeepChildCount();
                if (header.getParent().getSubHeaders().length === 1) {
                    if (header.getParent() !== this.rowHeader) {
                        rowsToRemove -= 1
                    }
                }
                if (header.getParent().getSubHeaders().length === 1 && header.getParent() !== this.rowHeader) {
                    header.getParent().setHeight(header.getHeight())
                }
                header.zeroWidth();
                header.zeroHeight();
                this.cells.removeRows(gindex, rowsToRemove);
                this.raiseEvent(mlanes.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            findColumn: function(title) {
                return this.findHeader(this.columnHeader.getSubHeaders(), title)
            },
            findRow: function(title) {
                return this.findHeader(this.rowHeader.getSubHeaders(), title)
            },
            findHeader: function(headers, title) {
                for (var i = 0; i < headers.length; i++) {
                    var header = headers[i];
                    if (header.getTitle() == title) {
                        return header
                    }
                    var result = this.findHeader(header.getSubHeaders(), title);
                    if (result) {
                        return result
                    }
                }
            },
            getIndex: function(header) {
                if (!header.getParent()) {
                    return 0
                }
                return this.getIndex(header.getParent()) + this.getLocalIndex(header)
            },
            getLocalIndex: function(header) {
                var index = 0;
                for (var i = 0, l = header.getParent().getSubHeaders().length; i < l; i++) {
                    var child = header.getParent().getSubHeaders()[i];
                    if (child === header) {
                        break
                    }
                    index += child.getDeepChildCount()
                }
                return index
            },
            getRowLevelCount: function(level) {
                return this.getLevelCount(this.rowHeader.getSubHeaders(), level, 0)
            },
            getColumnLevelCount: function(level) {
                return this.getLevelCount(this.columnHeader.getSubHeaders(), level, 0)
            },
            getLevelCount: function(headers, level, currentLevel) {
                if (level === currentLevel) {
                    return headers.length
                }
                if (level < currentLevel) {
                    return 0
                }
                var count = 0;
                for (var i = 0; i < headers.length; i++) {
                    var header = headers[i];
                    count += this.getLevelCount(header.getSubHeaders(), level, currentLevel + 1)
                }
                return count
            },
            getRowDepth: function(exclude) {
                return this.getDepth(this.rowHeader.getSubHeaders(), exclude)
            },
            getColumnDepth: function(exclude) {
                return this.getDepth(this.columnHeader.getSubHeaders(), exclude)
            },
            getDepth: function(headers, exclude) {
                if (headers.length === 0) {
                    return 0
                }
                if (headers.length === 1) {
                    if (headers[0] === exclude) {
                        return 0
                    }
                }
                var depth = 0;
                for (var i = 0; i < headers.length; i++) {
                    var header = headers[i];
                    if (header === exclude) {
                        continue
                    }
                    depth = Math.max(depth, this.getDepth(header.getSubHeaders(), exclude))
                }
                return depth + 1
            },
            collectHeights: function(headers, heights, level) {
                if (heights.length <= level) {
                    heights.push(0)
                }
                var maxHeight = 0;
                var setHeight = false;
                if (level < this.columnHeights.length) {
                    var height = this.columnHeights[level];
                    if (height > 0) {
                        setHeight = true;
                        maxHeight = height
                    }
                }
                var i;
                if (!setHeight) {
                    maxHeight = heights[level];
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        if (maxHeight < header.getHeight()) {
                            maxHeight = header.getHeight()
                        }
                    }
                }
                for (i = 0; i < headers.length; i++) {
                    this.collectHeights(headers[i].getSubHeaders(), heights, level + 1)
                }
                heights[level] = maxHeight
            },
            getTotalColumnHeightIf: function(header, height) {
                var maxHeightsPerLevel = [];
                this.collectHeightsIf(this.columnHeader.getSubHeaders(), header, height, maxHeightsPerLevel, 0);
                var totalHeight = 0;
                for (var i = 0; i < maxHeightsPerLevel.length; i++) {
                    totalHeight += maxHeightsPerLevel[i]
                }
                return totalHeight
            },
            collectHeightsIf: function(headers, desiredHeader, desiredHeight, heights, level) {
                if (heights.length <= level) {
                    heights.push(0)
                }
                var maxHeight = 0;
                var setHeight = false;
                var height;
                if (level < this.columnHeights.length) {
                    height = this.columnHeights[level];
                    if (height > 0) {
                        setHeight = true;
                        maxHeight = height
                    }
                }
                var i;
                if (!setHeight) {
                    maxHeight = heights[level];
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        height = header.getHeight();
                        if (header === desiredHeader) {
                            height = desiredHeight
                        }
                        if (maxHeight < height) {
                            maxHeight = height
                        }
                    }
                }
                for (i = 0; i < headers.length; i++) {
                    this.collectHeightsIf(headers[i].getSubHeaders(), desiredHeader, desiredHeight, heights, level + 1)
                }
                heights[level] = maxHeight
            },
            collectWidths: function(headers, widths, level) {
                if (widths.length <= level) {
                    widths.push(0)
                }
                var maxWidth = 0;
                var setWidth = false;
                if (level < this.rowWidths.length) {
                    var width = this.rowWidths[level];
                    if (width > 0) {
                        setWidth = true;
                        maxWidth = width
                    }
                }
                var i;
                if (!setWidth) {
                    maxWidth = widths[level];
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        if (maxWidth < header.getWidth()) {
                            maxWidth = header.getWidth()
                        }
                    }
                }
                for (i = 0; i < headers.length; i++) {
                    this.collectWidths(headers[i].getSubHeaders(), widths, level + 1)
                }
                widths[level] = maxWidth
            },
            getTotalRowWidthIf: function(header, width) {
                var maxWidthsPerLevel = [];
                this.collectWidthsIf(this.rowHeader.getSubHeaders(), header, width, maxWidthsPerLevel, 0);
                var totalWidth = 0;
                for (var i = 0; i < maxWidthsPerLevel.length; i++) {
                    totalWidth += maxWidthsPerLevel[i]
                }
                return totalWidth
            },
            collectWidthsIf: function(headers, desiredHeader, desiredWidth, widths, level) {
                if (widths.length <= level) {
                    widths.push(0)
                }
                var maxWidth = 0;
                var setWidth = false;
                var width;
                if (level < this.rowWidths.length) {
                    width = this.rowWidths[level];
                    if (width > 0) {
                        setWidth = true;
                        maxWidth = width
                    }
                }
                var i;
                if (!setWidth) {
                    maxWidth = widths[level];
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        width = header.getWidth();
                        if (header === desiredHeader) {
                            width = desiredWidth
                        }
                        if (maxWidth < width) {
                            maxWidth = width
                        }
                    }
                }
                for (i = 0; i < headers.length; i++) {
                    this.collectWidthsIf(headers[i].getSubHeaders(), desiredHeader, desiredWidth, widths, level + 1)
                }
                widths[level] = maxWidth
            },
            getDepth: function(headers) {
                if (headers.length === 0) {
                    return 0
                }
                var maxDepth = 0;
                for (var i = 0; i < headers.length; i++) {
                    maxDepth = Math.max(maxDepth, this.getDepth(headers[i].getSubHeaders()))
                }
                return maxDepth + 1
            },
            getColumnLevelHeight: function(level, headers, currentLevel) {
                if (!headers) {
                    if (level < this.columnHeights.length) {
                        var height = this.columnHeights[level];
                        if (height > 0) {
                            return height
                        }
                    }
                    headers = this.columnHeader.getSubHeaders()
                }
                if (!currentLevel) {
                    currentLevel = 0
                }
                var maxHeight = 0;
                var i;
                if (level === currentLevel) {
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        if (maxHeight < header.getHeight()) {
                            maxHeight = header.getHeight()
                        }
                    }
                    return maxHeight
                }
                for (i = 0; i < headers.length; i++) {
                    maxHeight = Math.max(maxHeight, this.getColumnLevelHeight(level, headers[i].getSubHeaders(), currentLevel + 1))
                }
                return maxHeight
            },
            getRowLevelWidth: function(level, headers, currentLevel) {
                if (!headers) {
                    if (level < this.rowWidths.length) {
                        var width = this.rowWidths[level];
                        if (width > 0) {
                            return width
                        }
                    }
                    headers = this.rowHeader.getSubHeaders()
                }
                if (!currentLevel) {
                    currentLevel = 0
                }
                var maxWidth = 0;
                var i;
                if (level === currentLevel) {
                    for (i = 0; i < headers.length; i++) {
                        var header = headers[i];
                        if (maxWidth < header.getWidth()) {
                            maxWidth = header.getWidth()
                        }
                    }
                    return maxWidth
                }
                for (i = 0; i < headers.length; i++) {
                    maxWidth = Math.max(maxWidth, this.getRowLevelWidth(level, headers[i].getSubHeaders(), currentLevel + 1))
                }
                return maxWidth
            },
            collectHeaderBounds: function(header, bounds, customData) {
                if (header === customData.header) {
                    customData.bounds = bounds
                } else {
                    if (customData.includeSubHeaders) {
                        if (header.isDescendantOf(customData.header)) {
                            customData.bounds = bounds.union(customData.bounds)
                        }
                    }
                }
            },
            removeLastChildDeep: function(header) {
                if (header.getSubHeaders().length === 0) {
                    return
                }
                var lastChild = header.getSubHeaders()[header.getSubHeaders().length - 1];
                if (lastChild.getSubHeaders().length === 0) {
                    if (header.isColumnHeader()) {
                        this.removeColumnHeader(lastChild)
                    } else {
                        this.removeRowHeader(lastChild)
                    }
                    this.ensureNonEmpty(header);
                    return
                }
                this.removeLastChildDeep(lastChild)
            },
            ensureNonEmpty: function(header) {
                if (header.getSubHeaders().length > 0) {
                    return
                }
                var parent = header.getParent();
                if (!parent) {
                    return
                }
                if (header.isRowHeader()) {
                    this.removeRowHeader(header)
                } else {
                    this.removeColumnHeader(header)
                }
                this.ensureNonEmpty(parent)
            },
            getHeaderBounds: function(header, includeSubHeaders) {
                var data = {
                    header: header,
                    includeSubHeaders: includeSubHeaders
                };
                var _this = this;
                var callback = function(header, bounds, data) {
                    _this.collectHeaderBounds(header, bounds, data)
                };
                var x = 0;
                var y = 0;
                if (this.hookHeaders && this.parent.getScrollX && this.parent.getScrollY) {
                    x = this.parent.getScrollX();
                    y = this.parent.getScrollY()
                }
                this.processRowHeaders(callback, x, y, data);
                this.processColumnHeaders(callback, x, y, data);
                return data.bounds
            },
            getColumnHeaderBounds: function() {
                return this.getHeaderBounds(this.columnHeader, true)
            },
            getRowHeaderBounds: function() {
                return this.getHeaderBounds(this.rowHeader, true)
            },
            getCellBounds: function(cell) {
                var columnStart = -1;
                var columnEnd = -1;
                var rowStart = -1;
                var rowEnd = -1;
                if (cell.getColumnStart && cell.getColumnEnd && cell.getRowStart && cell.getRowEnd) {
                    columnStart = cell.getColumnStart();
                    columnEnd = cell.getColumnEnd();
                    rowStart = cell.getRowStart();
                    rowEnd = cell.getRowEnd()
                } else {
                    for (var c = 0, cl = this.cells.getColumnCount(); c < cl; c++) {
                        for (var r = 0, rl = this.cells.getRowCount(); r < rl; r++) {
                            if (this.cells.get(c, r) == cell) {
                                columnStart = c;
                                columnEnd = c;
                                rowStart = r;
                                rowEnd = r;
                                break
                            }
                        }
                        if (columnStart !== -1) {
                            break
                        }
                    }
                }
                if (columnStart !== -1) {
                    var x = this.leftMargin + this.getTotalRowWidth();
                    var y = this.topMargin + this.getTotalColumnHeight();
                    var width = 0;
                    var height = 0;
                    var i;
                    var j;
                    for (i = 0; i < columnStart; i++) {
                        x += this.getColumn(i).getWidth()
                    }
                    for (j = 0; j < rowStart; j++) {
                        y += this.getRow(j).getHeight()
                    }
                    for (i = columnStart; i <= columnEnd; i++) {
                        width += this.getColumn(i).getWidth()
                    }
                    for (j = rowStart; j <= rowEnd; j++) {
                        height += this.getRow(j).getHeight()
                    }
                    return new Rect(x, y, width, height)
                }
                return Rect.empty
            },
            getColumnHeaders: function() {
                return this.columnHeader.getSubHeaders()
            },
            getRowHeaders: function() {
                return this.rowHeader.getSubHeaders()
            },
            getColumnCount: function() {
                var count = 0;
                var headers = this.columnHeader.getSubHeaders();
                for (var i = 0, l = headers.length; i < l; i++) {
                    var header = headers[i];
                    count += header.getDeepChildCount()
                }
                return count
            },
            setColumnCount: function(value) {
                if (value < 0) {
                    return
                }
                var columnCount = this.getColumnCount();
                if (value === columnCount) {
                    return
                }
                if (value > columnCount) {
                    for (var i = 0; i < value - columnCount; i++) {
                        this.addColumnHeader(new mlanes.Header(), this.columnHeader)
                    }
                }
                if (value < columnCount) {
                    var columnsToRemove = columnCount - value;
                    while (columnsToRemove > 0) {
                        this.removeLastChildDeep(this.columnHeader);
                        columnsToRemove--
                    }
                }
            },
            getRowCount: function() {
                var count = 0;
                var headers = this.rowHeader.getSubHeaders();
                for (var i = 0, l = headers.length; i < l; i++) {
                    var header = headers[i];
                    count += header.getDeepChildCount()
                }
                return count
            },
            setRowCount: function(value) {
                if (value < 0) {
                    return
                }
                var rowCount = this.getRowCount();
                if (value == rowCount) {
                    return
                }
                if (value > rowCount) {
                    for (var i = 0; i < value - rowCount; i++) {
                        this.addRowHeader(new mlanes.Header(), this.rowHeader)
                    }
                }
                if (value < rowCount) {
                    var rowsToRemove = rowCount - value;
                    while (rowsToRemove > 0) {
                        this.removeLastChildDeep(this.rowHeader);
                        rowsToRemove--
                    }
                }
            },
            get: function(column, row) {
                if (!isNaN(column) && !isNaN(row)) {
                    return this.cells.get(column, row)
                }
                if (row && row.getSubHeaders && row.getSubHeaders().length === 0 && column && column.getSubHeaders && column.getSubHeaders().length === 0) {
                    var columnIndex = this.getIndex(column);
                    var rowIndex = this.getIndex(row);
                    return this.cells.get(columnIndex, rowIndex)
                } else {
                    if (!column || !column.getSubHeaders) {
                        column = this.columnHeader
                    }
                    if (!row || !row.getSubHeaders) {
                        row = this.rowHeader
                    }
                    var columnStartIndex = this.getIndex(column);
                    var columnEndIndex = columnStartIndex + column.getDeepChildCount() - 1;
                    var rowStartIndex = this.getIndex(row);
                    var rowEndIndex = rowStartIndex + row.getDeepChildCount() - 1;
                    return new mlanes.CellCluster(this, columnStartIndex, columnEndIndex, rowStartIndex, rowEndIndex)
                }
            },
            getLeftMargin: function() {
                return this.leftMargin
            },
            setLeftMargin: function(value) {
                if (this.leftMargin === value) {
                    return
                }
                this.leftMargin = value;
                this.invalidate()
            },
            getTopMargin: function() {
                return this.topMargin
            },
            setTopMargin: function(value) {
                if (this.topMargin === value) {
                    return
                }
                this.topMargin = value;
                this.invalidate()
            },
            getMinHeaderSize: function() {
                return this.minHeaderSize
            },
            setMinHeaderSize: function(value) {
                if (value <= 0) {
                    return
                }
                if (this.minHeaderSize === value) {
                    return
                }
                this.minHeaderSize = value;
                for (var i = 0, l = this.columnHeader.getSubHeaders().length; i < l; i++) {
                    var header = this.columnHeader.getSubHeaders()[i];
                    header.ensureWidth(this.minHeaderSize)
                }
            },
            getTotalColumnHeight: function() {
                var maxHeightsPerLevel = [];
                this.collectHeights(this.columnHeader.getSubHeaders(), maxHeightsPerLevel, 0);
                var totalHeight = 0;
                for (var i = 0; i < maxHeightsPerLevel.length; i++) {
                    totalHeight += maxHeightsPerLevel[i]
                }
                return totalHeight
            },
            getTotalRowWidth: function() {
                var maxWidthsPerLevel = [];
                this.collectWidths(this.rowHeader.getSubHeaders(), maxWidthsPerLevel, 0);
                var totalWidth = 0;
                for (var i = 0; i < maxWidthsPerLevel.length; i++) {
                    totalWidth += maxWidthsPerLevel[i]
                }
                return totalWidth
            },
            getColumnDepth: function() {
                return this.getDepth(this.columnHeader.getSubHeaders())
            },
            getRowDepth: function() {
                return this.getDepth(this.rowHeader.getSubHeaders())
            },
            getTopLeftAreaStyle: function() {
                return this.topLeftAreaStyle
            },
            setTopLeftAreaStyle: function(value) {
                if (this.topLeftAreaStyle === value) {
                    return
                }
                this.topLeftAreaStyle = value;
                this.invalidate()
            },
            getTopLeftAreaText: function() {
                return this.topLeftAreaText
            },
            setTopLeftAreaText: function(value) {
                if (this.topLeftAreaText === value) {
                    return
                }
                this.topLeftAreaText = value;
                this.invalidate()
            },
            getHookHeaders: function() {
                return this.hookHeaders
            },
            setHookHeaders: function(value) {
                if (this.hookHeaders === value) {
                    return
                }
                this.hookHeaders = value;
                this.invalidate()
            },
            getHeadersOnTop: function() {
                return this.headersOnTop
            },
            setHeadersOnTop: function(value) {
                if (this.headersOnTop === value) {
                    return
                }
                this.headersOnTop = value;
                this.invalidate()
            },
            getRowHeadersWidths: function() {
                return this.rowWidths
            },
            setRowHeadersWidths: function(value) {
                if (!value) {
                    throw new Error("The row widths array cannot be null.")
                }
                this.rowWidths = value;
                this.invalidate()
            },
            getColumnHeadersHeights: function() {
                return this.columnHeights
            },
            setColumnHeadersHeights: function(value) {
                if (!value) {
                    throw new Error("The row widths array cannot be null.")
                }
                this.columnHeights = value;
                this.invalidate()
            },
            processColumnHeaders: function(callback, scrollX, scrollY, customData) {
                var totalColumnHeight = this.getTotalColumnHeight();
                var totalRowWidth = this.getTotalRowWidth();
                var columnLevelCount = this.getColumnDepth();
                var y = this.topMargin;
                var current = [];
                var currentY = new Dictionary();
                var header;
                for (var i = 0, l = this.columnHeader.getSubHeaders().length; i < l; i++) {
                    header = this.columnHeader.getSubHeaders()[i];
                    current.push(header);
                    currentY.set(header, y)
                }
                var level = 0;
                while (current.length > 0) {
                    var x = this.leftMargin + totalRowWidth;
                    var levelHeight = this.getColumnLevelHeight(level);
                    var next = [];
                    var nextY = new Dictionary();
                    for (var i = 0; i < current.length; i++) {
                        var header = current[i];
                        if (header.getSubHeaders().length === 0) {
                            if (level !== columnLevelCount - 1) {
                                next.push(header);
                                nextY.set(header, currentY.get(header));
                                x += header.getWidth();
                                continue
                            }
                        }
                        var dx = x;
                        var dy = currentY.get(header);
                        var bounds = new MindFusion.Drawing.Rect(dx, dy, header.getWidth(), y + levelHeight - dy);
                        bounds.y += scrollY;
                        callback(header, bounds, customData);
                        x += header.getWidth();
                        for (var j = 0, jl = header.getSubHeaders().length; j < jl; j++) {
                            var child = header.getSubHeaders()[j];
                            next.push(child);
                            nextY.set(child, y + levelHeight)
                        }
                    }
                    y += levelHeight;
                    level++;
                    current = next;
                    currentY = nextY
                }
            },
            processRowHeaders: function(callback, scrollX, scrollY, customData) {
                var totalColumnHeight = this.getTotalColumnHeight();
                var totalRowWidth = this.getTotalRowWidth();
                var rowLevelCount = this.getRowDepth();
                var x = this.leftMargin;
                var current = [];
                var currentX = new Dictionary();
                var header;
                for (var i = 0, l = this.rowHeader.getSubHeaders().length; i < l; i++) {
                    var header = this.rowHeader.getSubHeaders()[i];
                    current.push(header);
                    currentX.set(header, x)
                }
                var level = 0;
                while (current.length > 0) {
                    var y = this.topMargin + totalColumnHeight;
                    var levelWidth = this.getRowLevelWidth(level);
                    var next = [];
                    var nextX = new Dictionary();
                    for (var i = 0; i < current.length; i++) {
                        var header = current[i];
                        if (header.getSubHeaders().length === 0) {
                            if (level !== rowLevelCount - 1) {
                                next.push(header);
                                nextX.set(header, currentX.get(header));
                                y += header.getHeight();
                                continue
                            }
                        }
                        var dx = currentX.get(header);
                        var dy = y;
                        var bounds = new MindFusion.Drawing.Rect(dx, dy, x + levelWidth - dx, header.getHeight());
                        bounds.x += scrollX;
                        callback(header, bounds, customData);
                        y += header.getHeight();
                        for (var j = 0, jl = header.getSubHeaders().length; j < jl; j++) {
                            var child = header.getSubHeaders()[j];
                            next.push(child);
                            nextX.set(child, x + levelWidth)
                        }
                    }
                    x += levelWidth;
                    level++;
                    current = next;
                    currentX = nextX
                }
            },
            drawFirst: function(context) {
                this.drawCells(context);
                if (!this.headersOnTop) {
                    this.drawHeaders(context)
                }
            },
            drawLast: function(context) {
                if (this.headersOnTop) {
                    this.drawHeaders(context)
                }
            },
            drawHeaders: function(context) {
                var data = {
                    context: context
                };
                var _this = this;
                var callback = function(header, bounds, data) {
                    _this.drawHeader(header, bounds, data)
                };
                var x = 0;
                var y = 0;
                if (this.hookHeaders && this.parent.getScrollX && this.parent.getScrollY) {
                    x = this.parent.getScrollX();
                    y = this.parent.getScrollY()
                }
                this.processColumnHeaders(callback, x, y, data);
                this.processRowHeaders(callback, x, y, data);
                if (this.cells.getColumnCount() > 0 && this.cells.getRowCount() > 0) {
                    this.drawTopLeftArea(context, x, y)
                }
            },
            drawTopLeftArea: function(context, x, y) {
                var totalColumnHeight = this.getTotalColumnHeight();
                var totalRowWidth = this.getTotalRowWidth();
                var bounds = new MindFusion.Drawing.Rect(this.leftMargin + x, this.topMargin + y, totalRowWidth, totalColumnHeight);
                if (this.topLeftAreaStyle) {
                    this.drawRectangle(context, bounds, this.topLeftAreaStyle)
                }
                var fontName = this.getEffectiveFontName(this.topLeftAreaStyle);
                var fontSize = this.getEffectiveFontSize(this.topLeftAreaStyle);
                var textColor = this.getEffectiveTextColor(this.topLeftAreaStyle);
                var textAlignment = this.getEffectiveTextAlignment(this.topLeftAreaStyle);
                var lineAlignment = this.getEffectiveLineAlignment(this.topLeftAreaStyle);
                this.drawText(context, this.getTopLeftAreaText(), fontName, fontSize, textAlignment, lineAlignment, textColor, bounds, false)
            },
            drawRectangle: function(context, bounds, style) {
                var background = MindFusion.Diagramming.Utils.getBrush(context, this.getEffectiveBackground(style), bounds);
                if (background) {
                    context.fillStyle = background;
                    context.fillRect(bounds.x, bounds.y, bounds.width, bounds.height)
                }
                var leftBorderPen = this.getEffectiveLeftBorderPen(style);
                var leftBorderThickness = this.getEffectiveLeftBorderThickness(style);
                if (leftBorderPen && leftBorderThickness) {
                    context.beginPath();
                    context.moveTo(bounds.left(), bounds.top());
                    context.lineTo(bounds.left(), bounds.bottom());
                    context.strokeStyle = leftBorderPen;
                    context.lineWidth = leftBorderThickness / context._mf_scale;
                    context.stroke()
                }
                var topBorderPen = this.getEffectiveTopBorderPen(style);
                var topBorderThickness = this.getEffectiveTopBorderThickness(style);
                if (topBorderPen && topBorderThickness) {
                    context.beginPath();
                    context.moveTo(bounds.left(), bounds.top());
                    context.lineTo(bounds.right(), bounds.top());
                    context.strokeStyle = topBorderPen;
                    context.lineWidth = topBorderThickness / context._mf_scale;
                    context.stroke()
                }
                var rightBorderPen = this.getEffectiveRightBorderPen(style);
                var rightBorderThickness = this.getEffectiveRightBorderThickness(style);
                if (rightBorderPen && rightBorderThickness) {
                    context.beginPath();
                    context.moveTo(bounds.right(), bounds.top());
                    context.lineTo(bounds.right(), bounds.bottom());
                    context.strokeStyle = rightBorderPen;
                    context.lineWidth = rightBorderThickness / context._mf_scale;
                    context.stroke()
                }
                var bottomBorderPen = this.getEffectiveBottomBorderPen(style);
                var bottomBorderThickness = this.getEffectiveBottomBorderThickness(style);
                if (bottomBorderPen && bottomBorderThickness) {
                    context.beginPath();
                    context.moveTo(bounds.left(), bounds.bottom());
                    context.lineTo(bounds.right(), bounds.bottom());
                    context.strokeStyle = bottomBorderPen;
                    context.lineWidth = bottomBorderThickness / context._mf_scale;
                    context.stroke()
                }
            },
            drawText: function(context, text, fontName, fontSize, textAlignment, lineAlignment, color, bounds, rotate) {
                if (!text) {
                    return
                }
                context.save();
                context.rect(bounds.x, bounds.y, bounds.width, bounds.height);
                context.clip();
                var off = 0;
                if (rotate) {
                    if (bounds.width < bounds.height) {
                        off = Math.max(bounds.width, bounds.height) / 2
                    } else {
                        off = Math.min(bounds.width, bounds.height) / 2
                    }
                    context.translate(bounds.x + off, bounds.y + off);
                    context.rotate(3 * Math.PI / 2);
                    context.translate(-bounds.x - off, -bounds.y - off)
                }
                context.fillStyle = color;
                context.textBaseline = "top";
                context.font = fontSize + "px " + fontName;
                var destWidth = bounds.width;
                var destHeight = bounds.height;
                if (rotate) {
                    destWidth = bounds.height;
                    destHeight = bounds.width
                }
                var lineHeight = fontSize;
                var lines = this.wrapText(context, text, destWidth);
                if (lines) {
                    var x = bounds.x;
                    var y = bounds.y;
                    context.textAlign = "left";
                    if (textAlignment == MindFusion.Diagramming.Alignment.Center) {
                        if (rotate) {
                            x = bounds.x + off
                        } else {
                            x = bounds.x + bounds.width / 2
                        }
                        context.textAlign = "center"
                    }
                    if (textAlignment == MindFusion.Diagramming.Alignment.Far) {
                        if (rotate) {
                            x = bounds.x + 2 * off
                        } else {
                            x = bounds.x + bounds.width
                        }
                        context.textAlign = "right"
                    }
                    var totalHeight = lines.length * lineHeight;
                    if (totalHeight < destHeight) {
                        if (lineAlignment == MindFusion.Diagramming.Alignment.Center) {
                            y += (destHeight - totalHeight) / 2
                        }
                        if (lineAlignment == MindFusion.Diagramming.Alignment.Far) {
                            y += destHeight - totalHeight
                        }
                    }
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];
                        context.fillText(line, x, y);
                        y += lineHeight
                    }
                }
                context.restore()
            },
            wrapText: function(context, text, maxWidth) {
                var lines = text.split("\n");
                if (maxWidth == Number.MAX_VALUE) {
                    return lines
                }
                var wrappedLines = [];
                for (var i = 0; i < lines.length; i++) {
                    var words = lines[i].split(" ");
                    var lastWord = "";
                    for (var i = 0; i < words.length; i++) {
                        var word = words[i];
                        m = context.measureText(lastWord + word).width;
                        if (m < maxWidth) {
                            if (i === 0) {
                                lastWord += word
                            } else {
                                lastWord += " " + word
                            }
                        } else {
                            if (lastWord != "") {
                                wrappedLines.push(lastWord)
                            }
                            lastWord = word
                        }
                        if (i === words.length - 1) {
                            wrappedLines.push(lastWord);
                            break
                        }
                    }
                }
                return wrappedLines
            },
            drawHeader: function(header, bounds, customData) {
                var renderData = customData;
                var context = customData.context;
                this.drawRectangle(context, bounds, header.getStyle());
                var headerStyle = header.getStyle();
                var fontName = this.getEffectiveFontName(headerStyle);
                var fontSize = this.getEffectiveFontSize(headerStyle);
                var textColor = this.getEffectiveTextColor(headerStyle);
                var textAlignment = this.getEffectiveTextAlignment(headerStyle);
                var lineAlignment = this.getEffectiveLineAlignment(headerStyle);
                this.drawText(context, header.getTitle(), fontName, fontSize, textAlignment, lineAlignment, textColor, bounds, header.getRotateTitle())
            },
            drawCells: function(context) {
                var totalColumnHeight = this.getTotalColumnHeight();
                var totalRowWidth = this.getTotalRowWidth();
                var x = this.leftMargin + totalRowWidth;
                for (var c = 0; c < this.getColumnCount(); c++) {
                    var column = this.getColumn(c);
                    var columnWidth = column.getWidth();
                    var y = this.topMargin + totalColumnHeight;
                    for (var r = 0; r < this.getRowCount(); r++) {
                        var row = this.getRow(r);
                        var rowHeight = row.getHeight();
                        var cell = this.cells.get(c, r);
                        var bounds = new MindFusion.Drawing.Rect(x, y, columnWidth, rowHeight);
                        y += row.getHeight();
                        var cellStyle = cell.getStyle();
                        this.drawRectangle(context, bounds, cellStyle);
                        var text = cell.getText();
                        if (text) {
                            var fontName = this.getEffectiveFontName(cellStyle);
                            var fontSize = this.getEffectiveFontSize(cellStyle);
                            var textColor = this.getEffectiveTextColor(cellStyle);
                            var textAlignment = this.getEffectiveTextAlignment(cellStyle);
                            var lineAlignment = this.getEffectiveLineAlignment(cellStyle);
                            this.drawText(context, cell.getText(), fontName, fontSize, textAlignment, lineAlignment, textColor, bounds, false)
                        }
                    }
                    x += column.getWidth()
                }
            },
            collectLeaves: function(headers, leaves) {
                for (var i = 0; i < headers.length; i++) {
                    if (headers[i].subHeaders.length == 0) {
                        leaves.push(headers[i]);
                        continue
                    }
                    this.collectLeaves(headers[i].subHeaders, leaves)
                }
            },
            onColumnHeaderHeightChanged: function(header, oldValue) {
                var currentHeight = this.getTotalColumnHeight();
                var previousHeight = this.getTotalColumnHeightIf(header, oldValue);
                var rowHeaders = [];
                this.collectLeaves(this.rowHeader.subHeaders, rowHeaders);
                var columnHeaders = [];
                this.collectLeaves(this.columnHeader.subHeaders, columnHeaders);
                if (previousHeight != currentHeight) {
                    var offset = currentHeight - previousHeight;
                    var columnCount = this.getColumnCount();
                    var rowCount = this.getRowCount();
                    var x = this.leftMargin + this.getTotalRowWidth();
                    for (var c = 0; c < columnCount; c++) {
                        var y = this.topMargin + this.getTotalColumnHeight();
                        for (var r = 0; r < rowCount; r++) {
                            var cell = this.cells.get(c, r);
                            var bounds = new Rect(x, y, columnHeaders[c].width, rowHeaders[r].height);
                            var oldBounds = bounds;
                            oldBounds.y -= offset;
                            y += rowHeaders[r].height
                        }
                        x += columnHeaders[c].width
                    }
                }
            },
            onRowHeaderWidthChanged: function(header, oldValue) {
                var currentWidth = this.getTotalRowWidth();
                var previousWidth = this.getTotalRowWidthIf(header, oldValue);
                var rowHeaders = [];
                this.collectLeaves(this.rowHeader.subHeaders, rowHeaders);
                var columnHeaders = [];
                this.ollectLeaves(this.columnHeader.subHeaders, columnHeaders);
                if (previousWidth != currentWidth) {
                    var offset = currentWidth - previousWidth;
                    var columnCount = this.getColumnCount();
                    var rowCount = this.getRowCount();
                    var x = this.leftMargin + this.getTotalRowWidth();
                    for (var c = 0; c < columnCount; c++) {
                        var y = this.topMargin + getTotalColumnHeight();
                        for (var r = 0; r < rowCount; r++) {
                            var cell = this.cells.get(c, r);
                            var bounds = new Rect(x, y, columnHeaders[c].width, rowHeaders[r].height);
                            var oldBounds = bounds;
                            oldBounds.x -= offset;
                            y += rowHeaders[r].height
                        }
                        x += columnHeaders[c].width
                    }
                }
            },
            resolveEffectiveStyle: function(check) {
                if (this.parent) {
                    var parentStyle = this.parent.style;
                    if (parentStyle && check.apply(parentStyle)) {
                        return parentStyle
                    }
                    var theme = this.parent.theme;
                    if (theme) {
                        var themeStyle = this.resolveInheritedStyle(check, theme);
                        if (themeStyle) {
                            return themeStyle
                        }
                    }
                }
                return this.resolveInheritedStyle(check, MindFusion.Diagramming.Theme.Default)
            },
            resolveInheritedStyle: function(check, theme) {
                var diagramStyle = theme.styles["std:Diagram"];
                if (diagramStyle) {
                    if (check.apply(diagramStyle)) {
                        return diagramStyle
                    }
                }
                return null
            },
            getEffectivePropertyValue: function(style, getter, parentGetter) {
                var value;
                if (style) {
                    value = getter.apply(style);
                    if (value !== undefined) {
                        return value
                    }
                }
                if (this.style) {
                    value = getter.apply(this.style);
                    if (value !== undefined) {
                        return value
                    }
                }
                if (parentGetter) {
                    var resolverdStyle = this.resolveEffectiveStyle(parentGetter);
                    if (resolverdStyle) {
                        return parentGetter.apply(resolverdStyle)
                    }
                }
            },
            getEffectiveBackground: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getBackgroundBrush, MindFusion.Diagramming.Style.prototype.getBrush);
                if (value !== undefined) {
                    return value
                }
                return "white"
            },
            getEffectiveLeftBorderPen: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getLeftBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (value !== undefined) {
                    return value
                }
                return "black"
            },
            getEffectiveLeftBorderThickness: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getLeftBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (value !== undefined) {
                    return value
                }
                return 0
            },
            getEffectiveTopBorderPen: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getTopBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (value !== undefined) {
                    return value
                }
                return "black"
            },
            getEffectiveTopBorderThickness: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getTopBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (value !== undefined) {
                    return value
                }
                return 0
            },
            getEffectiveRightBorderPen: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getRightBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (value !== undefined) {
                    return value
                }
                return "black"
            },
            getEffectiveRightBorderThickness: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getRightBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (value !== undefined) {
                    return value
                }
                return 0
            },
            getEffectiveBottomBorderPen: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getBottomBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (value !== undefined) {
                    return value
                }
                return "black"
            },
            getEffectiveBottomBorderThickness: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getBottomBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (value !== undefined) {
                    return value
                }
                return 0
            },
            getEffectiveFontName: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getFontName, MindFusion.Diagramming.Style.prototype.getFontName);
                if (value !== undefined) {
                    return value
                }
                return "sans-serif"
            },
            getEffectiveFontSize: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getFontSize, MindFusion.Diagramming.Style.prototype.getFontSize);
                if (value !== undefined) {
                    return value
                }
                return 4
            },
            getEffectiveTextColor: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getTextColor, MindFusion.Diagramming.Style.prototype.getTextColor);
                if (value !== undefined) {
                    return value
                }
                return "black"
            },
            getEffectiveTextAlignment: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getTextAlignment);
                if (value !== undefined) {
                    return value
                }
                return MindFusion.Diagramming.Alignment.Center
            },
            getEffectiveLineAlignment: function(style) {
                var value = this.getEffectivePropertyValue(style, mlanes.Style.prototype.getLineAlignment);
                if (value !== undefined) {
                    return value
                }
                return MindFusion.Diagramming.Alignment.Center
            },
            getColumn: function(index) {
                return this.getHeader(this.columnHeader.getSubHeaders(), index)
            },
            getRow: function(index) {
                return this.getHeader(this.rowHeader.getSubHeaders(), index)
            },
            hitTestHeader: function(header, bounds, customData) {
                if (bounds.containsPoint(customData.testPoint)) {
                    customData.hitHeader = header;
                    customData.headerBounds = bounds
                }
            },
            getHeaderFromPoint: function(point, headerBounds, scrollPosition) {
                if (!scrollPosition) {
                    scrollPosition = new Point(0, 0)
                }
                var data = {
                    testPoint: point
                };
                var _this = this;
                var callback = function(header, bounds, data) {
                    _this.hitTestHeader(header, bounds, data)
                };
                var x = 0;
                var y = 0;
                if (this.hookHeaders && scrollPosition) {
                    x = scrollPosition.x;
                    y = scrollPosition.y
                }
                this.processColumnHeaders(callback, x, y, data);
                this.processRowHeaders(callback, x, y, data);
                if (headerBounds) {
                    headerBounds.headerBounds = data.headerBounds
                }
                return data.hitHeader
            },
            getCellFromPoint: function(point, cellBounds) {
                var x = point.x - this.getTotalRowWidth() - this.leftMargin;
                var y = point.y - this.getTotalColumnHeight() - this.topMargin;
                var width = 0;
                var height = 0;
                if (x < 0 || y < 0) {
                    return
                }
                var column = -1;
                var row = -1;
                for (var c = 0, cl = this.cells.getColumnCount(); c < cl; c++) {
                    width = this.getColumn(c).getWidth();
                    x -= width;
                    if (x < 0) {
                        column = c;
                        break
                    }
                }
                for (var r = 0; r < this.cells.getRowCount(); r++) {
                    height = this.getRow(r).getHeight();
                    y -= height;
                    if (y < 0) {
                        row = r;
                        break
                    }
                }
                if (column >= 0 && row >= 0) {
                    if (cellBounds) {
                        cellBounds.cellBounds = new MindFusion.Drawing.Rect(point.x - x - width, point.y - y - height, width, height);
                        cellBounds.column = column;
                        cellBounds.row = row
                    }
                    return this.cells.get(column, row)
                }
                return null
            },
            getCellColumn: function(cell) {
                for (var c = 0, cl = this.getColumnCount(); c < cl; c++) {
                    for (var r = 0, rl = this.getRowCount(); r < rl; r++) {
                        if (this.cells.get(c, r) === cell) {
                            return c
                        }
                    }
                }
                return -1
            },
            getCellRow: function(cell) {
                for (var c = 0, cl = this.getColumnCount(); c < cl; c++) {
                    for (var r = 0, rl = this.getRowCount(); r < rl; r++) {
                        if (this.cells.get(c, r) === cell) {
                            return r
                        }
                    }
                }
                return -1
            },
            getColumnIndex: function(column) {
                if (column.getSubHeaders().length > 0) {
                    return -1
                }
                if (column.isRowHeader()) {
                    return -1
                }
                return this.getIndex(column)
            },
            getRowIndex: function(row) {
                if (row.getSubHeaders().length > 0) {
                    return -1
                }
                if (row.isColumnHeader()) {
                    return -1
                }
                return this.getIndex(row)
            },
            getHeader: function(headers, index) {
                var current = 0;
                for (var i = 0; i < headers.length; i++) {
                    var header = headers[i];
                    var from = current;
                    var to = from + header.getDeepChildCount() - 1;
                    if (header.getSubHeaders().length === 0) {
                        if (from <= index && index <= to) {
                            return header
                        }
                    }
                    if (from <= index && index <= to) {
                        return this.getHeader(header.getSubHeaders(), index - current)
                    }
                    current = to + 1
                }
                return null
            },
            invalidate: function(dirty) {
                if (this.parent) {
                    this.parent.invalidate();
                    if (dirty === undefined) {
                        dirty = true
                    }
                    if (dirty && this.parent.setDirty) {
                        this.parent.setDirty(true)
                    }
                }
            },
            getStyle: function() {
                return this.style
            },
            getAllowInplaceEdit: function() {
                return this.allowInplaceEdit
            },
            setAllowInplaceEdit: function(value) {
                this.allowInplaceEdit = value
            },
            getAllowResizeHeaders: function() {
                return this.allowResizeHeaders
            },
            setAllowResizeHeaders: function(value) {
                this.allowResizeHeaders = value
            }
        };
        MindFusion.registerClass(Grid, "MindFusion.Diagramming.Lanes.Grid")
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var Header = mlanes.Header = function() {
            mflayer.initializeBase(Header, this);
            this.subHeaders = [];
            this.width = 0;
            this.height = 0;
            this.resizeType = MindFusion.Diagramming.Lanes.ResizeType.Proportional;
            this.title = "";
            this.rotateTitle = false;
            this.titleColor = "#000000";
            this.style = new mlanes.Style()
        };
        Header.prototype = {
            fromJson: function(json) {
                this.subHeaders = [];
                for (var i = 0; i < json.subHeaders.length; i++) {
                    var header = new mlanes.Header();
                    header.fromJson(json.subHeaders[i]);
                    header.parent = this;
                    this.subHeaders.push(header)
                }
                this.width = json.width || 0;
                this.height = json.height || 0;
                this.resizeType = json.resizeType || MindFusion.Diagramming.Lanes.ResizeType.Proportional;
                this.title = json.title || "";
                this.rotateTitle = json.rotateTitle || false;
                this.titleColor = json.titleColor || "#000000";
                if (json.style) {
                    this.style.fromJson(json.style)
                }
                if (this.getHeight() === 0) {
                    this.height = 20
                }
            },
            toJson: function() {
                var json = {
                    subHeaders: this.serializeSubHeaders(),
                    width: this.width,
                    height: this.height,
                    resizeType: this.resizeType,
                    title: this.title,
                    rotateTitle: this.rotateTitle,
                    titleColor: this.titleColor,
                    style: this.style.toJson()
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                context.writeFloat(this.width, "Width", xmlElement);
                context.writeFloat(this.height, "Height", xmlElement);
                context.writeInt(this.resizeType, "ResizeType", xmlElement);
                context.writeString(this.title, "Title", xmlElement);
                context.writeBool(this.rotateTitle, "RotateTitle", xmlElement);
                context.writeColor(this.titleColor, "TitleColor", xmlElement);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var font = {};
                    if (this.style.fontName) {
                        font.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        font.size = this.style.fontSize
                    }
                    context.writeFont(font, "TitleFont", xmlElement)
                }
                if (this.style && (this.style.textAlignment != undefined || this.style.lineAlignment != undefined)) {
                    var stringFormat = {};
                    if (this.style.textAlignment !== undefined) {
                        stringFormat.alignment = this.style.textAlignment
                    }
                    if (this.style.lineAlignment != undefined) {
                        stringFormat.lineAlignment = this.style.lineAlignment
                    }
                    context.writeStringFormat(stringFormat, "TitleFormat", xmlElement)
                }
                var styleElement = context.addChildElement("Style", xmlElement);
                this.style.saveToXml(styleElement, context);
                var subHeadersElement = context.addChildElement("SubHeaders", xmlElement);
                for (var i = 0; i < this.subHeaders.length; i++) {
                    context.saveHeaderToXml(this.subHeaders[i], subHeadersElement, "Header")
                }
            },
            loadFromXml: function(xmlElement, context) {
                this.width = context.readFloat("Width", xmlElement);
                this.height = context.readFloat("Height", xmlElement);
                this.resizeType = context.readInt("ResizeType", xmlElement);
                this.title = context.readString("Title", xmlElement);
                this.rotateTitle = context.readBool("RotateTitle", xmlElement);
                this.titleColor = context.readColor("TitleColor", xmlElement);
                var font = context.readFont("TitleFont", xmlElement);
                if (font) {
                    if (font.name) {
                        this.style.fontName = font.name
                    }
                    if (font.size) {
                        this.style.fontSize = font.size
                    }
                }
                var stringFormat = context.readStringFormat("TitleFormat", xmlElement);
                if (stringFormat) {
                    if (stringFormat.alignment) {
                        this.style.textAlignment = stringFormat.alignment
                    }
                    if (stringFormat.lineAlignment) {
                        this.style.lineAlignment = stringFormat.lineAlignment
                    }
                }
                var styleElement = context.selectSingleNode("Style", xmlElement);
                this.style.loadFromXml(styleElement, context);
                var subHeadersElement = context.selectSingleNode("SubHeaders", xmlElement);
                this.subHeaders = [];
                var headerElements = context.selectNodes("Header", subHeadersElement);
                for (var i = 0; i < headerElements.length; i++) {
                    var header = context.loadHeaderFromXml(headerElements[i]);
                    header.parent = this;
                    this.subHeaders.push(header)
                }
            },
            serializeSubHeaders: function() {
                var result = [];
                for (var i = 0; i < this.subHeaders.length; i++) {
                    result.push(this.subHeaders[i].toJson())
                }
                return result
            },
            isDescendantOf: function(header) {
                if (this.parent === header) {
                    return true
                }
                if (!this.parent) {
                    return false
                }
                return this.parent.isDescendantOf(header)
            },
            setParent: function(value) {
                this.parent = value
            },
            setChildrenWidths: function(oldWidth, newWidth) {
                if (this.subHeaders.length === 0) {
                    return
                }
                var proportionalCount = 0;
                var totalProportionalWidth = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    var header = this.subHeaders[i];
                    if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                        proportionalCount++;
                        totalProportionalWidth += header.getWidth()
                    }
                }
                var minSize = this.getMinSize();
                if (oldWidth < newWidth) {
                    if (proportionalCount > 0) {
                        var increase = newWidth - oldWidth;
                        for (var i = 0; i < this.subHeaders.length; i++) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                header.setWidthNoNotify(header.getWidth() + increase * header.getWidth() / totalProportionalWidth)
                            }
                        }
                    } else {
                        var lastHeader = this.subHeaders[this.subHeaders.length - 1];
                        lastHeader.setWidthNoNotify(lastHeader.getWidth() + newWidth - oldWidth)
                    }
                } else {
                    var more = 0;
                    if (proportionalCount > 0) {
                        var decrease = oldWidth - newWidth;
                        for (var i = 0; i < this.subHeaders.length; i++) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                var newHeaderWidth = header.getWidth() - decrease * header.getWidth() / totalProportionalWidth;
                                if (newHeaderWidth < minSize) {
                                    more = minSize - newHeaderWidth;
                                    newHeaderWidth = minSize
                                }
                                header.setWidthNoNotify(newHeaderWidth)
                            }
                        }
                    } else {
                        more = oldWidth - newWidth
                    }
                    if (more > 0) {
                        for (var i = this.subHeaders.length - 1; i >= 0; i--) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Fixed) {
                                var newHeaderWidth = header.getWidth() - more;
                                if (newHeaderWidth < minSize) {
                                    newHeaderWidth = minSize
                                }
                                header.setWidthNoNotify(newHeaderWidth)
                            }
                        }
                    }
                }
            },
            setChildrenHeights: function(oldHeight, newHeight) {
                if (this.subHeaders.length === 0) {
                    return
                }
                var proportionalCount = 0;
                var totalProportionalHeight = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    var header = this.subHeaders[i];
                    if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                        proportionalCount++;
                        totalProportionalHeight += header.getHeight()
                    }
                }
                var minSize = this.getMinSize();
                if (oldHeight < newHeight) {
                    if (proportionalCount > 0) {
                        var increase = newHeight - oldHeight;
                        for (var i = 0; i < this.subHeaders.length; i++) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                header.setHeightNoNotify(header.getHeight() + increase * header.getHeight() / totalProportionalHeight)
                            }
                        }
                    } else {
                        var lastHeader = this.subHeaders[this.subHeaders.length - 1];
                        lastHeader.setHeightNoNotify(lastHeader.getHeight() + newHeight - oldHeight)
                    }
                } else {
                    var more = 0;
                    if (proportionalCount > 0) {
                        var decrease = oldHeight - newHeight;
                        for (var i = 0; i < this.subHeaders.length; i++) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                var newHeaderHeight = header.getHeight() - decrease * header.getHeight() / totalProportionalHeight;
                                if (newHeaderHeight < minSize) {
                                    more = minSize - newHeaderHeight;
                                    newHeaderHeight = minSize
                                }
                                header.setHeightNoNotify(newHeaderHeight)
                            }
                        }
                    } else {
                        more = oldHeight - newHeight
                    }
                    if (more > 0) {
                        for (var i = this.subHeaders.Count - 1; i >= 0; i--) {
                            var header = this.subHeaders[i];
                            if (header.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Fixed) {
                                var newHeaderHeight = header.getHeight() - more;
                                if (newHeaderHeight < minSize) {
                                    newHeaderHeight = minSize
                                }
                                header.setHeightNoNotify(newHeaderHeight)
                            }
                        }
                    }
                }
            },
            ensureWidth: function(width) {
                if (this.subHeaders.length === 0) {
                    if (this.width < width) {
                        this.width = width
                    }
                } else {
                    for (var i = 0; i < this.subHeaders.length; i++) {
                        this.subHeaders[i].ensureWidth(width)
                    }
                }
            },
            ensureHeight: function(height) {
                if (this.subHeaders.length === 0) {
                    if (this.height < height) {
                        this.height = height
                    }
                } else {
                    for (var i = 0; i < this.subHeaders.length; i++) {
                        this.subHeaders[i].ensureHeight(height)
                    }
                }
            },
            zeroWidth: function() {
                this.width = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    this.subHeaders[i].setWidth(0)
                }
            },
            zeroHeight: function() {
                this.height = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    this.subHeaders[i].setHeight(0)
                }
            },
            notifyHeaderChanged: function(header) {
                if (this.parent) {
                    this.parent.notifyHeaderChanged(header)
                }
            },
            setWidthNoNotify: function(value) {
                if (this.isColumnHeader()) {
                    if (value < this.getMinSize()) {
                        value = this.getMinSize()
                    }
                } else {
                    if (value < 0) {
                        value = 0
                    }
                }
                if (this.width === value) {
                    return
                }
                var prevWidth = this.width;
                if (this.subHeaders.length === 0) {
                    this.width = value;
                    return
                }
                var oldWidth = this.getWidth();
                this.width = value;
                if (this.isColumnHeader()) {
                    this.setChildrenWidths(oldWidth, this.width)
                }
                if (this.isRowHeader()) {
                    this.onRowHeaderWidthChanged(this, prevWidth)
                }
            },
            setHeightNoNotify: function(value) {
                if (this.isRowHeader()) {
                    if (value < this.getMinSize()) {
                        value = this.getMinSize()
                    }
                } else {
                    if (value < 0) {
                        value = 0
                    }
                }
                if (this.height === value) {
                    return
                }
                var prevHeight = this.height;
                if (this.subHeaders.length === 0) {
                    this.height = value;
                    if (this.isColumnHeader()) {
                        this.parent.onColumnHeaderHeightChanged(this, prevHeight)
                    }
                    return
                }
                var oldHeight = this.getHeight();
                this.height = value;
                if (this.isRowHeader()) {
                    this.setChildrenHeights(oldHeight, this.height)
                }
                if (this.isColumnHeader()) {
                    this.onColumnHeaderHeightChanged(this, prevHeight)
                }
            },
            onColumnHeaderHeightChanged: function(header, height) {
                this.parent.onColumnHeaderHeightChanged(header, height)
            },
            onRowHeaderWidthChanged: function(header, width) {
                this.parent.onRowHeaderWidthChanged(header, width)
            },
            getParent: function() {
                return this.parent
            },
            getSubHeaders: function() {
                return this.subHeaders
            },
            getDeepChildCount: function() {
                if (this.subHeaders.length === 0) {
                    return 1
                }
                var result = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    result += this.subHeaders[i].getDeepChildCount()
                }
                return result
            },
            getWidth: function() {
                if (this.subHeaders.length === 0) {
                    return this.width
                }
                if (this.isRowHeader()) {
                    return this.width
                }
                var totalWidth = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    totalWidth += this.subHeaders[i].getWidth()
                }
                if (totalWidth == 0) {
                    return this.width
                }
                return totalWidth
            },
            setWidth: function(value) {
                this.setWidthNoNotify(value)
            },
            getHeight: function() {
                if (this.subHeaders.length == 0) {
                    return this.height
                }
                if (this.isColumnHeader()) {
                    return this.height
                }
                var totalHeight = 0;
                for (var i = 0; i < this.subHeaders.length; i++) {
                    totalHeight += this.subHeaders[i].getHeight()
                }
                if (totalHeight == 0) {
                    return this.height
                }
                return totalHeight
            },
            setHeight: function(value) {
                this.setHeightNoNotify(value)
            },
            getResizeType: function() {
                return this.resizeType
            },
            setResizeType: function(value) {
                this.resizeType = value
            },
            getTitle: function() {
                return this.title
            },
            setTitle: function(value) {
                if (this.title === value) {
                    return
                }
                this.title = value;
                this.notifyHeaderChanged(this)
            },
            getRotateTitle: function() {
                return this.rotateTitle
            },
            setRotateTitle: function(value) {
                if (this.rotateTitle === value) {
                    return
                }
                this.rotateTitle = value;
                this.notifyHeaderChanged(this)
            },
            getStyle: function() {
                return this.style
            },
            setStyle: function(value) {
                if (!value) {
                    return
                }
                if (this.style === value) {
                    return
                }
                this.style = value;
                this.notifyHeaderChanged(this)
            },
            isColumnHeader: function() {
                if (this.parent) {
                    return this.parent.isColumnHeader()
                }
                return false
            },
            isRowHeader: function() {
                if (this.parent) {
                    return this.parent.isRowHeader()
                }
                return false
            },
            getMinSize: function() {
                if (this.parent) {
                    return this.parent.getMinSize()
                }
                return 0
            }
        };
        MindFusion.registerClass(Header, "MindFusion.Diagramming.Lanes.Header")
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var MasterHeader = mlanes.MasterHeader = function(grid, rowHeader) {
            mflayer.initializeBase(MasterHeader, this);
            this.grid = grid;
            this.rowHeader = rowHeader
        };
        MasterHeader.prototype = {
            fromJson: function(json) {
                mflayer.callBaseMethod(MasterHeader, this, "fromJson", [json]);
                this.rowHeader = json.rowHeader
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(MasterHeader, this, "toJson", []);
                json.rowHeader = this.rowHeader;
                return json
            },
            notifyHeaderChanged: function(header) {
                if (this.grid) {
                    this.grid.invalidate()
                }
            },
            isColumnHeader: function() {
                return !this.rowHeader
            },
            isRowHeader: function() {
                return this.rowHeader
            },
            getMinSize: function() {
                return this.grid.getMinHeaderSize()
            },
            onColumnHeaderHeightChanged: function(header, height) {
                this.grid.onColumnHeaderHeightChanged(header, height)
            },
            onRowHeaderWidthChanged: function(header, width) {
                this.grid.onRowHeaderWidthChanged(header, width)
            }
        };
        MindFusion.registerClass(MasterHeader, "MindFusion.Diagramming.Lanes.MasterHeader", mlanes.Header)
    })(MindFusion.Diagramming.Lanes);
    (function(mlanes) {
        var Style = mlanes.Style = function() {
            mflayer.initializeBase(Style, this)
        };
        Style.prototype = {
            fromJson: function(json) {
                this.backgroundBrush = json.backgroundBrush;
                this.leftBorderPen = json.leftBorderPen;
                this.leftBorderThickness = json.leftBorderThickness || 1;
                this.topBorderPen = json.topBorderPen;
                this.topBorderThickness = json.topBorderThickness || 1;
                this.rightBorderPen = json.rightBorderPen;
                this.rightBorderThickness = json.rightBorderThickness || 1;
                this.bottomBorderPen = json.bottomBorderPen;
                this.bottomBorderThickness = json.bottomBorderThickness || 1;
                this.textColor = json.textColor;
                this.fontName = json.fontName;
                this.fontSize = json.fontSize;
                this.textAlignment = json.textAlignment;
                this.lineAlignment = json.lineAlignment
            },
            toJson: function() {
                var json = {
                    backgroundBrush: this.backgroundBrush,
                    leftBorderPen: this.leftBorderPen,
                    leftBorderThickness: this.leftBorderThickness,
                    topBorderPen: this.topBorderPen,
                    topBorderThickness: this.topBorderThickness,
                    rightBorderPen: this.rightBorderPen,
                    rightBorderThickness: this.rightBorderThickness,
                    bottomBorderPen: this.bottomBorderPen,
                    bottomBorderThickness: this.bottomBorderThickness,
                    textColor: this.textColor,
                    fontName: this.fontName,
                    fontSize: this.fontSize,
                    textAlignment: this.textAlignment,
                    lineAlignment: this.lineAlignment
                };
                return json
            },
            saveToXml: function(xmlElement, context) {
                context.writeBrush(this.backgroundBrush, "BackgroundBrush", xmlElement);
                context.writePen({
                    brush: this.leftBorderPen,
                    width: this.leftBorderThickness
                }, "LeftBorderPen", xmlElement);
                context.writePen({
                    brush: this.topBorderPen,
                    width: this.toptBorderThickness
                }, "TopBorderPen", xmlElement);
                context.writePen({
                    brush: this.rightBorderPen,
                    width: this.rightBorderThickness
                }, "RightBorderPen", xmlElement);
                context.writePen({
                    brush: this.bottomBorderPen,
                    width: this.bottomBorderThickness
                }, "BottomBorderPen", xmlElement)
            },
            loadFromXml: function(xmlElement, context) {
                this.backgroundBrush = context.readBrush("BackgroundBrush", xmlElement);
                var pen = context.readPen("LeftBorderPen", xmlElement);
                if (pen) {
                    if (pen.brush) {
                        this.leftBorderPen = pen.brush
                    }
                    if (pen.width) {
                        this.leftBorderThickness = pen.width
                    }
                }
                pen = context.readPen("TopBorderPen", xmlElement);
                if (pen) {
                    if (pen.brush) {
                        this.topBorderPen = pen.brush
                    }
                    if (pen.width) {
                        this.rightBorderThickness = pen.width
                    }
                }
                pen = context.readPen("RightBorderPen", xmlElement);
                if (pen) {
                    if (pen.brush) {
                        this.rightBorderPen = pen.brush
                    }
                    if (pen.width) {
                        this.rightBorderThickness = pen.width
                    }
                }
                pen = context.readPen("BottomBorderPen", xmlElement);
                if (pen) {
                    if (pen.brush) {
                        this.bottomBorderPen = pen.brush
                    }
                    if (pen.width) {
                        this.bottomBorderThickness = pen.width
                    }
                }
            },
            getBackgroundBrush: function() {
                return this.backgroundBrush
            },
            setBackgroundBrush: function(value) {
                this.backgroundBrush = value
            },
            getLeftBorderPen: function() {
                return this.leftBorderPen
            },
            setLeftBorderPen: function(value) {
                this.leftBorderPen = value
            },
            getLeftBorderThickness: function() {
                return this.leftBorderThickness
            },
            setLeftBorderThickness: function(value) {
                this.leftBorderThickness = value
            },
            getTopBorderPen: function() {
                return this.topBorderPen
            },
            setTopBorderPen: function(value) {
                this.topBorderPen = value
            },
            getTopBorderThickness: function() {
                return this.topBorderThickness
            },
            setTopBorderThickness: function(value) {
                this.topBorderThickness = value
            },
            getRightBorderPen: function() {
                return this.rightBorderPen
            },
            setRightBorderPen: function(value) {
                this.rightBorderPen = value
            },
            getRightBorderThickness: function() {
                return this.rightBorderThickness
            },
            setRightBorderThickness: function(value) {
                this.rightBorderThickness = value
            },
            getBottomBorderPen: function() {
                return this.bottomBorderPen
            },
            setBottomBorderPen: function(value) {
                this.bottomBorderPen = value
            },
            getBottomBorderThickness: function() {
                return this.bottomBorderThickness
            },
            setBottomBorderThickness: function(value) {
                this.bottomBorderThickness = value
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextColor: function(value) {
                this.textColor = value
            },
            getFontName: function() {
                return this.fontName
            },
            setFontName: function(value) {
                this.fontName = value
            },
            getFontSize: function() {
                return this.fontSize
            },
            setFontSize: function(value) {
                this.fontSize = value
            },
            getTextAlignment: function() {
                return this.textAlignment
            },
            setTextAlignment: function(value) {
                this.textAlignment = value
            },
            getLineAlignment: function() {
                return this.lineAlignment
            },
            setLineAlignment: function(value) {
                this.lineAlignment = value
            }
        };
        MindFusion.registerClass(Style, "MindFusion.Diagramming.Lanes.Style")
    })(MindFusion.Diagramming.Lanes);
    return MindFusion
}));